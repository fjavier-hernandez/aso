{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Administraci\u00f3n de Sistemas Operativos \u00b6 Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Administraci\u00f3n de Sistemas Operativos , que se imparte en el segundo curso del ciclo formativo de grado superior de Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas , a raz\u00f3n de 6 horas semanales , y se desarrolla a lo largo de los dos primeros trimestres del curso . Se ha planificado bas\u00e1ndose en 3 sesiones lectivas por semana , con 2 horas de duraci\u00f3n cada una de ellas. \u00bfQu\u00e9 voy a aprender? \u00b6 Administrar sistemas operativos de servidor, instalando y configurando el software, en condiciones de calidad para asegurar el funcionamiento del sistema. Administrar servicios de recursos compartidos (acceso a directorios, impresi\u00f3n, accesos remotos, entre otros) instalando y configurando el software, en condiciones de calidad. Administrar usuarios de acuerdo a las especificaciones de explotaci\u00f3n para garantizar los accesos y la disponibilidad de los recursos del sistema. Gestionar los recursos de diferentes sistemas operativos (programando y verificando su cumplimiento). Resultados de aprendizaje \u00b6 Un Resultado de Aprendizaje \"es una declaraci\u00f3n de lo que el estudiante se espera que conozca, comprenda y sea capaz de hacer al finalizar un periodo de aprendizaje\". Los resultados de aprendizaje de ASO vienen definidos en el RD 1629/2009. Los Resultados de Aprendizaje de ASO son: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Gestiona la automatizaci\u00f3n de tareas del sistema, aplicando criterios de eficiencia y utilizando comandos y herramientas gr\u00e1ficas. Administra de forma remota el sistema operativo en red valorando su importancia y aplicando criterios de seguridad. Administra servidores de impresi\u00f3n describiendo sus funciones e integr\u00e1ndolos en una red. Integra sistemas operativos libres y propietarios, justificando y garantizando su interoperabilidad. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Unidades did\u00e1cticas / Temporalizaci\u00f3n \u00b6 A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas, repartidas en cada evaluaci\u00f3n con una duraci\u00f3n aproximada de 30 sesiones por evaluaci\u00f3n . Primera evaluaci\u00f3n \u00b6 ShellScripting. (5 sesiones) ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. ShellScripting, Re-direcciones, tuber\u00edas. Control de flujo en Shell, vectores. PowerShell. (5 sesiones) PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. PowerShell, Control de flujo, y vectores. Docker. Administraci\u00f3n de Procesos del Sistema. (5 sesiones) Procesos. Tipos. Estados. Estructura. Transiciones, Hilos. Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Gesti\u00f3n de procesos, demonios/servicios con Shell y Powershell. Servicios de Directorio Libres: LDAP. (6 sesiones) Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). LDAP, modelo informaci\u00f3n, Esquema. LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Servicios de Directorio Propietarios: Active Directory (9 sesiones). Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. AD, Permisos, directivas de grupo, perfiles y relaciones de confianza. Segunda evaluaci\u00f3n \u00b6 Integraci\u00f3n de Sistemas Libre: NFS (6 sesiones). Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de recursos compartidos. NFS, Instalaci\u00f3n, Permisos, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Integraci\u00f3n de Sistemas Propietarios: SAMBA (6 sesiones). SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de usuario y carpetas personales, cuotas. Informaci\u00f3n del sistema operativo (6 sesiones). Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. Rendimiento. Estad\u00edsticas. Planificaci\u00f3n de Tareas, Programador de tareas, crontab . Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Servicios de acceso y administraci\u00f3n remota (6 sesiones). Acceso remoto en modo texto SSH . Tunelizaci\u00f3n. Escritorio Remoto: RDP y xRDP. Acceso remoto de equipos en el AD con PWSH. Herramientas gr\u00e1ficas externas, TeamViewer, AnyDesk y Apache Guacamole. Administraci\u00f3n de Servidores de Impresi\u00f3n (6 sesiones). Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n. Servidor de impresi\u00f3n en GNU/Linux, CUPS . \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server. Instrumentos de Evaluaci\u00f3n \u00b6 La nota de cada evaluaci\u00f3n se calcula mediante la media ponderada de los puntos obtenidos, de los siguientes instrumentos de evaluaci\u00f3n. Trabajo en Clase/Actividades. Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos: 0: No entregada 1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta 2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto 3: Entregada y soluci\u00f3n correcta. Pruebas Espec\u00edficas. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 30 puntos. Una o dos pruebas por evaluaci\u00f3n.","title":"Inicio"},{"location":"index.html#administracion-de-sistemas-operativos","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Administraci\u00f3n de Sistemas Operativos , que se imparte en el segundo curso del ciclo formativo de grado superior de Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas , a raz\u00f3n de 6 horas semanales , y se desarrolla a lo largo de los dos primeros trimestres del curso . Se ha planificado bas\u00e1ndose en 3 sesiones lectivas por semana , con 2 horas de duraci\u00f3n cada una de ellas.","title":"Administraci\u00f3n de Sistemas Operativos"},{"location":"index.html#que-voy-a-aprender","text":"Administrar sistemas operativos de servidor, instalando y configurando el software, en condiciones de calidad para asegurar el funcionamiento del sistema. Administrar servicios de recursos compartidos (acceso a directorios, impresi\u00f3n, accesos remotos, entre otros) instalando y configurando el software, en condiciones de calidad. Administrar usuarios de acuerdo a las especificaciones de explotaci\u00f3n para garantizar los accesos y la disponibilidad de los recursos del sistema. Gestionar los recursos de diferentes sistemas operativos (programando y verificando su cumplimiento).","title":"\u00bfQu\u00e9 voy a aprender?"},{"location":"index.html#resultados-de-aprendizaje","text":"Un Resultado de Aprendizaje \"es una declaraci\u00f3n de lo que el estudiante se espera que conozca, comprenda y sea capaz de hacer al finalizar un periodo de aprendizaje\". Los resultados de aprendizaje de ASO vienen definidos en el RD 1629/2009. Los Resultados de Aprendizaje de ASO son: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Gestiona la automatizaci\u00f3n de tareas del sistema, aplicando criterios de eficiencia y utilizando comandos y herramientas gr\u00e1ficas. Administra de forma remota el sistema operativo en red valorando su importancia y aplicando criterios de seguridad. Administra servidores de impresi\u00f3n describiendo sus funciones e integr\u00e1ndolos en una red. Integra sistemas operativos libres y propietarios, justificando y garantizando su interoperabilidad. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo.","title":"Resultados de aprendizaje"},{"location":"index.html#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas, repartidas en cada evaluaci\u00f3n con una duraci\u00f3n aproximada de 30 sesiones por evaluaci\u00f3n .","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"index.html#primera-evaluacion","text":"ShellScripting. (5 sesiones) ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. ShellScripting, Re-direcciones, tuber\u00edas. Control de flujo en Shell, vectores. PowerShell. (5 sesiones) PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. PowerShell, Control de flujo, y vectores. Docker. Administraci\u00f3n de Procesos del Sistema. (5 sesiones) Procesos. Tipos. Estados. Estructura. Transiciones, Hilos. Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Gesti\u00f3n de procesos, demonios/servicios con Shell y Powershell. Servicios de Directorio Libres: LDAP. (6 sesiones) Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). LDAP, modelo informaci\u00f3n, Esquema. LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Servicios de Directorio Propietarios: Active Directory (9 sesiones). Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. AD, Permisos, directivas de grupo, perfiles y relaciones de confianza.","title":"Primera evaluaci\u00f3n"},{"location":"index.html#segunda-evaluacion","text":"Integraci\u00f3n de Sistemas Libre: NFS (6 sesiones). Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de recursos compartidos. NFS, Instalaci\u00f3n, Permisos, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Integraci\u00f3n de Sistemas Propietarios: SAMBA (6 sesiones). SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de usuario y carpetas personales, cuotas. Informaci\u00f3n del sistema operativo (6 sesiones). Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. Rendimiento. Estad\u00edsticas. Planificaci\u00f3n de Tareas, Programador de tareas, crontab . Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Servicios de acceso y administraci\u00f3n remota (6 sesiones). Acceso remoto en modo texto SSH . Tunelizaci\u00f3n. Escritorio Remoto: RDP y xRDP. Acceso remoto de equipos en el AD con PWSH. Herramientas gr\u00e1ficas externas, TeamViewer, AnyDesk y Apache Guacamole. Administraci\u00f3n de Servidores de Impresi\u00f3n (6 sesiones). Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n. Servidor de impresi\u00f3n en GNU/Linux, CUPS . \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server.","title":"Segunda evaluaci\u00f3n"},{"location":"index.html#instrumentos-de-evaluacion","text":"La nota de cada evaluaci\u00f3n se calcula mediante la media ponderada de los puntos obtenidos, de los siguientes instrumentos de evaluaci\u00f3n. Trabajo en Clase/Actividades. Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos: 0: No entregada 1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta 2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto 3: Entregada y soluci\u00f3n correcta. Pruebas Espec\u00edficas. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 30 puntos. Una o dos pruebas por evaluaci\u00f3n.","title":"Instrumentos de Evaluaci\u00f3n"},{"location":"ProgramacionAula.html","text":"TABLAS UUDD \u00b6 UD1 SHELLSCRIPTING \u00b6 .heatMap td { text-align: left; } .heatMap td:nth-child(1) { background: lightblue; } .heatMap td:nth-child(3) { background: lightblue; } table caption { padding: 10px; background: #85ABB8; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } TABLA RESUMEN DE UNIDAD Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Aprendizajes de car\u00e1cter transversal Crear y ejecutar guiones en el terminal de bash de Linux/GNU. Conocer y utilizar variables, par\u00e1metros y operadores. Optimizar el c\u00f3digo de los scripts mediante tuberias y redirecciones. Dominar el control de flujo mediante estructuras alternativas e iterativas. Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento (14). Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. (16) Contenidos conceptuales Contenidos procedimentales Actividades de ense\u00f1anza y aprendizaje Actividades de ense\u00f1anza y aprendizaje Criterios de Evaluaci\u00f3n Instrumentos de Evaluaci\u00f3n Actividades de refuerzo Actividades de profundizaci\u00f3n","title":"TABLAS UUDD"},{"location":"ProgramacionAula.html#tablas-uudd","text":"","title":"TABLAS UUDD"},{"location":"ProgramacionAula.html#ud1-shellscripting","text":".heatMap td { text-align: left; } .heatMap td:nth-child(1) { background: lightblue; } .heatMap td:nth-child(3) { background: lightblue; } table caption { padding: 10px; background: #85ABB8; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } TABLA RESUMEN DE UNIDAD Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Aprendizajes de car\u00e1cter transversal Crear y ejecutar guiones en el terminal de bash de Linux/GNU. Conocer y utilizar variables, par\u00e1metros y operadores. Optimizar el c\u00f3digo de los scripts mediante tuberias y redirecciones. Dominar el control de flujo mediante estructuras alternativas e iterativas. Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento (14). Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. (16) Contenidos conceptuales Contenidos procedimentales Actividades de ense\u00f1anza y aprendizaje Actividades de ense\u00f1anza y aprendizaje Criterios de Evaluaci\u00f3n Instrumentos de Evaluaci\u00f3n Actividades de refuerzo Actividades de profundizaci\u00f3n","title":"UD1 SHELLSCRIPTING"},{"location":"RAsASO.html","text":"Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Criterios de evaluaci\u00f3n: a) Se han identificado la funci\u00f3n, los elementos y las estructuras l\u00f3gicas del servicio de directorio. b) Se ha determinado y creado el esquema del servicio de directorio. c) Se ha realizado la instalaci\u00f3n del servicio de directorio en el servidor. d) Se ha realizado la configuraci\u00f3n y personalizaci\u00f3n del servicio de directorio. e) Se ha integrado el servicio de directorio con otros servicios. f) Se han aplicado filtros de b\u00fasqueda en el servicio de directorio. g) Se ha utilizado el servicio de directorio como mecanismo de acreditaci\u00f3n centralizada de los usuarios en una red. h) Se ha realizado la configuraci\u00f3n del cliente para su integraci\u00f3n en el servicio de directorio. i) Se han utilizado herramientas gr\u00e1ficas y comandos para la administraci\u00f3n del servicio de directorio. j) Se ha documentado la estructura e implantaci\u00f3n del servicio de directorio. Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Criterios de evaluaci\u00f3n: a) Se han descrito el concepto de proceso del sistema, tipos, estados y ciclo de vida. b) Se han utilizado interrupciones y excepciones para describir los eventos internos del procesador. c) Se ha diferenciado entre proceso, hilo y trabajo. d) Se han realizado tareas de creaci\u00f3n, manipulaci\u00f3n y terminaci\u00f3n de procesos. e) Se ha utilizado el sistema de archivos como medio l\u00f3gico para el registro e identificaci\u00f3n de los procesos del sistema. f) Se han utilizado herramientas gr\u00e1ficas y comandos para el control y seguimiento de los procesos del sistema. g) Se ha comprobado la secuencia de arranque del sistema, los procesos implicados y la relaci\u00f3n entre ellos. h) Se han tomado medidas de seguridad ante la aparici\u00f3n de procesos no identificados. i) Se han documentado los procesos habituales del sistema, su funci\u00f3n y relaci\u00f3n entre ellos. Gestiona la automatizaci\u00f3n de tareas del sistema, aplicando criterios de eficiencia y utilizando comandos y herramientas gr\u00e1ficas. Criterios de evaluaci\u00f3n: a) Se han descrito las ventajas de la automatizaci\u00f3n de las tareas repetitivas en el sistema. b) Se han utilizado los comandos del sistema para la planificaci\u00f3n de tareas. c) Se han establecido restricciones de seguridad. d) Se han realizado planificaciones de tareas repetitivas o puntuales relacionadas con la administraci\u00f3n del sistema. e) Se ha automatizado la administraci\u00f3n de cuentas. f) Se han instalado y configurado herramientas gr\u00e1ficas para la planificaci\u00f3n de tareas. g) Se han utilizado herramientas gr\u00e1ficas para la planificaci\u00f3n de tareas. h) Se han documentado los procesos programados como tareas autom\u00e1ticas. Administra de forma remota el sistema operativo en red valorando su importancia y aplicando criterios de seguridad. Criterios de evaluaci\u00f3n: a) Se han descrito m\u00e9todos de acceso y administraci\u00f3n remota de sistemas. b) Se ha diferenciado entre los servicios orientados a sesi\u00f3n y los no orientados a sesi\u00f3n. c) Se han utilizado herramientas de administraci\u00f3n remota suministradas por el propio sistema operativo. d) Se han instalado servicios de acceso y administraci\u00f3n remota. e) Se han utilizado comandos y herramientas gr\u00e1ficas para gestionar los servicios de acceso y administraci\u00f3n remota. f) Se han creado cuentas de usuario para el acceso remoto. g) Se han realizado pruebas de acceso y administraci\u00f3n remota entre sistemas heterog\u00e9neos. h) Se han utilizado mecanismos de encriptaci\u00f3n de la informaci\u00f3n transferida. i) Se han documentado los procesos y servicios del sistema administrados de forma remota. Administra servidores de impresi\u00f3n describiendo sus funciones e integr\u00e1ndolos en una red. Criterios de evaluaci\u00f3n: a) Se ha descrito la funcionalidad de los sistemas y servidores de impresi\u00f3n. b) Se han identificado los puertos y los protocolos utilizados. c) Se han utilizado las herramientas para la gesti\u00f3n de impresoras integradas en el sistema operativo. d) Se ha instalado y configurado un servidor de impresi\u00f3n en entorno Web. e) Se han creado y clasificado impresoras l\u00f3gicas. f) Se han creado grupos de impresi\u00f3n. g) Se han gestionado impresoras y colas de trabajos mediante comandos y herramientas gr\u00e1ficas. h) Se han compartido impresoras en red entre sistemas operativos diferentes. i) Se ha documentado la configuraci\u00f3n del servidor de impresi\u00f3n y de las impresoras creadas. Integra sistemas operativos libres y propietarios, justificando y garantizando su interoperabilidad. Criterios de evaluaci\u00f3n: a) Se ha identificado la necesidad de compartir recursos en red entre diferentes sistemas operativos. b) Se han establecido niveles de seguridad para controlar el acceso del cliente a los recursos compartidos en red. c) Se ha comprobado la conectividad de la red en un escenario heterog\u00e9neo. d) Se ha descrito la funcionalidad de los servicios que permiten compartir recursos en red. e) Se han instalado y configurado servicios para compartir recursos en red. f) Se ha comprobado el funcionamiento de los servicios instalados. g) Se ha trabajado en grupo para acceder a sistemas de archivos e impresoras en red desde equipos con diferentes sistemas operativos. h) Se ha documentado la configuraci\u00f3n de los servicios instalados. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Criterios de evaluaci\u00f3n: a) Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b) Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. c) Se han interpretado guiones de configuraci\u00f3n del sistema operativo. d) Se han realizado cambios y adaptaciones de guiones del sistema. e) Se han creado y probado guiones de administraci\u00f3n de servicios. f) Se han creado y probado guiones de automatizaci\u00f3n de tareas. g) Se han implantado guiones en sistemas libres y propietarios. h) Se han consultado y utilizado librer\u00edas de funciones. i) Se han documentado los guiones creados.","title":"RAsASO"},{"location":"planning.html","text":"Planificaci\u00f3n ASO (120h) \u00b6 1.- ShellScripting (10h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 1.1 ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 4h 1.2 ShellScripting, Redirecciones, tuberias. Desarrollo 3h 1.3 Control de flujo en Shell, vectores. Refuerzo y ampliaci\u00f3n 3h 2.- Programaci\u00f3n de Scripts (10h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 2.1 PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 3h 2.2 PowerShell, Control de flujo, y vectores. Desarrollo 3h 2.3 Python, creaci\u00f3n scripts, automatizaci\u00f3n Redes. Refuerzo y ampliaci\u00f3n 4h 3.- Servicios de Directorio Libres: LDAP (12h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 3.1 Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). Iniciales 4h 3.2 LDAP, m\u00f3delo informaci\u00f3n, Esquema. Desarrollo 4h 3.3 LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Refuerzo y ampliaci\u00f3n 4h 4.- Servicios de Directorio Propietarios: Active Directory (16h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 4.1 Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Iniciales 5h 4.2 Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. Desarrollo 5h 4.3 AD, Permisos, directivas de grupo, perfiles y relaciones de confianza. Ampliaci\u00f3n 6h 5.- Integraci\u00f3n de Sistemas Libre: NFS (12h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 5.1 NFS, Instalaci\u00f3n, Permisos en NFS. Iniciales 2h 5.2 NFS, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. Desarrollo 4h 5.3 NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Ampliaci\u00f3n 3h 6.- Integraci\u00f3n de Sistemas Propietarios: SAMBA (10h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 6.2 SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. Desarrollo 4h 6.3 SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de ususario y carpetas personales, cuotas. Ampliaci\u00f3n 3h 7.- Administraci\u00f3n de procesos del Sistema (14h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 7.1 Procesos. Tipos. Estados. Estructura. Trancisiones, Hilos. Iniciales 2h 7.2 Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Desarrollo I 2h 7.3 Gesti\u00f3n de procesos con Shell, Powershell y Python. Desarrollo II 6h 7.4 Secuencia de arranque del sistema. Demonios y servicios, systemd . Ampliaci\u00f3n 4h 8.- Informaci\u00f3n del sistema operativo (14h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 8.1 Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. \u00d3rdenes. Herramientas gr\u00e1ficas. Iniciales 2h 8.2 VFS, DFS, Herramientas gr\u00e1ficas Rendimiento. Estad\u00edsticas. Desarrollo I 4h 8.3 Planificaci\u00f3n de Tareas, Programacor de atreas, crontab . Desarrollo II 4h 8.4 Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Ampliaci\u00f3n 4h 9.- Servicios de acceso y administraci\u00f3n remota (14h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 9.1 Escritorio Remoto RDP, xRDP y RemoteAPP Iniciales y Desarrollo I 4h 9.2 Acceso remoto en modo texto SSH . Desarrollo II 4h 9.3 Herramientas gr\u00e1ficas externas, RealVNC, TeamViewer y AnyDesk. Desarrollo III 4h 9.4 Apache Guacamole. Ampliaci\u00f3n 2h 10.- Administraci\u00f3n de Servidores de Impresi\u00f3n (8h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 10.1 Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n Iniciales 2h 10.2 \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Desarrollo I 2h 10.3 Servidor de impresi\u00f3n en GNU/Linux, CUPS . Desarrollo II 2h 10.4 Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server. Desarrollo II 2h","title":"Planificaci\u00f3n ASO (120h)"},{"location":"planning.html#planificacion-aso-120h","text":"","title":"Planificaci\u00f3n ASO (120h)"},{"location":"planning.html#1-shellscripting-10h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 1.1 ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 4h 1.2 ShellScripting, Redirecciones, tuberias. Desarrollo 3h 1.3 Control de flujo en Shell, vectores. Refuerzo y ampliaci\u00f3n 3h","title":"1.- ShellScripting (10h)"},{"location":"planning.html#2-programacion-de-scripts-10h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 2.1 PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 3h 2.2 PowerShell, Control de flujo, y vectores. Desarrollo 3h 2.3 Python, creaci\u00f3n scripts, automatizaci\u00f3n Redes. Refuerzo y ampliaci\u00f3n 4h","title":"2.- Programaci\u00f3n de Scripts (10h)"},{"location":"planning.html#3-servicios-de-directorio-libres-ldap-12h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 3.1 Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). Iniciales 4h 3.2 LDAP, m\u00f3delo informaci\u00f3n, Esquema. Desarrollo 4h 3.3 LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Refuerzo y ampliaci\u00f3n 4h","title":"3.- Servicios de Directorio Libres: LDAP (12h)"},{"location":"planning.html#4-servicios-de-directorio-propietarios-active-directory-16h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 4.1 Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Iniciales 5h 4.2 Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. Desarrollo 5h 4.3 AD, Permisos, directivas de grupo, perfiles y relaciones de confianza. Ampliaci\u00f3n 6h","title":"4.- Servicios de Directorio Propietarios: Active Directory (16h)"},{"location":"planning.html#5-integracion-de-sistemas-libre-nfs-12h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 5.1 NFS, Instalaci\u00f3n, Permisos en NFS. Iniciales 2h 5.2 NFS, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. Desarrollo 4h 5.3 NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Ampliaci\u00f3n 3h","title":"5.- Integraci\u00f3n de Sistemas Libre: NFS (12h)"},{"location":"planning.html#6-integracion-de-sistemas-propietarios-samba-10h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 6.2 SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. Desarrollo 4h 6.3 SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de ususario y carpetas personales, cuotas. Ampliaci\u00f3n 3h","title":"6.- Integraci\u00f3n de Sistemas Propietarios: SAMBA (10h)"},{"location":"planning.html#7-administracion-de-procesos-del-sistema-14h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 7.1 Procesos. Tipos. Estados. Estructura. Trancisiones, Hilos. Iniciales 2h 7.2 Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Desarrollo I 2h 7.3 Gesti\u00f3n de procesos con Shell, Powershell y Python. Desarrollo II 6h 7.4 Secuencia de arranque del sistema. Demonios y servicios, systemd . Ampliaci\u00f3n 4h","title":"7.- Administraci\u00f3n de procesos del Sistema (14h)"},{"location":"planning.html#8-informacion-del-sistema-operativo-14h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 8.1 Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. \u00d3rdenes. Herramientas gr\u00e1ficas. Iniciales 2h 8.2 VFS, DFS, Herramientas gr\u00e1ficas Rendimiento. Estad\u00edsticas. Desarrollo I 4h 8.3 Planificaci\u00f3n de Tareas, Programacor de atreas, crontab . Desarrollo II 4h 8.4 Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Ampliaci\u00f3n 4h","title":"8.- Informaci\u00f3n del sistema operativo (14h)"},{"location":"planning.html#9-servicios-de-acceso-y-administracion-remota-14h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 9.1 Escritorio Remoto RDP, xRDP y RemoteAPP Iniciales y Desarrollo I 4h 9.2 Acceso remoto en modo texto SSH . Desarrollo II 4h 9.3 Herramientas gr\u00e1ficas externas, RealVNC, TeamViewer y AnyDesk. Desarrollo III 4h 9.4 Apache Guacamole. Ampliaci\u00f3n 2h","title":"9.- Servicios de acceso y administraci\u00f3n remota (14h)"},{"location":"planning.html#10-administracion-de-servidores-de-impresion-8h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 10.1 Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n Iniciales 2h 10.2 \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Desarrollo I 2h 10.3 Servidor de impresi\u00f3n en GNU/Linux, CUPS . Desarrollo II 2h 10.4 Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server. Desarrollo II 2h","title":"10.- Administraci\u00f3n de Servidores de Impresi\u00f3n (8h)"},{"location":"01_ShellScripting/index.html","text":"Programaci\u00f3n de Aula \u00b6 Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Detalle de la programaci\u00f3n de Aula: Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 07/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Argumentos, Variables. Introducci\u00f3n ShellScripting 2 09/09/22 Sintaxis, Interacci\u00f3n con el usuario, Operadores, redirecciones y tuberias. Sintaxis ShellScripting 3 12/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 14/09/22 Vectores y funciones Vectores y Funciones. 5 16/09/22 Refuerzo y Ampliaci\u00f3n Refuerzo y Ampliaci\u00f3n. 6 19/09/22 Prueba Espec\u00edfica Prueba Espec\u00edfica.","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/index.html#programacion-de-aula","text":"Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Detalle de la programaci\u00f3n de Aula: Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 07/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Argumentos, Variables. Introducci\u00f3n ShellScripting 2 09/09/22 Sintaxis, Interacci\u00f3n con el usuario, Operadores, redirecciones y tuberias. Sintaxis ShellScripting 3 12/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 14/09/22 Vectores y funciones Vectores y Funciones. 5 16/09/22 Refuerzo y Ampliaci\u00f3n Refuerzo y Ampliaci\u00f3n. 6 19/09/22 Prueba Espec\u00edfica Prueba Espec\u00edfica.","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/011_ShellScript_Intro.html","text":"Introducci\u00f3n \u00b6 Para administrar sistemas operativos es crucial manejar y dominar las interfaces (terminales) disponibles que nos permiten gestionarlos. Entre dichas interfaces destacan los siguientes tipos: De l\u00edneas de texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos/ventanas ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario, ejemplo SIRI en IOS). Este tema se centra en Sistemas basados en c\u00f3digo libre del tipo UNIX, debido a su amplio despliegue en empresas para implementar servicios, m\u00e1s en concreto de distribuciones Linux/GNU . El CLI de las distribuciones de Linux/GNU es conocido como Shell o terminal, con esta interfaz es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas, debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura . Estructura de Linux NOTA Por lo tanto, es buena pr\u00e1ctica que el administrador del sistemas tenga conocimientos en el manejo y gesti\u00f3n del terminal Shell, as\u00ed como en la programaci\u00f3n de scripts . Shell \u00b6 En inform\u00e1tica, el shell o int\u00e9rprete de comandos , es el programa inform\u00e1tico que permite a los usuarios interactuar con el sistema, procesando las \u00f3rdenes que se le indican; adem\u00e1s provee una interfaz de usuario para acceder a los servicios del sistema operativo. Los comandos ejecutables desde el shell pueden clasificarse en internos (corresponden en realidad a \u00f3rdenes interpretadas por el propio shell) y externos (corresponden a ficheros ejecutables externos al shell, conocidos como guiones o scripts). IMPORTANTE: Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... A destacar: sh (Bourne Shell) : este shell fue usado desde las primeras versiones de Unix (Unix Versi\u00f3n 7). Recibe ese nombre por su desarrollador, Stephen Bourne , de los Laboratorios Bell de AT&T . bash : fue desarrollado para ser un superconjunto de la funcionalidad del Bourne Shell, siendo el int\u00e9rprete de comandos asignado por defecto a los usuarios en las distribuciones de Linux, por lo que es el shell empleado en la mayor\u00eda de las consolas de comandos de Linux. Se caracteriza por una gran funcionalidad adicional a la del Bourne Shell. Para intentar homogeneizar esta diversidad de shells, el IEEE defini\u00f3 un est\u00e1ndar de \u00abint\u00e9rprete de comandos\u00bb bajo la especificaci\u00f3n POSIX 1003.2 (tambi\u00e9n recogida como ISO 9945.2 ). La creaci\u00f3n de dicho est\u00e1ndar se bas\u00f3 en la sintaxis que presentaban m\u00faltiples shells de la familia Bourne shell. bash respeta completamente el est\u00e1ndar POSIX, sobre el que a\u00f1ade un n\u00famero considerable de extensiones (estructura select, arrays, mayor n\u00famero de operadores,\u2026). En este tema utilizaremos el Shell de bash . Formato comandos \u00b6 En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y min\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE . Principales comandos \u00b6 Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado Shell Script en GNU/Linux \u00b6 Un Shell script (guion) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell. Estructura general \u00b6 En su forma m\u00e1s b\u00e1sica, un shell-script puede ser un simple fichero de texto que contenga uno o varios comandos. Para ayudar a la identificaci\u00f3n del contenido a partir del nombre del archivo, es habitual que los shell scripts tengan la extensi\u00f3n \u00ab.sh\u00bb, Se seguir\u00e1 este criterio pero hay que tener en cuenta que es informativo y opcional. #!/bin/bash #********************************* #Este es mi primer script #********************************* echo Hola Mundo #Esto es un comentario, soy muy \u00fatil. Creaci\u00f3n Shell scripts \u00b6 Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: (ubicados en la carpeta que contiene el archivo), se pueden utilizar el siguiente archivo: ./script.sh Adem\u00e1s se puede utilizar otro m\u00e9todo que consiste en definir la carpeta dentro de la variable de entorno PATH (editando el fichero .bashrc .) Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH NOTA La primera forma ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado. El primer Shellscript \u00b6 Crea un ejemplo llamado listar.sh , se aconseja ejecutar los siguientes comandos de forma secuencial. cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \u201cListado realizado el \u201c $( date ) Comentarios \u00b6 Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Es el \"Shebang\" Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta. Depuraci\u00f3n \u00b6 Esta tarea no es sencilla en ShellScripting, aun as\u00ed se recomienda los siguientes m\u00e9todos de depuraci\u00f3n, apoyados en los siguientes argumentos a la hora de ejecutar el script: -x \u2192 Expande cada orden simple, e imprime por pantalla la orden con sus argumentos, y a continuaci\u00f3n su salida. -v \u2192 Imprime en pantalla cada elemento completo del script (estructura de control, \u2026) y a continuaci\u00f3n su salida. Adem\u00e1s en el propio Script se pueden utilizar los siguientes comandos: Comando Acci\u00f3n set -x set \u2013xv Activa las trazas/verbose. Se debe ubicar justo antes del trozo del script que se desea depurar. set +x set +xv Desactiva las trazas/verbose. Ubicarlo justo despu\u00e9s del trozo del script que se desea depurar. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un script que guarde en un fichero el listado de archivos y directorios de la carpeta etc , a posteriori que imprima por pantalla dicho listado. Modifica el script anterior para que adem\u00e1s muestre por pantalla el n\u00famero de l\u00edneas del archivo y el n\u00famero de palabras. Depura los ejercicios anteriores utilizando los argumentos -x y -v .","title":"1.1- Introducci\u00f3n"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#introduccion","text":"Para administrar sistemas operativos es crucial manejar y dominar las interfaces (terminales) disponibles que nos permiten gestionarlos. Entre dichas interfaces destacan los siguientes tipos: De l\u00edneas de texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos/ventanas ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario, ejemplo SIRI en IOS). Este tema se centra en Sistemas basados en c\u00f3digo libre del tipo UNIX, debido a su amplio despliegue en empresas para implementar servicios, m\u00e1s en concreto de distribuciones Linux/GNU . El CLI de las distribuciones de Linux/GNU es conocido como Shell o terminal, con esta interfaz es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas, debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura . Estructura de Linux NOTA Por lo tanto, es buena pr\u00e1ctica que el administrador del sistemas tenga conocimientos en el manejo y gesti\u00f3n del terminal Shell, as\u00ed como en la programaci\u00f3n de scripts .","title":"Introducci\u00f3n"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#shell","text":"En inform\u00e1tica, el shell o int\u00e9rprete de comandos , es el programa inform\u00e1tico que permite a los usuarios interactuar con el sistema, procesando las \u00f3rdenes que se le indican; adem\u00e1s provee una interfaz de usuario para acceder a los servicios del sistema operativo. Los comandos ejecutables desde el shell pueden clasificarse en internos (corresponden en realidad a \u00f3rdenes interpretadas por el propio shell) y externos (corresponden a ficheros ejecutables externos al shell, conocidos como guiones o scripts). IMPORTANTE: Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... A destacar: sh (Bourne Shell) : este shell fue usado desde las primeras versiones de Unix (Unix Versi\u00f3n 7). Recibe ese nombre por su desarrollador, Stephen Bourne , de los Laboratorios Bell de AT&T . bash : fue desarrollado para ser un superconjunto de la funcionalidad del Bourne Shell, siendo el int\u00e9rprete de comandos asignado por defecto a los usuarios en las distribuciones de Linux, por lo que es el shell empleado en la mayor\u00eda de las consolas de comandos de Linux. Se caracteriza por una gran funcionalidad adicional a la del Bourne Shell. Para intentar homogeneizar esta diversidad de shells, el IEEE defini\u00f3 un est\u00e1ndar de \u00abint\u00e9rprete de comandos\u00bb bajo la especificaci\u00f3n POSIX 1003.2 (tambi\u00e9n recogida como ISO 9945.2 ). La creaci\u00f3n de dicho est\u00e1ndar se bas\u00f3 en la sintaxis que presentaban m\u00faltiples shells de la familia Bourne shell. bash respeta completamente el est\u00e1ndar POSIX, sobre el que a\u00f1ade un n\u00famero considerable de extensiones (estructura select, arrays, mayor n\u00famero de operadores,\u2026). En este tema utilizaremos el Shell de bash .","title":"Shell"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#formato-comandos","text":"En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y min\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE .","title":"Formato comandos"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#principales-comandos","text":"Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado","title":"Principales comandos"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#shell-script-en-gnulinux","text":"Un Shell script (guion) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell.","title":"Shell Script en GNU/Linux"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#estructura-general","text":"En su forma m\u00e1s b\u00e1sica, un shell-script puede ser un simple fichero de texto que contenga uno o varios comandos. Para ayudar a la identificaci\u00f3n del contenido a partir del nombre del archivo, es habitual que los shell scripts tengan la extensi\u00f3n \u00ab.sh\u00bb, Se seguir\u00e1 este criterio pero hay que tener en cuenta que es informativo y opcional. #!/bin/bash #********************************* #Este es mi primer script #********************************* echo Hola Mundo #Esto es un comentario, soy muy \u00fatil.","title":"Estructura general"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#creacion-shell-scripts","text":"Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: (ubicados en la carpeta que contiene el archivo), se pueden utilizar el siguiente archivo: ./script.sh Adem\u00e1s se puede utilizar otro m\u00e9todo que consiste en definir la carpeta dentro de la variable de entorno PATH (editando el fichero .bashrc .) Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH NOTA La primera forma ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado.","title":"Creaci\u00f3n Shell scripts"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#el-primer-shellscript","text":"Crea un ejemplo llamado listar.sh , se aconseja ejecutar los siguientes comandos de forma secuencial. cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \u201cListado realizado el \u201c $( date )","title":"El primer Shellscript"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#comentarios","text":"Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Es el \"Shebang\" Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta.","title":"Comentarios"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#depuracion","text":"Esta tarea no es sencilla en ShellScripting, aun as\u00ed se recomienda los siguientes m\u00e9todos de depuraci\u00f3n, apoyados en los siguientes argumentos a la hora de ejecutar el script: -x \u2192 Expande cada orden simple, e imprime por pantalla la orden con sus argumentos, y a continuaci\u00f3n su salida. -v \u2192 Imprime en pantalla cada elemento completo del script (estructura de control, \u2026) y a continuaci\u00f3n su salida. Adem\u00e1s en el propio Script se pueden utilizar los siguientes comandos: Comando Acci\u00f3n set -x set \u2013xv Activa las trazas/verbose. Se debe ubicar justo antes del trozo del script que se desea depurar. set +x set +xv Desactiva las trazas/verbose. Ubicarlo justo despu\u00e9s del trozo del script que se desea depurar.","title":"Depuraci\u00f3n"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un script que guarde en un fichero el listado de archivos y directorios de la carpeta etc , a posteriori que imprima por pantalla dicho listado. Modifica el script anterior para que adem\u00e1s muestre por pantalla el n\u00famero de l\u00edneas del archivo y el n\u00famero de palabras. Depura los ejercicios anteriores utilizando los argumentos -x y -v .","title":"Actividades"},{"location":"01_ShellScripting/011_ShellScripting_Total.html","text":"Shell Scripting \u00b6 Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas libres . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados. Introducci\u00f3n Linux \u00b6 Breve Historia \u00b6 1969 La empresa AT&T desarrolla el sistema operativo UNIX y vendido posteriormente a Novell. 1983 Richard Stallman comienza el proyecto GNU (GNU is Not Unix) para crear un SO tipo UNIX pero de software libre. Software libre: Aquel software, que una vez adquirido (no tiene porque ser gratuito), puede ser usado, copiado, modificado y redistribuido, con cambios o mejoras. 1985 Microsoft publica Windows, un sistema operativo con interfaz gr\u00e1fica de usuario (GUI) para su sistema operativo MS-DOS. 1991 Linus Torvald comienza a programar el sistema operativo Linux (Linus + UNIX). El c\u00f3digo era totalmente nuevo, pero emulaba el funcionamiento del sistema operativo MINIX (Tanenbaum), con estructura de micronucleo. 1992 Se juntan el proyecto Linux y GNU \u2192 GNU/Linux. 2001 Se lanza el primer sistema operativo MAC (MAC OS X) con interfaz de escritorio. MAC est\u00e1 basado en UNIX. Principales Actores \u00b6 Principales Actores en la creaci\u00f3n de GNU/Linux Caracter\u00edsticas \u00b6 Software Libre \u2192 Cualquiera puede usarlo o descargarlo. Licencias GPL (General Public License) de GNU. La Licencia P\u00fablica General de GNU o m\u00e1s conocida por su nombre en ingl\u00e9s GNU General Public License es una licencia de derecho de autor ampliamente usada en el mundo del software libre y c\u00f3digo abierto, \u200b y garantiza a los usuarios finales la libertad de usar, estudiar, compartir y modificar el software. C\u00f3digo Abierto \u2192 Cualquiera puede ver y modificar el c\u00f3digo. En la siguiente tabla se muestra algunas de las principales caracter\u00edsticas. Tabla con algunas caracter\u00edsticas de Linux Distribuciones \u00b6 Gratuitas: Ubuntu, CentOS, Mint, Fedora, Knoppix, OpenSUSE. En el caso de Ubuntu sacan distribuciones LTS que tienen mayor tiempo de actualizaciones. Las versiones indican el a\u00f1o y el mes en que se saca dicha versi\u00f3n. Por ejemplo 17.04 (A\u00f1o 2017, Abril). Pago: RedHat o SUSE. Se paga por el soporte, no por el software en s\u00ed. Las distribuciones de pago tambi\u00e9n suelen tener sus versiones gratuitas. Principales distribuciones \u00b6 Algunas Distribuciones de Linux Shell \u00b6 En inform\u00e1tica, el shell o int\u00e9rprete de \u00f3rdenes o int\u00e9rprete de comandos es el programa inform\u00e1tico que provee una interfaz de usuario para acceder a los servicios del sistema operativo. Dependiendo del tipo de interfaz que empleen, los shells pueden ser: De l\u00edneas texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario). En un terminal (Shell) es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas. Debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura. Estructura de Linux Tip Es buena pr\u00e1ctica que el administrador del sistema tenga conocimientos en el manejo del terminal as\u00ed como en la programaci\u00f3n de scripts. Info Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... En este tema utilizaremos el Shell bash . Formato comandos \u00b6 En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y nim\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE . Principales comandos \u00b6 Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado Shell Script en GNU/Linux \u00b6 Un Shell script (gui\u00f3n) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell. Creaci\u00f3n Shell scripts \u00b6 Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: ubicados en la carpeta que contiene el archivo, se pueden utilizar tres formas: Se teclea el nombre del archivo en el terminal precedido del comando sh sh script.sh Precedido de un punto . . script.sh ./ script.sh Definir la carpeta dentro de la variable de entorno PATH (tambi\u00e9n editando el fichero .bashrc ). Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH Info Cualquiera de estas dos primeras formas ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado. El primer Shellscript \u00b6 Crea un ejemplo llamado listar.sh cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \"Listado realizado el\" $( date ) Comentarios \u00b6 Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta. Argumentos o Par\u00e1metros \u00b6 Son especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script ./script.sh Caballo Perro 675 Nueva El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito Variables \u00b6 Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos . Variables de entorno \u00b6 Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde busca los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio Entrada y salida del Shell Script \u00b6 Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo . echo \u00b6 Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla Modificador Funci\u00f3n -e para usar las opciones hay utilizar el modificador \\c Sirve para eliminar el salto de l\u00ednea natural del comando echo . \\n nueva l\u00ednea. \\t tabulador horizontal. \\v tabulador vertical. Info Si se antepone el s\u00edmbolo del d\u00f3lar delante de una variable, mostrar\u00e1 su contenido Si es necesario mostrar frases con espacios, debe situarse entre comillas Warning La orden echo permite expandir variables siempre que se usen las comillas dobles. Ejemplo: #!/bin/bash NOMBRE = Javi echo \u201chola $NOMBRE \u201d El texto mostrado por pantalla ser\u00e1: hola javi read \u00b6 Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Lo que hace read es detener la ejecuci\u00f3n del shell script y pasa el testigo al usuario. Hasta que \u00e9ste no introduzca los datos, la ejecuci\u00f3n del programa no avanzar\u00e1. Ejemplo: #!/bin/bash echo \u201cIntroduce tu nombre: \u201d read NOMBRE echo \u201cHola $NOMBRE \u201d Info Cuando se utiliza read con varios nombres de variables, el primer campo tecleado por el usuario se asigna a la primera variable, el segundo campo a la segunda y as\u00ed sucesivamente Ejemplo: #!/bin/bash read -p \u201cIntroduce tres n\u00fameros ( separados por un espacio ) : \u201d num1 num2 num3 echo \u201cLos n\u00famero introducidos son $num1 , $num2 y $num3 \u201d Info En este ejemplo se ha usado el modificador -p el cual permite imprimir un mensaje antes de la recogida de los datos, prescindiendo de primer comando echo del ejemplo anterior. Operadores en shell script \u00b6 Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es s\u00f3lo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos aritm\u00e9ticos \u00b6 Los operadores aritm\u00e9ticos realizan operaciones matem\u00e1ticas, como sumas o restas con operandos. \"Manipulan\" datos num\u00e9ricos, tanto enteros como reales. S\u00edmbolo Funci\u00f3n + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % modulo (resto) = asignaci\u00f3n Ejemplo: #!/bin/bash #********************************* #Esto es mi tercer script #********************************* NUMERO = 4 let SUMA = NUMERO+3 echo $SUMA NUMERO = 5 let SUMA = NUMERO+5 echo $SUMA NUMERO = 10 let SUMA = NUMERO-10 relacionales \u00b6 Este tipo de operadores tan s\u00f3lo devuelven dos posibles valores; verdadero o falso . Existen subtipos seg\u00fan se comparen cadenas o n\u00fameros. 1. Operadores relacionales para n\u00fameros Operador Acci\u00f3n -eq Comprueba si dos n\u00fameros son iguales. -ne Detecta si dos n\u00fameros son diferentes. -gt Revisa si la izquierda es mayor que derecha. -lt Verifica si la izquierda es menor que derecha. -ge Coteja si la izquierda es mayor o igual que derecha. -le Constata si la izquierda es menor o igual que derecha. 2. Operadores relacionales para cadenas de texto o de cuerda Operador Acci\u00f3n -z Comprueba si la longitud de la cadena es cero. -n Eval\u00faa si la longitud de la cadena no es cero. = Verifica si las cadenas son iguales. != Coteja si las cadenas son diferentes. cadena Revisa si la cadena es nula. 3. Operadores relacionales para archivos y directorios Operador Acci\u00f3n -a Comprueba si existe el archivo. -r Eval\u00faa si la longitud de la cadena no es cero. -w Confirma si existe el archivo y tiene permisos de escritura. -x Constata si existe el archivo y tiene permisos de ejecuci\u00f3n. -f Escruta si existe y es un fichero regular. -d Escruta si existe y es un fichero regular. -h Coteja si existe y es un enlace. -s Revisa si existe el archivo y su tama\u00f1o es mayor a cero. l\u00f3gicos \u00b6 Se utilizan para evaluar condiciones, no elementos. Comprueba el resultado de dos operandos y devuelve verdadero o falso en funci\u00f3n del valor que arrojen los operandos. Los tipos son: Operador Acci\u00f3n && AND , devuelve verdadero si todas condiciones que eval\u00faa son verdaderas. Se puede representar: -a o && . || OR , da como resultado verdadero si alguna de las condiciones que eval\u00faa es verdadera. Se representar: -o o || . ! negaci\u00f3n , invierte el significado del operando. de verdadero a falso, y viceversa. Con ! o not . Info Para realizar c\u00e1lculos aritm\u00e9ticos es necesario utilizar expresiones como expr , let o los expansores . expr \u00b6 Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Cada t\u00e9rmino de la expresi\u00f3n debe ir separado por espacios en blanco. Soporta diferentes operaciones: sumar, restar, multiplicar y dividir enteros utilizando los operadores aritm\u00e9ticos para el c\u00e1lculo del m\u00f3dulo. Tip MEJOR NO UTILIZAR Desafortunadamente, expr es dif\u00edcil de utilizar debido a las colisiones entre su sintaxis y la propia del terminal. Puesto que * es el s\u00edmbolo comod\u00edn, deber\u00e1 ir precedido por una barra invertida para que el terminal lo interprete literalmente como un asterisco. Adem\u00e1s, es muy inc\u00f3modo de trabajar ya que los espacios entre los elementos de una expresi\u00f3n son cr\u00edticos. Ejemplo: #!/bin/bash var = 5 resultado = ` expr $1 + $var + 1 echo $resultado ` let \u00b6 Facilita la sintaxis de estas operaciones aritm\u00e9ticas reduci\u00e9ndolas a la m\u00ednima expresi\u00f3n. No es necesario incluir el s\u00edmbolo del d\u00f3lar que precede a las variables. Se configura como un comando m\u00e1s c\u00f3modo de ejecutar. Ejemplo: #!/bin/bash var = 5 let resultado = $1 +var+1 echo $resultado expansores \u00b6 Para las operaciones aritm\u00e9ticas se utilizan los dobles par\u00e9ntesis. Realizan la operaci\u00f3n contenida dentro de ellos lanzando la ejecuci\u00f3n fuera de ellos una vez resuelta. Ejemplo: #!/bin/bash var = 5 echo $(( $1 + $var + 1 )) echo $(( $1 + $var + 1 )) Tip Consejo de uso , ya que es mucho m\u00e1s intuitivo que las anteriores expresiones. Redirecciones \u00b6 Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado . Tuber\u00edas \u00b6 Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuberias para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo. alias \u00b6 Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019 Sistema de notaci\u00f3n \u00b6 Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos. Diagramas de flujo \u00b6 Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. Note Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En lo sucesivo se ilustrar\u00e1n las diferentes estructuras de control a trav\u00e9s de esta t\u00e9cnica la cual facilita su comprensi\u00f3n. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas. Control de flujo \u00b6 Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estrcuturas que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for . Estructuras condicionales \u00b6 Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ). Estructura alternativa doble: if \u00b6 La forma general de la orden if es: if [ expresi\u00f3n ] then realizar este c\u00f3digo si expresi\u00f3n es verdadera fi Estructura alternativa simple. Ejemplo: if [ $# -eq 1 ] then VAR = $1 fi Info El c\u00f3digo anterior comprueba se ha pasado alg\u00fan argumento ,es decir, si han pasado un par\u00e1metro. En caso afirmativo, asigna el contenido de ese par\u00e1metro a la variable VAR. Warning Hay que recordar siempre cerrar esta estructura para indicarle al terminal donde termina, en este caso, se cierra con la palabra reservada fi . Estructura alternativa multiple if then else \u00b6 En este caso se contempla tambi\u00e9n la posibilidad de ejecutar alguna acci\u00f3n si no se cumple la expresi\u00f3n. La forma general del if then else es: if [ expresi\u00f3n ] then realizar si expresi\u00f3n es verdadera else realizar si expresi\u00f3n es falsa fi Estructura alternativa doble. Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" else echo \" $a es menor que $b \" fi La estructura if then elif else \u00b6 Permite una segunda evaluaci\u00f3n para ejecutar c\u00f3digo a trav\u00e9s de la estructura elif . Es posible colocar tantos elif como condiciones se requiera evaluar. La forma general del if then elif else es: if [ exp1 ] then realizar si exp1 es verdadera elif [ exp2 ] then realizar si exp1 es falsa, pero es verdadera exp2 elif [ exp3 ] then realizar si exp1 y exp2 son falsas, pero es verdadera exp3 else realizar si todas las expresiones son falsas fi Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" elif [ $a -eq $b ] then echo \" $a es igual que $b \" else echo \" $a es menor que $b \" fi Info Este ejemplo ampl\u00eda el anterior comprobando si, adem\u00e1s, los valores de a y b son iguales. Warning El \u00faltimo caso se realiza con la sentencia else . La estructura case \u00b6 La estructura case permite realizar varias acciones en funci\u00f3n del valor de una variable. La limitaci\u00f3n que tan s\u00f3lo se comprueba si es igual a ese valor. La forma general del case es: case VARIABLE in valor1 ) Se ejecuta si VARIABLE tiene el valor1 ;; valor2 ) Se ejecuta si VARIABLE tiene el valor2 ;; * ) Se ejecuta por defecto ;; esac Estructura Alternativa Multiple. Estructuras de iteraci\u00f3n \u00b6 Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. Info La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. Info La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno, o bien los valores booleanos verdadero o falso. Info Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa. Las estructuras while y until \u00b6 Estas estructuras van a repetir el c\u00f3digo que contienen mientras la expresi\u00f3n evaluada sea verdadera. El funcionamiento es l\u00f3gico: Eval\u00faa la condici\u00f3n, si es falsa, no realiza ninguna acci\u00f3n y continua con el siguiente c\u00f3digo del programa. Si es verdadera entra en el bucle y ejecuta el c\u00f3digo que contiene. Al finalizar la ejecuci\u00f3n, al iterar, vuelve a evaluar la condici\u00f3n y vuelve a repetir la operaci\u00f3n anterior. Warning Al construir una estructura while es preciso asegurarse que en alg\u00fan momento de su ejecuci\u00f3n la condici\u00f3n dejar\u00e1 de cumplirse y se romper\u00e1 el ciclo, si no, \u00e9ste ser\u00e1 infinito, a menos que el usuario o el sistema interrumpa su ejecuci\u00f3n. WHILE while [ expresi\u00f3n ] do c\u00f3digo se repite MIENTRAS la expresi\u00f3n sea verdadera done UNTIL until [ expresi\u00f3n ] do c\u00f3digo se repite HASTA que la expresi\u00f3n sea verdadera done Info La diferencia es que un until se ejecuta como m\u00ednimo una vez, ya que ejecuta el c\u00f3digo y luego comprueba, mientras que el while es posible que nunca se ejecute, ya que es posible que la condici\u00f3n de entrada nunca se cumpla. Ejemplo: while [ expresi\u00f3n ] #! /bin/bash read -p \u201cEscribe un n\u00famero: \u201c num i = 1 while [ $i -le 10 ] do let res = num*i echo \u201c $i x $num = $res \u201d let i = i+1 done Info Este c\u00f3digo imprime por pantalla la tabla de multiplicar del n\u00famero que el usuario ha especificado. Las l\u00edneas contenidas entre do y done se ejecutar\u00e1n mientras i sea menor o igual a diez. Al final de cada iteraci\u00f3n el valor de i se incrementa en uno (es un contador) por lo que en diez iteraciones la condici\u00f3n dejar\u00e1 de cumplirse y el bucle se romper\u00e1. La estructuras for \u00b6 Esta estructura permite repetir c\u00f3digo por cada elemento de un conjunto determinado. No necesita condici\u00f3n de salida ya que al finalizar los elementos del conjunto acabar\u00e1 con su ejecuci\u00f3n. la forma general es: for variable in conjunto do estas l\u00edneas se repiten una vez por cada elemento del conjunto variable toma los valores del conjunto, uno en cada iteraci\u00f3n done * Ejemplo: #! /bin/bash read -p \u201cEscribe la direcci\u00f3n de una carpeta: \u201c car for i in $( ls $car ) do if [ -f $i ] then echo \u201c $i es un archivo de tipo regular\u201d elif [ -d $i ] then echo \u201c $i es un archivo de tipo directorio\u201d else echo \u201c $i es otro tipo de archivo o no existe\u201d fi done Info Este ejemplo se van a mostrar los nombres de los ficheros que contiene un directorio y dir\u00e1 si es un directorio o un fichero. Romper un bucle de forma deliberada \u00b6 No s\u00f3lo es posible terminar un bucle cuando se cumpla una condici\u00f3n o cuando se terminen los elementos de un conjunto, shell script proporciona dos formas de alterar el funcionamiento de la estructura en un bucle y romperla en funci\u00f3n de las necesidades del programa: break rompe el bucle que lo contiene y contin\u00faa la ejecuci\u00f3n del script. continue rompe la iteraci\u00f3n que lo contiene, pero mantiene el bucle, que continuar\u00e1 con la siguiente iteraci\u00f3n hasta que termine su ejecuci\u00f3n. exit detiene la ejecuci\u00f3n del script. Este comando no es exclusivo de las estructuras iterativas, pero cobra especial sentido en este \u00e1mbito. Vectores en shell script \u00b6 Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, por ejemplo, para recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done Funciones en shell script \u00b6 Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se identifican a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 } En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Actividades iniciales \u00b6 Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b Actividades de desarrollo UD1_01 \u00b6 Modifica el shell script realizado en el ejercicio 102 para comprobar si el fichero existe. En tal caso debe contar el n\u00famero de l\u00edneas del mismo a trav\u00e9s del comando wc y mostrar un mensaje indicando dicho n\u00famero. Si el fichero no existe, debe mostrar un mensaje de error y salir. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until . Actividades de desarrollo UD1_02 \u00b6 Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Crea un shell script para jugar a \u201cDoble o Nada\u201d. Consistir\u00e1 en adivinar un n\u00famero entre 1 y 10 (este n\u00famero ser\u00e1 generado al azar por el ordenador, para ello debes utilizar la funci\u00f3n $RANDOM de la siguiente manera numero=$RANDOM % 10 ). * A\u00f1ade al juego las siguientes caracter\u00edsticas: El jugador apuesta una cantidad de un valor inicial de 100 puntos. Si sale cara obtiene el doble de la cantidad apostada. Si sale cruz pierde todo lo apostado. El shell script debe llevar la cuenta de las tiradas y de la cantidad ganada. Al final de la partida mostrar\u00e1 un informe por pantalla a modo de resumen. Modificar el shell script anterior para que permita ir jugando hasta que el jugador decida abandonar el juego (para ello deber\u00e1 pulsar la tecla \u201cx\u201d del teclado), o no tenga m\u00e1s dinero que apostar. Tampoco podr\u00e1 apostar m\u00e1s dinero del que dispone en su \u201ccartera virtual\u201d. Actividades de desarrollo UD1_03 \u00b6 Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados.","title":"Shell Scripting"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#shell-scripting","text":"Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas libres . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados.","title":"Shell Scripting"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#introduccion-linux","text":"","title":"Introducci\u00f3n Linux"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#breve-historia","text":"1969 La empresa AT&T desarrolla el sistema operativo UNIX y vendido posteriormente a Novell. 1983 Richard Stallman comienza el proyecto GNU (GNU is Not Unix) para crear un SO tipo UNIX pero de software libre. Software libre: Aquel software, que una vez adquirido (no tiene porque ser gratuito), puede ser usado, copiado, modificado y redistribuido, con cambios o mejoras. 1985 Microsoft publica Windows, un sistema operativo con interfaz gr\u00e1fica de usuario (GUI) para su sistema operativo MS-DOS. 1991 Linus Torvald comienza a programar el sistema operativo Linux (Linus + UNIX). El c\u00f3digo era totalmente nuevo, pero emulaba el funcionamiento del sistema operativo MINIX (Tanenbaum), con estructura de micronucleo. 1992 Se juntan el proyecto Linux y GNU \u2192 GNU/Linux. 2001 Se lanza el primer sistema operativo MAC (MAC OS X) con interfaz de escritorio. MAC est\u00e1 basado en UNIX.","title":"Breve Historia"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#principales-actores","text":"Principales Actores en la creaci\u00f3n de GNU/Linux","title":"Principales Actores"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#caracteristicas","text":"Software Libre \u2192 Cualquiera puede usarlo o descargarlo. Licencias GPL (General Public License) de GNU. La Licencia P\u00fablica General de GNU o m\u00e1s conocida por su nombre en ingl\u00e9s GNU General Public License es una licencia de derecho de autor ampliamente usada en el mundo del software libre y c\u00f3digo abierto, \u200b y garantiza a los usuarios finales la libertad de usar, estudiar, compartir y modificar el software. C\u00f3digo Abierto \u2192 Cualquiera puede ver y modificar el c\u00f3digo. En la siguiente tabla se muestra algunas de las principales caracter\u00edsticas. Tabla con algunas caracter\u00edsticas de Linux","title":"Caracter\u00edsticas"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#distribuciones","text":"Gratuitas: Ubuntu, CentOS, Mint, Fedora, Knoppix, OpenSUSE. En el caso de Ubuntu sacan distribuciones LTS que tienen mayor tiempo de actualizaciones. Las versiones indican el a\u00f1o y el mes en que se saca dicha versi\u00f3n. Por ejemplo 17.04 (A\u00f1o 2017, Abril). Pago: RedHat o SUSE. Se paga por el soporte, no por el software en s\u00ed. Las distribuciones de pago tambi\u00e9n suelen tener sus versiones gratuitas.","title":"Distribuciones"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#principales-distribuciones","text":"Algunas Distribuciones de Linux","title":"Principales distribuciones"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#shell","text":"En inform\u00e1tica, el shell o int\u00e9rprete de \u00f3rdenes o int\u00e9rprete de comandos es el programa inform\u00e1tico que provee una interfaz de usuario para acceder a los servicios del sistema operativo. Dependiendo del tipo de interfaz que empleen, los shells pueden ser: De l\u00edneas texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario). En un terminal (Shell) es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas. Debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura. Estructura de Linux Tip Es buena pr\u00e1ctica que el administrador del sistema tenga conocimientos en el manejo del terminal as\u00ed como en la programaci\u00f3n de scripts. Info Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... En este tema utilizaremos el Shell bash .","title":"Shell"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#formato-comandos","text":"En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y nim\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE .","title":"Formato comandos"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#principales-comandos","text":"Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado","title":"Principales comandos"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#shell-script-en-gnulinux","text":"Un Shell script (gui\u00f3n) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell.","title":"Shell Script en GNU/Linux"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#creacion-shell-scripts","text":"Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: ubicados en la carpeta que contiene el archivo, se pueden utilizar tres formas: Se teclea el nombre del archivo en el terminal precedido del comando sh sh script.sh Precedido de un punto . . script.sh ./ script.sh Definir la carpeta dentro de la variable de entorno PATH (tambi\u00e9n editando el fichero .bashrc ). Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH Info Cualquiera de estas dos primeras formas ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado.","title":"Creaci\u00f3n Shell scripts"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#el-primer-shellscript","text":"Crea un ejemplo llamado listar.sh cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \"Listado realizado el\" $( date )","title":"El primer Shellscript"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#comentarios","text":"Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta.","title":"Comentarios"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#argumentos-o-parametros","text":"Son especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script ./script.sh Caballo Perro 675 Nueva El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito","title":"Argumentos o Par\u00e1metros"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#variables","text":"Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos .","title":"Variables"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#variables-de-entorno","text":"Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde busca los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio","title":"Variables de entorno"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#entrada-y-salida-del-shell-script","text":"Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo .","title":"Entrada y salida del Shell Script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#operadores-en-shell-script","text":"Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es s\u00f3lo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos","title":"Operadores en shell script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#redirecciones","text":"Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado .","title":"Redirecciones"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#tuberias","text":"Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuberias para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo.","title":"Tuber\u00edas"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#alias","text":"Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019","title":"alias"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#sistema-de-notacion","text":"Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos.","title":"Sistema de notaci\u00f3n"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#diagramas-de-flujo","text":"Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. Note Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En lo sucesivo se ilustrar\u00e1n las diferentes estructuras de control a trav\u00e9s de esta t\u00e9cnica la cual facilita su comprensi\u00f3n. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas.","title":"Diagramas de flujo"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#control-de-flujo","text":"Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estrcuturas que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for .","title":"Control de flujo"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#estructuras-condicionales","text":"Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ).","title":"Estructuras condicionales"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#estructuras-de-iteracion","text":"Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. Info La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. Info La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno, o bien los valores booleanos verdadero o falso. Info Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa.","title":"Estructuras de iteraci\u00f3n"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#vectores-en-shell-script","text":"Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, por ejemplo, para recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done","title":"Vectores en shell script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#funciones-en-shell-script","text":"Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se identifican a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 } En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3.","title":"Funciones en shell script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-iniciales","text":"Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b","title":"Actividades iniciales"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-de-desarrollo-ud1_01","text":"Modifica el shell script realizado en el ejercicio 102 para comprobar si el fichero existe. En tal caso debe contar el n\u00famero de l\u00edneas del mismo a trav\u00e9s del comando wc y mostrar un mensaje indicando dicho n\u00famero. Si el fichero no existe, debe mostrar un mensaje de error y salir. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until .","title":"Actividades de desarrollo UD1_01"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-de-desarrollo-ud1_02","text":"Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Crea un shell script para jugar a \u201cDoble o Nada\u201d. Consistir\u00e1 en adivinar un n\u00famero entre 1 y 10 (este n\u00famero ser\u00e1 generado al azar por el ordenador, para ello debes utilizar la funci\u00f3n $RANDOM de la siguiente manera numero=$RANDOM % 10 ). * A\u00f1ade al juego las siguientes caracter\u00edsticas: El jugador apuesta una cantidad de un valor inicial de 100 puntos. Si sale cara obtiene el doble de la cantidad apostada. Si sale cruz pierde todo lo apostado. El shell script debe llevar la cuenta de las tiradas y de la cantidad ganada. Al final de la partida mostrar\u00e1 un informe por pantalla a modo de resumen. Modificar el shell script anterior para que permita ir jugando hasta que el jugador decida abandonar el juego (para ello deber\u00e1 pulsar la tecla \u201cx\u201d del teclado), o no tenga m\u00e1s dinero que apostar. Tampoco podr\u00e1 apostar m\u00e1s dinero del que dispone en su \u201ccartera virtual\u201d.","title":"Actividades de desarrollo UD1_02"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-de-desarrollo-ud1_03","text":"Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados.","title":"Actividades de desarrollo UD1_03"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html","text":"Sintaxis \u00b6 Argumentos o Par\u00e1metros \u00b6 Son especificaciones que se le hacen al programa al momento de llamarlo. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script Si por ejemplo se enviasen los siguientes par\u00e1metros: ./script.sh Caballo Perro 675 Nueva Se obtendr\u00eda la siguiente salida: El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito Variables \u00b6 Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ . Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos . Variables de entorno \u00b6 Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde se buscan los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio Entrada y salida del Shell Script \u00b6 Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo . echo \u00b6 Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla Modificador Funci\u00f3n -e para usar las opciones hay que utilizar este modificador \\c Sirve para eliminar el salto de l\u00ednea natural del comando echo . \\n nueva l\u00ednea. \\t tabulador horizontal. \\v tabulador vertical. Info Si se antepone el s\u00edmbolo del d\u00f3lar delante de una variable, mostrar\u00e1 su contenido. Si es necesario mostrar frases con espacios, debe situarse entre comillas. Warning La orden echo permite expandir variables siempre que se usen las comillas dobles. Ejemplo: #!/bin/bash NOMBRE = Javi echo \u201chola $NOMBRE \u201d El texto mostrado por pantalla ser\u00e1: hola javi read \u00b6 Esta herramienta asigna el texto que el usuario ha escrito en el terminal a una o m\u00e1s variables. Lo que hace read es detener la ejecuci\u00f3n del shell script y pasa el testigo al usuario. Hasta que \u00e9ste no introduzca los datos, la ejecuci\u00f3n del programa no avanzar\u00e1. Ejemplo: #!/bin/bash echo \u201cIntroduce tu nombre: \u201d read NOMBRE echo \u201cHola $NOMBRE \u201d Info Cuando se utiliza read con varios nombres de variables, el primer campo tecleado por el usuario se asigna a la primera variable, el segundo campo a la segunda y as\u00ed sucesivamente Ejemplo: #!/bin/bash read -p \u201cIntroduce tres n\u00fameros ( separados por un espacio ) : \u201d num1 num2 num3 echo \u201cLos n\u00famero introducidos son $num1 , $num2 y $num3 \u201d Info En este ejemplo se ha usado el modificador -p el cual permite imprimir un mensaje antes de la recogida de los datos, prescindiendo de primer comando echo del ejemplo anterior. Operadores en shell script \u00b6 Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es solo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos Aritm\u00e9ticos \u00b6 Los operadores aritm\u00e9ticos realizan operaciones matem\u00e1ticas, como sumas o restas con operandos. \"Manipulan\" datos num\u00e9ricos, tanto enteros como reales. S\u00edmbolo Funci\u00f3n + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % modulo (resto) = asignaci\u00f3n Ejemplo: #!/bin/bash #********************************* #Esto es mi tercer script #********************************* NUMERO = 4 let SUMA = NUMERO+3 echo $SUMA NUMERO = 5 let SUMA = NUMERO+5 echo $SUMA NUMERO = 10 let SUMA = NUMERO-10 Relacionales \u00b6 Este tipo de operadores tan s\u00f3lo devuelven dos posibles valores; verdadero o falso . Existen subtipos seg\u00fan se comparen cadenas o n\u00fameros. 1. Operadores relacionales para n\u00fameros Operador Acci\u00f3n -eq Comprueba si dos n\u00fameros son iguales. -ne Detecta si dos n\u00fameros son diferentes. -gt Revisa si la izquierda es mayor que derecha. -lt Verifica si la izquierda es menor que derecha. -ge Coteja si la izquierda es mayor o igual que derecha. -le Constata si la izquierda es menor o igual que derecha. 2. Operadores relacionales para cadenas de texto o de cuerda Operador Acci\u00f3n -z Comprueba si la longitud de la cadena es cero. -n Eval\u00faa si la longitud de la cadena no es cero. = Verifica si las cadenas son iguales. != Coteja si las cadenas son diferentes. cadena Revisa si la cadena es nula. 3. Operadores relacionales para archivos y directorios Operador Acci\u00f3n -a Comprueba si existe el archivo. -r Eval\u00faa si el archivo esta vac\u00edo. -w Confirma si existe el archivo y tiene permisos de escritura. -x Constata si existe el archivo y tiene permisos de ejecuci\u00f3n. -f Escruta si existe y es un archivo de tipo regular. -d Escruta si existe y es un archivo de tipo directorio. -h Coteja si existe y es un enlace. -s Revisa si existe el archivo y su tama\u00f1o es mayor a cero. L\u00f3gicos \u00b6 Se utilizan para evaluar condiciones, no elementos. Comprueba el resultado de dos operandos y devuelve verdadero o falso en funci\u00f3n del valor que arrojen los operandos. Los tipos son: Operador Acci\u00f3n && AND , devuelve verdadero si todas condiciones que eval\u00faa son verdaderas. Se puede representar: -a o && . || OR , da como resultado verdadero si alguna de las condiciones que eval\u00faa es verdadera. Se representar: -o o || . ! negaci\u00f3n , invierte el significado del operando. de verdadero a falso, y viceversa. Con ! o not . Info Para realizar c\u00e1lculos aritm\u00e9ticos es necesario utilizar expresiones como expr , let o los expansores . expr \u00b6 Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Cada t\u00e9rmino de la expresi\u00f3n debe ir separado por espacios en blanco. Soporta diferentes operaciones: sumar, restar, multiplicar y dividir enteros utilizando los operadores aritm\u00e9ticos para el c\u00e1lculo del m\u00f3dulo. Tip MEJOR NO UTILIZAR Desafortunadamente, expr es dif\u00edcil de utilizar debido a las colisiones entre su sintaxis y la propia terminal. Puesto que * es el s\u00edmbolo comod\u00edn, deber\u00e1 ir precedido por una barra invertida para que el terminal lo interprete literalmente como un asterisco. Adem\u00e1s, es muy inc\u00f3modo de trabajar ya que los espacios entre los elementos de una expresi\u00f3n son cr\u00edticos. Ejemplo: #!/bin/bash var = 5 resultado = ` expr $1 + $var + 1 echo $resultado ` let \u00b6 Facilita la sintaxis de estas operaciones aritm\u00e9ticas reduci\u00e9ndolas a la m\u00ednima expresi\u00f3n. No es necesario incluir el s\u00edmbolo del d\u00f3lar que precede a las variables. Se configura como un comando m\u00e1s c\u00f3modo de ejecutar. Ejemplo: #!/bin/bash var = 5 let resultado = $1 +var+1 echo $resultado expansores \u00b6 Para las operaciones aritm\u00e9ticas se utilizan los dobles par\u00e9ntesis. Realizan la operaci\u00f3n contenida dentro de ellos lanzando la ejecuci\u00f3n fuera de ellos una vez resuelta. Ejemplo: #!/bin/bash var = 5 echo $(( $1 + $var + 1 )) echo $(( $1 + $var + 1 )) Tip Consejo de uso , ya que es mucho m\u00e1s intuitivo que las anteriores expresiones. Redirecciones \u00b6 Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado . Tuber\u00edas \u00b6 Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuber\u00edas para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo. alias \u00b6 Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019 Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b Realiza un script que muestre por pantalla los par\u00e1metros introducidos separados por espacio, el n\u00famero de par\u00e1metros que se han pasado, y el nombre del script. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Genera un script que muestre los usuarios conectados en el sistema operativo, comprobando que son usuarios dados de alta en el mismo.","title":"1.2- Sintaxis"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#sintaxis","text":"","title":"Sintaxis"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#argumentos-o-parametros","text":"Son especificaciones que se le hacen al programa al momento de llamarlo. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script Si por ejemplo se enviasen los siguientes par\u00e1metros: ./script.sh Caballo Perro 675 Nueva Se obtendr\u00eda la siguiente salida: El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito","title":"Argumentos o Par\u00e1metros"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#variables","text":"Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ . Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos .","title":"Variables"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#variables-de-entorno","text":"Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde se buscan los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio","title":"Variables de entorno"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#entrada-y-salida-del-shell-script","text":"Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo .","title":"Entrada y salida del Shell Script"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#echo","text":"Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla Modificador Funci\u00f3n -e para usar las opciones hay que utilizar este modificador \\c Sirve para eliminar el salto de l\u00ednea natural del comando echo . \\n nueva l\u00ednea. \\t tabulador horizontal. \\v tabulador vertical. Info Si se antepone el s\u00edmbolo del d\u00f3lar delante de una variable, mostrar\u00e1 su contenido. Si es necesario mostrar frases con espacios, debe situarse entre comillas. Warning La orden echo permite expandir variables siempre que se usen las comillas dobles. Ejemplo: #!/bin/bash NOMBRE = Javi echo \u201chola $NOMBRE \u201d El texto mostrado por pantalla ser\u00e1: hola javi","title":"echo"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#read","text":"Esta herramienta asigna el texto que el usuario ha escrito en el terminal a una o m\u00e1s variables. Lo que hace read es detener la ejecuci\u00f3n del shell script y pasa el testigo al usuario. Hasta que \u00e9ste no introduzca los datos, la ejecuci\u00f3n del programa no avanzar\u00e1. Ejemplo: #!/bin/bash echo \u201cIntroduce tu nombre: \u201d read NOMBRE echo \u201cHola $NOMBRE \u201d Info Cuando se utiliza read con varios nombres de variables, el primer campo tecleado por el usuario se asigna a la primera variable, el segundo campo a la segunda y as\u00ed sucesivamente Ejemplo: #!/bin/bash read -p \u201cIntroduce tres n\u00fameros ( separados por un espacio ) : \u201d num1 num2 num3 echo \u201cLos n\u00famero introducidos son $num1 , $num2 y $num3 \u201d Info En este ejemplo se ha usado el modificador -p el cual permite imprimir un mensaje antes de la recogida de los datos, prescindiendo de primer comando echo del ejemplo anterior.","title":"read"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#operadores-en-shell-script","text":"Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es solo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos","title":"Operadores en shell script"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#aritmeticos","text":"Los operadores aritm\u00e9ticos realizan operaciones matem\u00e1ticas, como sumas o restas con operandos. \"Manipulan\" datos num\u00e9ricos, tanto enteros como reales. S\u00edmbolo Funci\u00f3n + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % modulo (resto) = asignaci\u00f3n Ejemplo: #!/bin/bash #********************************* #Esto es mi tercer script #********************************* NUMERO = 4 let SUMA = NUMERO+3 echo $SUMA NUMERO = 5 let SUMA = NUMERO+5 echo $SUMA NUMERO = 10 let SUMA = NUMERO-10","title":"Aritm\u00e9ticos"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#relacionales","text":"Este tipo de operadores tan s\u00f3lo devuelven dos posibles valores; verdadero o falso . Existen subtipos seg\u00fan se comparen cadenas o n\u00fameros. 1. Operadores relacionales para n\u00fameros Operador Acci\u00f3n -eq Comprueba si dos n\u00fameros son iguales. -ne Detecta si dos n\u00fameros son diferentes. -gt Revisa si la izquierda es mayor que derecha. -lt Verifica si la izquierda es menor que derecha. -ge Coteja si la izquierda es mayor o igual que derecha. -le Constata si la izquierda es menor o igual que derecha. 2. Operadores relacionales para cadenas de texto o de cuerda Operador Acci\u00f3n -z Comprueba si la longitud de la cadena es cero. -n Eval\u00faa si la longitud de la cadena no es cero. = Verifica si las cadenas son iguales. != Coteja si las cadenas son diferentes. cadena Revisa si la cadena es nula. 3. Operadores relacionales para archivos y directorios Operador Acci\u00f3n -a Comprueba si existe el archivo. -r Eval\u00faa si el archivo esta vac\u00edo. -w Confirma si existe el archivo y tiene permisos de escritura. -x Constata si existe el archivo y tiene permisos de ejecuci\u00f3n. -f Escruta si existe y es un archivo de tipo regular. -d Escruta si existe y es un archivo de tipo directorio. -h Coteja si existe y es un enlace. -s Revisa si existe el archivo y su tama\u00f1o es mayor a cero.","title":"Relacionales"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#logicos","text":"Se utilizan para evaluar condiciones, no elementos. Comprueba el resultado de dos operandos y devuelve verdadero o falso en funci\u00f3n del valor que arrojen los operandos. Los tipos son: Operador Acci\u00f3n && AND , devuelve verdadero si todas condiciones que eval\u00faa son verdaderas. Se puede representar: -a o && . || OR , da como resultado verdadero si alguna de las condiciones que eval\u00faa es verdadera. Se representar: -o o || . ! negaci\u00f3n , invierte el significado del operando. de verdadero a falso, y viceversa. Con ! o not . Info Para realizar c\u00e1lculos aritm\u00e9ticos es necesario utilizar expresiones como expr , let o los expansores .","title":"L\u00f3gicos"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#expr","text":"Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Cada t\u00e9rmino de la expresi\u00f3n debe ir separado por espacios en blanco. Soporta diferentes operaciones: sumar, restar, multiplicar y dividir enteros utilizando los operadores aritm\u00e9ticos para el c\u00e1lculo del m\u00f3dulo. Tip MEJOR NO UTILIZAR Desafortunadamente, expr es dif\u00edcil de utilizar debido a las colisiones entre su sintaxis y la propia terminal. Puesto que * es el s\u00edmbolo comod\u00edn, deber\u00e1 ir precedido por una barra invertida para que el terminal lo interprete literalmente como un asterisco. Adem\u00e1s, es muy inc\u00f3modo de trabajar ya que los espacios entre los elementos de una expresi\u00f3n son cr\u00edticos. Ejemplo: #!/bin/bash var = 5 resultado = ` expr $1 + $var + 1 echo $resultado `","title":"expr"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#let","text":"Facilita la sintaxis de estas operaciones aritm\u00e9ticas reduci\u00e9ndolas a la m\u00ednima expresi\u00f3n. No es necesario incluir el s\u00edmbolo del d\u00f3lar que precede a las variables. Se configura como un comando m\u00e1s c\u00f3modo de ejecutar. Ejemplo: #!/bin/bash var = 5 let resultado = $1 +var+1 echo $resultado","title":"let"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#expansores","text":"Para las operaciones aritm\u00e9ticas se utilizan los dobles par\u00e9ntesis. Realizan la operaci\u00f3n contenida dentro de ellos lanzando la ejecuci\u00f3n fuera de ellos una vez resuelta. Ejemplo: #!/bin/bash var = 5 echo $(( $1 + $var + 1 )) echo $(( $1 + $var + 1 )) Tip Consejo de uso , ya que es mucho m\u00e1s intuitivo que las anteriores expresiones.","title":"expansores"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#redirecciones","text":"Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado .","title":"Redirecciones"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#tuberias","text":"Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuber\u00edas para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo.","title":"Tuber\u00edas"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#alias","text":"Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019","title":"alias"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b Realiza un script que muestre por pantalla los par\u00e1metros introducidos separados por espacio, el n\u00famero de par\u00e1metros que se han pasado, y el nombre del script. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Genera un script que muestre los usuarios conectados en el sistema operativo, comprobando que son usuarios dados de alta en el mismo.","title":"Actividades"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html","text":"Control de Flujo \u00b6 Sistema de notaci\u00f3n \u00b6 Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos. Diagramas de flujo \u00b6 Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. NOTA Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas. Estructuras \u00b6 Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estructuras que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for . Estructuras alternativas \u00b6 Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ). Estructura alternativa doble: if \u00b6 La forma general de la orden if es: if [ expresi\u00f3n ] then realizar este c\u00f3digo si expresi\u00f3n es verdadera fi Estructura alternativa simple. Ejemplo: if [ $# -eq 1 ] then VAR = $1 fi Info El c\u00f3digo anterior comprueba se ha pasado alg\u00fan argumento ,es decir, si han pasado un par\u00e1metro. En caso afirmativo, asigna el contenido de ese par\u00e1metro a la variable VAR. Warning Hay que recordar siempre cerrar esta estructura para indicarle al terminal donde termina, en este caso, se cierra con la palabra reservada fi . Estructura alternativa multiple if then else \u00b6 En este caso se contempla tambi\u00e9n la posibilidad de ejecutar alguna acci\u00f3n si no se cumple la expresi\u00f3n. La forma general del if then else es: if [ expresi\u00f3n ] then realizar si expresi\u00f3n es verdadera else realizar si expresi\u00f3n es falsa fi Estructura alternativa doble. Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" else echo \" $a es menor que $b \" fi La estructura if then elif else \u00b6 Permite una segunda evaluaci\u00f3n para ejecutar c\u00f3digo a trav\u00e9s de la estructura elif . Es posible colocar tantos elif como condiciones se requiera evaluar. La forma general del if then elif else es: if [ exp1 ] then realizar si exp1 es verdadera elif [ exp2 ] then realizar si exp1 es falsa, pero es verdadera exp2 elif [ exp3 ] then realizar si exp1 y exp2 son falsas, pero es verdadera exp3 else realizar si todas las expresiones son falsas fi Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" elif [ $a -eq $b ] then echo \" $a es igual que $b \" else echo \" $a es menor que $b \" fi Info Este ejemplo ampl\u00eda el anterior comprobando si, adem\u00e1s, los valores de a y b son iguales. Warning El \u00faltimo caso se realiza con la sentencia else . La estructura case \u00b6 La estructura case permite realizar varias acciones en funci\u00f3n del valor de una variable. La limitaci\u00f3n que tan s\u00f3lo se comprueba si es igual a ese valor. La forma general del case es: case VARIABLE in valor1 ) Se ejecuta si VARIABLE tiene el valor1 ;; valor2 ) Se ejecuta si VARIABLE tiene el valor2 ;; * ) Se ejecuta por defecto ;; esac Estructura Alternativa Multiple. Estructuras de iteraci\u00f3n \u00b6 Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. NOTA La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. NOTA La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno , o bien los valores booleanos verdadero o falso . NOTA Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa. Las estructuras while y until \u00b6 Estas estructuras van a repetir el c\u00f3digo que contienen mientras la expresi\u00f3n evaluada sea verdadera. Funcionamiento: Eval\u00faa la condici\u00f3n, si es falsa, no realiza ninguna acci\u00f3n y continua con el siguiente c\u00f3digo del programa. Si es verdadera entra en el bucle y ejecuta el c\u00f3digo que contiene. Al finalizar la ejecuci\u00f3n, al iterar, vuelve a evaluar la condici\u00f3n y vuelve a repetir la operaci\u00f3n anterior. Warning Al construir una estructura while es preciso asegurarse que en alg\u00fan momento de su ejecuci\u00f3n la condici\u00f3n dejar\u00e1 de cumplirse y se romper\u00e1 el ciclo, si no, \u00e9ste ser\u00e1 infinito, a menos que el usuario o el sistema interrumpa su ejecuci\u00f3n. WHILE while [ expresi\u00f3n ] do c\u00f3digo se repite MIENTRAS la expresi\u00f3n sea verdadera done UNTIL until [ expresi\u00f3n ] do c\u00f3digo se repite HASTA que la expresi\u00f3n sea verdadera done Info La diferencia es que un until se ejecuta como m\u00ednimo una vez, ya que ejecuta el c\u00f3digo y luego comprueba, mientras que el while es posible que nunca se ejecute, ya que es posible que la condici\u00f3n de entrada nunca se cumpla. Ejemplo: #! /bin/bash read -p \"Escribe un n\u00famero: \" num i = 1 while [ $i -le 10 ] do let res = num*i echo \" $i x $num = $res \" let i = i+1 done Info Este c\u00f3digo imprime por pantalla la tabla de multiplicar del n\u00famero que el usuario ha especificado. Las l\u00edneas contenidas entre do y done se ejecutar\u00e1n mientras i sea menor o igual a diez. Al final de cada iteraci\u00f3n el valor de i se incrementa en uno (es un contador) por lo que en diez iteraciones la condici\u00f3n dejar\u00e1 de cumplirse y el bucle se romper\u00e1. La estructuras for \u00b6 Esta estructura permite repetir c\u00f3digo por cada elemento de un conjunto determinado. No necesita condici\u00f3n de salida ya que al finalizar los elementos del conjunto acabar\u00e1 con su ejecuci\u00f3n. la forma general es: for variable in conjunto do estas l\u00edneas se repiten una vez por cada elemento del conjunto variable toma los valores del conjunto, uno en cada iteraci\u00f3n done * Ejemplo: #! /bin/bash read -p \u201cEscribe la direcci\u00f3n de una carpeta: \u201c car for i in $( ls $car ) do if [ -f $i ] then echo \u201c $i es un archivo de tipo regular\u201d elif [ -d $i ] then echo \u201c $i es un archivo de tipo directorio\u201d else echo \u201c $i es otro tipo de archivo o no existe\u201d fi done NOTA Este ejemplo se van a mostrar los nombres de los ficheros que contiene un directorio y dir\u00e1 si es un directorio o un fichero. Romper un bucle de forma deliberada \u00b6 No s\u00f3lo es posible terminar un bucle cuando se cumpla una condici\u00f3n o cuando se terminen los elementos de un conjunto, shell script proporciona dos formas de alterar el funcionamiento de la estructura en un bucle y romperla en funci\u00f3n de las necesidades del programa: break rompe el bucle que lo contiene y contin\u00faa la ejecuci\u00f3n del script. continue rompe la iteraci\u00f3n que lo contiene, pero mantiene el bucle, que continuar\u00e1 con la siguiente iteraci\u00f3n hasta que termine su ejecuci\u00f3n. exit detiene la ejecuci\u00f3n del script. Este comando no es exclusivo de las estructuras iterativas, pero cobra especial sentido en este \u00e1mbito. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until .","title":"1.3- Control de flujo"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#control-de-flujo","text":"","title":"Control de Flujo"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#sistema-de-notacion","text":"Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos.","title":"Sistema de notaci\u00f3n"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#diagramas-de-flujo","text":"Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. NOTA Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas.","title":"Diagramas de flujo"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#estructuras","text":"Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estructuras que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for .","title":"Estructuras"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#estructuras-alternativas","text":"Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ).","title":"Estructuras alternativas"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#estructuras-de-iteracion","text":"Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. NOTA La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. NOTA La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno , o bien los valores booleanos verdadero o falso . NOTA Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa.","title":"Estructuras de iteraci\u00f3n"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until .","title":"Actividades"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html","text":"Vectores y Funciones \u00b6 Vectores en shell script \u00b6 Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done Funciones en shell script \u00b6 Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se distinguen a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script utilizando funciones que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados. Genera un script que rellene un vector con diez n\u00fameros pedidos al usuario y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores los valores ordenados de menor a mayor en una sola l\u00ednea los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores cantidad de valores pares que contiene el vector la suma total de n\u00fameros impares la media aritm\u00e9tica de los valores que contiene el vector Crea un script que muestre las opciones del ejercicio anterior con select. El usuario introducir\u00e1 los valores del vector al iniciar el script. Cuando termine aparecer\u00e1 el men\u00fa de selecci\u00f3n (deber\u00e1s a\u00f1adir la opci\u00f3n para salir del script). Adem\u00e1s deber\u00e1s crear una funci\u00f3n para cada opci\u00f3n del men\u00fa y llamarla en cada una de las opciones del select.","title":"1.4- Vectores y Funciones"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#vectores-y-funciones","text":"","title":"Vectores y Funciones"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#vectores-en-shell-script","text":"Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done","title":"Vectores en shell script"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#funciones-en-shell-script","text":"Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se distinguen a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3.","title":"Funciones en shell script"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script utilizando funciones que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados. Genera un script que rellene un vector con diez n\u00fameros pedidos al usuario y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores los valores ordenados de menor a mayor en una sola l\u00ednea los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores cantidad de valores pares que contiene el vector la suma total de n\u00fameros impares la media aritm\u00e9tica de los valores que contiene el vector Crea un script que muestre las opciones del ejercicio anterior con select. El usuario introducir\u00e1 los valores del vector al iniciar el script. Cuando termine aparecer\u00e1 el men\u00fa de selecci\u00f3n (deber\u00e1s a\u00f1adir la opci\u00f3n para salir del script). Adem\u00e1s deber\u00e1s crear una funci\u00f3n para cada opci\u00f3n del men\u00fa y llamarla en cada una de las opciones del select.","title":"Actividades"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html","text":"Refuerzo y Ampliaci\u00f3n \u00b6 En esta sesi\u00f3n se trabajan actividades para reforzar los contenidos estudiados en esta unidad, y actividades de ampliaci\u00f3n para profundizar en dichos contenidos. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Refuerzo \u00b6 Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Modifica el shell script realizado en el ejercicio anterior para comprobar si el fichero existe. Si el fichero no existe, debe mostrar un mensaje de error y salir. Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Genera un script que muestre la tabla de multiplicar de un n\u00famero introducido por pantalla por el usuario. Ampliaci\u00f3n \u00b6 Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2). Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un shell script que funcione de manera similar a la papelera de reciclaje. El manejo de los ficheros se debe realizar a trav\u00e9s de vectores. El programa debe mostrar el siguiente men\u00fa e implementar sus operaciones que ser\u00e1n implementadas a trav\u00e9s de funciones: eliminar archivo . Esta operaci\u00f3n recibe la ruta completa de un archivo y lo mueve al directorio /home/tu_usuario/recycled. Si no existe dicho directorio, el programa ha de crearlo. restaurar archivo . Esta operaci\u00f3n recibe el nombre de un archivo y lo mueve, desde la papelera de reciclaje, al directorio en el que estuviera anteriormente. El proceso de eliminaci\u00f3n, debe haber almacenado, por tanto dicho directorio en un fichero de texto. restaurar toda la papelera. Esta operaci\u00f3n es similar a la anterior, pero se efect\u00faa sobre todos los ficheros de la papelera. vaciar la papelera . Esta opci\u00f3n vac\u00eda el contenido de la papelera. Ninguno de los archivos ser\u00e1 recuperable. mostrar la papelera . Esta opci\u00f3n muestra el contenido de la papelera. salir . Sale del programa.","title":"Refuerzo y Ampliaci\u00f3n"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#refuerzo-y-ampliacion","text":"En esta sesi\u00f3n se trabajan actividades para reforzar los contenidos estudiados en esta unidad, y actividades de ampliaci\u00f3n para profundizar en dichos contenidos.","title":"Refuerzo y Ampliaci\u00f3n"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#refuerzo","text":"Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Modifica el shell script realizado en el ejercicio anterior para comprobar si el fichero existe. Si el fichero no existe, debe mostrar un mensaje de error y salir. Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Genera un script que muestre la tabla de multiplicar de un n\u00famero introducido por pantalla por el usuario.","title":"Refuerzo"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#ampliacion","text":"Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2). Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un shell script que funcione de manera similar a la papelera de reciclaje. El manejo de los ficheros se debe realizar a trav\u00e9s de vectores. El programa debe mostrar el siguiente men\u00fa e implementar sus operaciones que ser\u00e1n implementadas a trav\u00e9s de funciones: eliminar archivo . Esta operaci\u00f3n recibe la ruta completa de un archivo y lo mueve al directorio /home/tu_usuario/recycled. Si no existe dicho directorio, el programa ha de crearlo. restaurar archivo . Esta operaci\u00f3n recibe el nombre de un archivo y lo mueve, desde la papelera de reciclaje, al directorio en el que estuviera anteriormente. El proceso de eliminaci\u00f3n, debe haber almacenado, por tanto dicho directorio en un fichero de texto. restaurar toda la papelera. Esta operaci\u00f3n es similar a la anterior, pero se efect\u00faa sobre todos los ficheros de la papelera. vaciar la papelera . Esta opci\u00f3n vac\u00eda el contenido de la papelera. Ninguno de los archivos ser\u00e1 recuperable. mostrar la papelera . Esta opci\u00f3n muestra el contenido de la papelera. salir . Sale del programa.","title":"Ampliaci\u00f3n"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html","text":"Prueba Espec\u00edfica \u00b6 Esta prueba consta de dos partes: Una primera parte con preguntas tipo test , con car\u00e1cter te\u00f3rico, con un peso del 40% en el total de la prueba. La segunda parte consta de ejercicios pr\u00e1cticos basados en los realizados durante la Unidad Did\u00e1ctica, con un valor del 60% del total. Test: \u00b6 En shell Script para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada y salida de datos, en este sentido se utilizan los siguientes comandos: listen/echo listen/write read/echo read/write \u00bfQu\u00e9 es un Script? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando echo... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. Una Tuber\u00eda ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. Los scripts de Shell son uno de los tipos de programas m\u00e1s habituales en todos los sistemas LINUX/GNU. #!/bin/bash en la primera l\u00ednea del shell script indica: Cambia el directorio a /bin/bash. Indica que se debe usar la shell bash para ejecutar el script. Ejecuta el comando /bin/bash y presenta el resultado en pantalla. Es un comentario que no indica nada. \u00bfQu\u00e9 es una variable? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. Una Redirecci\u00f3n ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. \u00bfQu\u00e9 es un Argumento o par\u00e1metro? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando read... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. El comando expr... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$resultado\" \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar del n\u00famero introducido por el usuario. Muestra por pantalla la tabla de multiplicar de la variable num. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash read -p \u201cEscribe un n\u00famero : \u201c num i=1 while [ $i -le 10 ] do let res=num*i echo \u201c$i x $num = $res\u201d let i=i+1 done Diagramas de Flujo ... Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\" + \"$num2\" Diagramas de Flujo ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa Estructuras condicionales ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar el par\u00e1metro 1 introducido al ejecutar el script. Muestra por pantalla la tabla de multiplicar del argumento $1. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash echo \u201cTabla del n\u00famero $1\u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res=$1*i echo \u201c$i x $1 = $res\u201d done \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1+$num2\" Estructuras iterativas ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\"\"$num2\" Pr\u00e1ctica \u00b6 Escribe tres shell script utilizando estructuras alternativas: El primero ej1A.sh, que pida al usuario tres n\u00fameros y los muestre ordenados de mayor a menor. Se deber\u00e1 comprobar que los datos facilitados por el usuario son v\u00e1lidos. El segundo ej1B.sh, que a partir de una fecha introducida por teclado con el formato D\u00cdA, MES, A\u00d1O, se obtenga la fecha del d\u00eda siguiente. El tercero ej1C.sh, que acepte una calificaci\u00f3n num\u00e9rica y visualice la correspondiente en letra: Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2) .","title":"Prueba Espec\u00edfica"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html#prueba-especifica","text":"Esta prueba consta de dos partes: Una primera parte con preguntas tipo test , con car\u00e1cter te\u00f3rico, con un peso del 40% en el total de la prueba. La segunda parte consta de ejercicios pr\u00e1cticos basados en los realizados durante la Unidad Did\u00e1ctica, con un valor del 60% del total.","title":"Prueba Espec\u00edfica"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html#test","text":"En shell Script para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada y salida de datos, en este sentido se utilizan los siguientes comandos: listen/echo listen/write read/echo read/write \u00bfQu\u00e9 es un Script? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando echo... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. Una Tuber\u00eda ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. Los scripts de Shell son uno de los tipos de programas m\u00e1s habituales en todos los sistemas LINUX/GNU. #!/bin/bash en la primera l\u00ednea del shell script indica: Cambia el directorio a /bin/bash. Indica que se debe usar la shell bash para ejecutar el script. Ejecuta el comando /bin/bash y presenta el resultado en pantalla. Es un comentario que no indica nada. \u00bfQu\u00e9 es una variable? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. Una Redirecci\u00f3n ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. \u00bfQu\u00e9 es un Argumento o par\u00e1metro? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando read... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. El comando expr... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$resultado\" \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar del n\u00famero introducido por el usuario. Muestra por pantalla la tabla de multiplicar de la variable num. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash read -p \u201cEscribe un n\u00famero : \u201c num i=1 while [ $i -le 10 ] do let res=num*i echo \u201c$i x $num = $res\u201d let i=i+1 done Diagramas de Flujo ... Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\" + \"$num2\" Diagramas de Flujo ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa Estructuras condicionales ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar el par\u00e1metro 1 introducido al ejecutar el script. Muestra por pantalla la tabla de multiplicar del argumento $1. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash echo \u201cTabla del n\u00famero $1\u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res=$1*i echo \u201c$i x $1 = $res\u201d done \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1+$num2\" Estructuras iterativas ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\"\"$num2\"","title":"Test:"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html#practica","text":"Escribe tres shell script utilizando estructuras alternativas: El primero ej1A.sh, que pida al usuario tres n\u00fameros y los muestre ordenados de mayor a menor. Se deber\u00e1 comprobar que los datos facilitados por el usuario son v\u00e1lidos. El segundo ej1B.sh, que a partir de una fecha introducida por teclado con el formato D\u00cdA, MES, A\u00d1O, se obtenga la fecha del d\u00eda siguiente. El tercero ej1C.sh, que acepte una calificaci\u00f3n num\u00e9rica y visualice la correspondiente en letra: Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2) .","title":"Pr\u00e1ctica"},{"location":"01_ShellScripting/ProgramacionAula.html","text":"Programaci\u00f3n de Aula \u00b6 Resultados de Aprendizaje \u00b6 Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Planificaci\u00f3n Temporal \u00b6 Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 14/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Comentarios, Depuraci\u00f3n. Introducci\u00f3n ShellScripting 2 15/09/22 Sintaxis, Argumentos, Variables, Interacci\u00f3n con el usuario, Operadores, re-direcciones y tuber\u00edas. Sintaxis ShellScripting 3 20/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 21/09/22 Vectores y funciones Vectores y Funciones. 5 22/09/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n.","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/ProgramacionAula.html#programacion-de-aula","text":"","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/ProgramacionAula.html#resultados-de-aprendizaje","text":"Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; }","title":"Resultados de Aprendizaje"},{"location":"01_ShellScripting/ProgramacionAula.html#planificacion-temporal","text":"Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 14/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Comentarios, Depuraci\u00f3n. Introducci\u00f3n ShellScripting 2 15/09/22 Sintaxis, Argumentos, Variables, Interacci\u00f3n con el usuario, Operadores, re-direcciones y tuber\u00edas. Sintaxis ShellScripting 3 20/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 21/09/22 Vectores y funciones Vectores y Funciones. 5 22/09/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n.","title":"Planificaci\u00f3n Temporal"},{"location":"01_ShellScripting/ResumenUD.html","text":"Resumen UD \u00b6 A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"01_ShellScripting/ResumenUD.html#resumen-ud","text":"A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"02_PowerShell/012_PowerShellTotal.html","text":"Power Shell \u00b6 Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas propietarios . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados. Introducci\u00f3n \u00b6 Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de autocompletado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsar la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un gui\u00f3n y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas. Primer Script \u00b6 Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./Script.ps1 Aunque tambi\u00e9n es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro . PowerShell ISE \u00b6 PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE. Comentarios \u00b6 Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multil\u00ednea. Par\u00e1metros en PowerShell \u00b6 Como ocurr\u00eda en GNU/Linux, los par\u00e1metros que reciba el script se deben recoger de forma interna en una variable para poder operar con ellos. Example param ([string]$nombre) Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"Hola de nuevo, tu nombre es $nombre\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable nombre. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./Script.ps1 \u201cF\u00ba Javier Hern\u00e1ndez Ill\u00e1n\u201d Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables . Variables \u00b6 Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable. Implicita \u00b6 Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9.99 $Final_2021 = 30 ${Mi variable} = \u201cContiene espacios en el nombre\u201d En la forma implicita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $feo.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable . Explicita \u00b6 Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [ float ] $numero = 9.99 [int] $Final_2021 = 30 [string] ${Mi variable} = \u201cContiene espacios en el nombre\u201d Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: que las caracter\u00edsticas del dato se modifiquen para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, o que se producir\u00e1 un error si esa conversi\u00f3n no es posible y se detenga el script. Interacci\u00f3n con el usuario \u00b6 PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [ string ] $feo = Read-Host \u201c\u00bfCu\u00e1l es el nombre del marine de Doom?\u201d Write-Host \u201cNo se sabe, pero lo has intentado con $feo\u201d Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript. Operadores \u00b6 Aritm\u00e9ticos \u00b6 Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [ int ] $a=10 [float] $b=20 [int] $res=$a+$b Write-Host $res Write-Host $a+$b Write-Host \"$a x $b = \" ($a*$b) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores. L\u00f3gicos \u00b6 Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host ((6 -ge 4) -and (7 -le 7)) Write-Host ((10 -gt 1) -or (2 -lt 2)) Write-Host ((1 -gt 0) -xor (4 -le 1)) Write-Host ( -not (12 -lt 10)) Write-Host (!(12 -lt 10)) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \u201cJavi\u201d -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \u201cJavi\u201d -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int]) Comparaci\u00f3n \u00b6 los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \u201cJavi\u201d -ieq \u201cjavi\u201d es verdadero -ceq Iguales. En cadenas es casesensitive. \u201cJavi\u201d -ceq \u201cjavi\u201d es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \u201ces como\u201d. \u201cPerro\u201d -like \u201cPe*\u201d es verdadero -notlike Eval\u00faa un patr\u00f3n \u201cno es como\u201d. \u201cPerro\u201d -notlike \u201cPe*\u201d es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso Control del flujo en PowerShell \u00b6 En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript. Alternativa Simple \u00b6 if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } Alternativa doble \u00b6 if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa } Alternativa m\u00faltiple \u00b6 if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas } El equivalente a case en GNU/Linux \u00b6 switch ($valor){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ($saludo){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } {$_ -is [string]} { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ($target){ '^ftp\\://.*$' { \"$_ is an ftp address\"; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\"; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $($matches[1])\"; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe u n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil : $_\"; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones. Estructuras iterativas \u00b6 while \u00b6 A diferencia de lo que ocurr\u00eda en GNU/Linux, en PowerShell existen diferencias entre las estructuras while, do while y do until . En este caso, la \u00fanica de las tres que evaluar\u00e1 la condici\u00f3n al inicio del bloque de c\u00f3digo ser\u00e1 la primera. El resto comprueba la condici\u00f3n al final del bloque ejecutando como m\u00ednimo una vez el c\u00f3digo que contiene. while ( condici\u00f3n ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } do { bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } while ( condici\u00f3n ) Existe una variante de esta estructura que se crea sustituyendo el while por un until . Esto cambia el sentido de la condici\u00f3n y es este caso el bloque se repite hasta que la condici\u00f3n se cumpla. Esta estructura no es muy utilizada, pero siempre es bueno contar con herramientas extra. for \u00b6 Tambi\u00e9n la estructura for es sensiblemente diferente que en shellscript. Esta estructura en PowerShell tiene m\u00e1s que ver con los lenguajes de programaci\u00f3n y se utiliza cuando el programador sabe el n\u00famero de iteraciones que hay que realizar para solucionar un problema. for ( inicializaci\u00f3n; condici\u00f3n; incremento ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } Por ejemplo, la creaci\u00f3n de la tabla de multiplicar de un n\u00famero especificado por el usuario. Para resolver este problema s\u00ed se conoce el n\u00famero de iteraciones necesarias, concretamente diez. Example $numero = Read-Host \"Dame un n\u00famero\" Write-Host \"Esta es la tabla del $num\" for ( $i=0; $i -lt 11; $i++){ Write-Host \" $i x $numero = \"($i*$numero) } foreach \u00b6 La estructura foreach en PowerShell es el equivalente a for en shellscript. Est\u00e1 pensada para recorrer un conjunto de valores y ejecutar el bloque de c\u00f3digo una vez por cada elemento del conjunto. foreach ( elemento in conjunto ){ bloque de c\u00f3digo a ejecutar por cada elemento del conjunto } Al igual que ocurre en GNU/Linux, el conjunto puede serlo de cualquier tipo de objetos, incluso los ficheros de una carpeta. En el siguiente ejemplo se buscan los ficheros que en su nombre contengan la cadena de texto que el usuario ha especificado: Example $ruta = \"C:\\Users\\Administrador\\Desktop\" $busca = Read-Host \"Escribe el texto a buscar\" foreach ($archivo in Get-ChildItem $ruta){ if ($archivo.Name.IndexOf($busca) -ge 0){ Write-Host $archivo.Name } } Note Las opciones que ofrece PowerShell en cuanto a estructuras de control parece una oferta m\u00e1s completa que la de shellscript, aunque para las tareas que se van a realizar en este m\u00f3dulo, ambos sistemas poseen herramientas suficientes. Vectores \u00b6 PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1,2,3,4,5 $Texto = \u201cLunes\u201d,\u201cMartes\u201d,\u201dMi\u00e9rcoles\u201d, \u201cJueves\u201d,\u201dViernes\u201d $EnterosRango = 1..10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @(For($i;$i < 5;$i++){$i}) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1,2,3,4,5 -Force New-Variable -Name Texto -Value \"Lunes\",\"Martes\",\"Mi\u00e9rcoles\",\"Jueves\",\"Viernes\" \u2013Force New-Variable -Name EnterosRango -Value (1..5) -Force New-Variable -Name EnterosFor -value (. {For($i=1;$i -lt 5;$i++){$i}}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto.Length # mostrar\u00e1 5 por pantalla $Texto[2].Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201cS\u00e1bado\u201d, \u201cDomingo\u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados. Funciones \u00b6 Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function <NOMBRE> { Param (<Parametro>,<Parametro>,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ([integer] $a, [integer] $b) $sumar = $a + $b Write-Host \u201cLa suma es $sumar\u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script. Actividades PowerShell \u00b6 Note Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Actividades Iniciales PowerShell \u00b6 Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script. Crea un script que si no se le pasa ning\u00fan argumento nos lo diga. Actividades de desarrollo UD1_04 \u00b6 Dise\u00f1a un script PowerShell que pida al usuario dos n\u00famero (comprobando que sean n\u00fameros) y muestre por pantalla el mayor de ellos o si son iguales. Crea un script PowerShell que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Usa el cmdlet Get-Date . Construye tres script PowerShell utilizando estructuras iterativas: el primero ej118A.ps1 , que imprima la tabla de multiplicar de un n\u00famero preguntado al usuario. Este n\u00famero debe ser entero positivo. el segundo ej118B.ps1 , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej118C.ps1 , que muestre las diez primeras tablas de multiplicar por pantalla. Hay un tiempo de espera de un segundo entre ellas. Utiliza las estructuras while, do while, for y foreach y el cmdlet Start-Sleep. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random. Actividades de desarrollo UD1_05 \u00b6 Crea un script PowerShell que rellene un vector con diez n\u00fameros de forma aleatoria y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores. los valores ordenados de menor a mayor en una sola l\u00ednea. los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores. cantidad de valores pares que contiene el vector. la suma total de n\u00fameros impares. la media aritm\u00e9tica de los valores que contiene el vector. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. Dise\u00f1a un script PowerShell que muestre un men\u00fa al usuario con cuatro operaciones disponibles: Crear directorio, Eliminar directorio, Mostrar directorio, Informe de directorio, Copia de directorio y Salir . Una vez elegida una opci\u00f3n correcta, el programa debe solicitar un nombre de directorio y hacer la operaci\u00f3n seleccionada. Tras esto debe mostrar un mensaje con el resultado de la operaci\u00f3n. Crea una funci\u00f3n para cada una de estas opciones. Si se elige la opci\u00f3n Informe de directorio , mostrar\u00e1 por pantalla el n\u00famero de ficheros que contiene, cuantos son carpetas, cuantos directorios y el tama\u00f1o total de ellos. Si la carpeta no existe, mostrar\u00e1 un error. Si elige la opci\u00f3n Copia de directorio , preguntar\u00e1 la carpeta de destino y mostrar\u00e1 fichero a fichero la copia. Realiza un script PowerShell que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: el informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libre o no (usa el comando ping). en el informe debe aparecer el tipo de red (A, B o C) en el que est\u00e1 inmerso el ordenador con el nombre de la red, su broadcast y su m\u00e1scara de subred.","title":"Power Shell"},{"location":"02_PowerShell/012_PowerShellTotal.html#power-shell","text":"Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas propietarios . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados.","title":"Power Shell"},{"location":"02_PowerShell/012_PowerShellTotal.html#introduccion","text":"Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de autocompletado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsar la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un gui\u00f3n y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas.","title":"Introducci\u00f3n"},{"location":"02_PowerShell/012_PowerShellTotal.html#primer-script","text":"Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./Script.ps1 Aunque tambi\u00e9n es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro .","title":"Primer Script"},{"location":"02_PowerShell/012_PowerShellTotal.html#powershell-ise","text":"PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE.","title":"PowerShell ISE"},{"location":"02_PowerShell/012_PowerShellTotal.html#comentarios","text":"Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multil\u00ednea.","title":"Comentarios"},{"location":"02_PowerShell/012_PowerShellTotal.html#parametros-en-powershell","text":"Como ocurr\u00eda en GNU/Linux, los par\u00e1metros que reciba el script se deben recoger de forma interna en una variable para poder operar con ellos. Example param ([string]$nombre) Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"Hola de nuevo, tu nombre es $nombre\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable nombre. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./Script.ps1 \u201cF\u00ba Javier Hern\u00e1ndez Ill\u00e1n\u201d Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables .","title":"Par\u00e1metros en PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#variables","text":"Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable.","title":"Variables"},{"location":"02_PowerShell/012_PowerShellTotal.html#implicita","text":"Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9.99 $Final_2021 = 30 ${Mi variable} = \u201cContiene espacios en el nombre\u201d En la forma implicita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $feo.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable .","title":"Implicita"},{"location":"02_PowerShell/012_PowerShellTotal.html#explicita","text":"Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [ float ] $numero = 9.99 [int] $Final_2021 = 30 [string] ${Mi variable} = \u201cContiene espacios en el nombre\u201d Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: que las caracter\u00edsticas del dato se modifiquen para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, o que se producir\u00e1 un error si esa conversi\u00f3n no es posible y se detenga el script.","title":"Explicita"},{"location":"02_PowerShell/012_PowerShellTotal.html#interaccion-con-el-usuario","text":"PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [ string ] $feo = Read-Host \u201c\u00bfCu\u00e1l es el nombre del marine de Doom?\u201d Write-Host \u201cNo se sabe, pero lo has intentado con $feo\u201d Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript.","title":"Interacci\u00f3n con el usuario"},{"location":"02_PowerShell/012_PowerShellTotal.html#operadores","text":"","title":"Operadores"},{"location":"02_PowerShell/012_PowerShellTotal.html#aritmeticos","text":"Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [ int ] $a=10 [float] $b=20 [int] $res=$a+$b Write-Host $res Write-Host $a+$b Write-Host \"$a x $b = \" ($a*$b) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores.","title":"Aritm\u00e9ticos"},{"location":"02_PowerShell/012_PowerShellTotal.html#logicos","text":"Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host ((6 -ge 4) -and (7 -le 7)) Write-Host ((10 -gt 1) -or (2 -lt 2)) Write-Host ((1 -gt 0) -xor (4 -le 1)) Write-Host ( -not (12 -lt 10)) Write-Host (!(12 -lt 10)) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \u201cJavi\u201d -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \u201cJavi\u201d -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int])","title":"L\u00f3gicos"},{"location":"02_PowerShell/012_PowerShellTotal.html#comparacion","text":"los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \u201cJavi\u201d -ieq \u201cjavi\u201d es verdadero -ceq Iguales. En cadenas es casesensitive. \u201cJavi\u201d -ceq \u201cjavi\u201d es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \u201ces como\u201d. \u201cPerro\u201d -like \u201cPe*\u201d es verdadero -notlike Eval\u00faa un patr\u00f3n \u201cno es como\u201d. \u201cPerro\u201d -notlike \u201cPe*\u201d es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso","title":"Comparaci\u00f3n"},{"location":"02_PowerShell/012_PowerShellTotal.html#control-del-flujo-en-powershell","text":"En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript.","title":"Control del flujo en PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#alternativa-simple","text":"if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera }","title":"Alternativa Simple"},{"location":"02_PowerShell/012_PowerShellTotal.html#alternativa-doble","text":"if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa }","title":"Alternativa doble"},{"location":"02_PowerShell/012_PowerShellTotal.html#alternativa-multiple","text":"if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas }","title":"Alternativa m\u00faltiple"},{"location":"02_PowerShell/012_PowerShellTotal.html#el-equivalente-a-case-en-gnulinux","text":"switch ($valor){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ($saludo){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } {$_ -is [string]} { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ($target){ '^ftp\\://.*$' { \"$_ is an ftp address\"; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\"; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $($matches[1])\"; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe u n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil : $_\"; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones.","title":"El equivalente a case en GNU/Linux"},{"location":"02_PowerShell/012_PowerShellTotal.html#estructuras-iterativas","text":"","title":"Estructuras iterativas"},{"location":"02_PowerShell/012_PowerShellTotal.html#vectores","text":"PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1,2,3,4,5 $Texto = \u201cLunes\u201d,\u201cMartes\u201d,\u201dMi\u00e9rcoles\u201d, \u201cJueves\u201d,\u201dViernes\u201d $EnterosRango = 1..10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @(For($i;$i < 5;$i++){$i}) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1,2,3,4,5 -Force New-Variable -Name Texto -Value \"Lunes\",\"Martes\",\"Mi\u00e9rcoles\",\"Jueves\",\"Viernes\" \u2013Force New-Variable -Name EnterosRango -Value (1..5) -Force New-Variable -Name EnterosFor -value (. {For($i=1;$i -lt 5;$i++){$i}}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto.Length # mostrar\u00e1 5 por pantalla $Texto[2].Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201cS\u00e1bado\u201d, \u201cDomingo\u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados.","title":"Vectores"},{"location":"02_PowerShell/012_PowerShellTotal.html#funciones","text":"Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function <NOMBRE> { Param (<Parametro>,<Parametro>,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ([integer] $a, [integer] $b) $sumar = $a + $b Write-Host \u201cLa suma es $sumar\u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script.","title":"Funciones"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-powershell","text":"Note Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-iniciales-powershell","text":"Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script. Crea un script que si no se le pasa ning\u00fan argumento nos lo diga.","title":"Actividades Iniciales PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-de-desarrollo-ud1_04","text":"Dise\u00f1a un script PowerShell que pida al usuario dos n\u00famero (comprobando que sean n\u00fameros) y muestre por pantalla el mayor de ellos o si son iguales. Crea un script PowerShell que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Usa el cmdlet Get-Date . Construye tres script PowerShell utilizando estructuras iterativas: el primero ej118A.ps1 , que imprima la tabla de multiplicar de un n\u00famero preguntado al usuario. Este n\u00famero debe ser entero positivo. el segundo ej118B.ps1 , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej118C.ps1 , que muestre las diez primeras tablas de multiplicar por pantalla. Hay un tiempo de espera de un segundo entre ellas. Utiliza las estructuras while, do while, for y foreach y el cmdlet Start-Sleep. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random.","title":"Actividades de desarrollo UD1_04"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-de-desarrollo-ud1_05","text":"Crea un script PowerShell que rellene un vector con diez n\u00fameros de forma aleatoria y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores. los valores ordenados de menor a mayor en una sola l\u00ednea. los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores. cantidad de valores pares que contiene el vector. la suma total de n\u00fameros impares. la media aritm\u00e9tica de los valores que contiene el vector. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. Dise\u00f1a un script PowerShell que muestre un men\u00fa al usuario con cuatro operaciones disponibles: Crear directorio, Eliminar directorio, Mostrar directorio, Informe de directorio, Copia de directorio y Salir . Una vez elegida una opci\u00f3n correcta, el programa debe solicitar un nombre de directorio y hacer la operaci\u00f3n seleccionada. Tras esto debe mostrar un mensaje con el resultado de la operaci\u00f3n. Crea una funci\u00f3n para cada una de estas opciones. Si se elige la opci\u00f3n Informe de directorio , mostrar\u00e1 por pantalla el n\u00famero de ficheros que contiene, cuantos son carpetas, cuantos directorios y el tama\u00f1o total de ellos. Si la carpeta no existe, mostrar\u00e1 un error. Si elige la opci\u00f3n Copia de directorio , preguntar\u00e1 la carpeta de destino y mostrar\u00e1 fichero a fichero la copia. Realiza un script PowerShell que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: el informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libre o no (usa el comando ping). en el informe debe aparecer el tipo de red (A, B o C) en el que est\u00e1 inmerso el ordenador con el nombre de la red, su broadcast y su m\u00e1scara de subred.","title":"Actividades de desarrollo UD1_05"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html","text":"Power Shell \u00b6 Introducci\u00f3n \u00b6 Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de auto-completado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsa la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un guion y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas. Primer Script \u00b6 Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./ Script . ps1 PowerShell ISE \u00b6 PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE. Es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro . Comentarios \u00b6 Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multi-l\u00ednea. Depuraci\u00f3n \u00b6 La depuraci\u00f3n es el proceso de examinar un script mientras se ejecuta para identificar y corregir errores en las instrucciones del script. El depurador de PowerShell puede ayudarle a examinar e identificar errores e ineficiencias en los scripts, funciones, comandos, configuraciones o expresiones de PowerShell Desired State Configuration (DSC). El depurador de PowerShell incluye el siguiente conjunto de cmdlets: Set-PSBreakpoint : establece puntos de interrupci\u00f3n en l\u00edneas, variables y comandos. Get-PSBreakpoint : obtiene puntos de interrupci\u00f3n en la sesi\u00f3n actual. Disable-PSBreakpoint : desactiva los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Enable-PSBreakpoint : vuelve a habilitar los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Remove-PSBreakpoint : elimina puntos de interrupci\u00f3n de la sesi\u00f3n actual. Get-PSCallStack : muestra la pila de llamadas actual. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script.","title":"2.1- Introducci\u00f3n"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#power-shell","text":"","title":"Power Shell"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#introduccion","text":"Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de auto-completado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsa la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un guion y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas.","title":"Introducci\u00f3n"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#primer-script","text":"Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./ Script . ps1","title":"Primer Script"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#powershell-ise","text":"PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE. Es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro .","title":"PowerShell ISE"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#comentarios","text":"Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multi-l\u00ednea.","title":"Comentarios"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#depuracion","text":"La depuraci\u00f3n es el proceso de examinar un script mientras se ejecuta para identificar y corregir errores en las instrucciones del script. El depurador de PowerShell puede ayudarle a examinar e identificar errores e ineficiencias en los scripts, funciones, comandos, configuraciones o expresiones de PowerShell Desired State Configuration (DSC). El depurador de PowerShell incluye el siguiente conjunto de cmdlets: Set-PSBreakpoint : establece puntos de interrupci\u00f3n en l\u00edneas, variables y comandos. Get-PSBreakpoint : obtiene puntos de interrupci\u00f3n en la sesi\u00f3n actual. Disable-PSBreakpoint : desactiva los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Enable-PSBreakpoint : vuelve a habilitar los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Remove-PSBreakpoint : elimina puntos de interrupci\u00f3n de la sesi\u00f3n actual. Get-PSCallStack : muestra la pila de llamadas actual.","title":"Depuraci\u00f3n"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script.","title":"Actividades"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html","text":"Sintaxis \u00b6 Par\u00e1metros en PowerShell \u00b6 A diferencia de GNU/Linux, los par\u00e1metros que reciba el script en PowerShell se reciben en el array args , Cada posici\u00f3n del array args[] guarda los par\u00e1metros introducidos al script en el orden indicado. Por lo tanto para acceder a los par\u00e1metros introducidos se debe acceder al valor de la posici\u00f3n que se desee. Example [string] $param1 = $args [ 0 ] Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"El primer par\u00e1metro introducido es $param1\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable $param1. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./ Script . ps1 \"F\u00ba Javier Hern\u00e1ndez Ill\u00e1n\" Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables . Variables \u00b6 Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable. Impl\u00edcita \u00b6 Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9 . 99 $Final_2021 = 30 ${ Mi variable } = \"Contiene espacios en el nombre\" En la forma impl\u00edcita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $numero.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable . Explicita \u00b6 Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [float] $numero = 9 . 99 [int] $Final_2021 = 30 [string] ${ Mi variable } = \"Contiene espacios en el nombre\" Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: Se modifiquen las caracter\u00edsticas del dato para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, Se produzca un error si esa conversi\u00f3n no es posible y se detenga el script. Interacci\u00f3n con el usuario \u00b6 PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [string] $marine = Read-Host \"\u00bfCu\u00e1l es el nombre del marine de Doom?\" Write-Host \"No se sabe, pero lo has intentado con $marine Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript. Operadores \u00b6 Aritm\u00e9ticos \u00b6 Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [int] $a = 10 [float] $b = 20 [int] $res = $a + $b Write-Host $res Write-Host $a + $b Write-Host \"$a x $b = \" ( $a * $b ) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores. L\u00f3gicos \u00b6 Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host (( 6 -ge 4 ) -and ( 7 -le 7 )) Write-Host (( 10 -gt 1 ) -or ( 2 -lt 2 )) Write-Host (( 1 -gt 0 ) -xor ( 4 -le 1 )) Write-Host ( -not ( 12 -lt 10 )) Write-Host (!( 12 -lt 10 )) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \"Javi\" -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \"Javi\" -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int]) Comparaci\u00f3n \u00b6 los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \"Javi\" -ieq \"javi\" es verdadero -ceq Iguales. En cadenas es casesensitive. \"Javi\" -ceq \"javi\" es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \"es como\". \"Perro\" -like \"Pe*\" es verdadero -notlike Eval\u00faa un patr\u00f3n \"no es como\". \"Perro\" -notlike \"Pe*\" es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un script que si no se le pasa ning\u00fan argumento nos lo diga. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b","title":"2.2- Sintaxis"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#sintaxis","text":"","title":"Sintaxis"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#parametros-en-powershell","text":"A diferencia de GNU/Linux, los par\u00e1metros que reciba el script en PowerShell se reciben en el array args , Cada posici\u00f3n del array args[] guarda los par\u00e1metros introducidos al script en el orden indicado. Por lo tanto para acceder a los par\u00e1metros introducidos se debe acceder al valor de la posici\u00f3n que se desee. Example [string] $param1 = $args [ 0 ] Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"El primer par\u00e1metro introducido es $param1\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable $param1. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./ Script . ps1 \"F\u00ba Javier Hern\u00e1ndez Ill\u00e1n\" Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables .","title":"Par\u00e1metros en PowerShell"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#variables","text":"Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable.","title":"Variables"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#implicita","text":"Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9 . 99 $Final_2021 = 30 ${ Mi variable } = \"Contiene espacios en el nombre\" En la forma impl\u00edcita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $numero.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable .","title":"Impl\u00edcita"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#explicita","text":"Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [float] $numero = 9 . 99 [int] $Final_2021 = 30 [string] ${ Mi variable } = \"Contiene espacios en el nombre\" Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: Se modifiquen las caracter\u00edsticas del dato para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, Se produzca un error si esa conversi\u00f3n no es posible y se detenga el script.","title":"Explicita"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#interaccion-con-el-usuario","text":"PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [string] $marine = Read-Host \"\u00bfCu\u00e1l es el nombre del marine de Doom?\" Write-Host \"No se sabe, pero lo has intentado con $marine Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript.","title":"Interacci\u00f3n con el usuario"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#operadores","text":"","title":"Operadores"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#aritmeticos","text":"Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [int] $a = 10 [float] $b = 20 [int] $res = $a + $b Write-Host $res Write-Host $a + $b Write-Host \"$a x $b = \" ( $a * $b ) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores.","title":"Aritm\u00e9ticos"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#logicos","text":"Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host (( 6 -ge 4 ) -and ( 7 -le 7 )) Write-Host (( 10 -gt 1 ) -or ( 2 -lt 2 )) Write-Host (( 1 -gt 0 ) -xor ( 4 -le 1 )) Write-Host ( -not ( 12 -lt 10 )) Write-Host (!( 12 -lt 10 )) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \"Javi\" -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \"Javi\" -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int])","title":"L\u00f3gicos"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#comparacion","text":"los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \"Javi\" -ieq \"javi\" es verdadero -ceq Iguales. En cadenas es casesensitive. \"Javi\" -ceq \"javi\" es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \"es como\". \"Perro\" -like \"Pe*\" es verdadero -notlike Eval\u00faa un patr\u00f3n \"no es como\". \"Perro\" -notlike \"Pe*\" es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso","title":"Comparaci\u00f3n"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un script que si no se le pasa ning\u00fan argumento nos lo diga. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b","title":"Actividades"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html","text":"Control de Flujo \u00b6 Estructuras \u00b6 En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript. Alternativa Simple \u00b6 if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } Alternativa doble \u00b6 if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa } Alternativa m\u00faltiple \u00b6 if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas } El equivalente a case en GNU/Linux \u00b6 switch ( $valor ){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ( $saludo ){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } { $_ -is [string] } { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ( $target ){ '^ftp\\://.*$' { \"$_ is an ftp address\" ; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\" ; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $( $matches [ 1 ]) \" ; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe un n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil: $_\" ; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones. Estructuras iterativas \u00b6 while \u00b6 A diferencia de lo que ocurr\u00eda en GNU/Linux, en PowerShell existen diferencias entre las estructuras while, do while y do until . En este caso, la \u00fanica de las tres que evaluar\u00e1 la condici\u00f3n al inicio del bloque de c\u00f3digo ser\u00e1 la primera. El resto comprueba la condici\u00f3n al final del bloque ejecutando como m\u00ednimo una vez el c\u00f3digo que contiene. while ( condici\u00f3n ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } do { bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } while ( condici\u00f3n ) Existe una variante de esta estructura que se crea sustituyendo el while por un until . Esto cambia el sentido de la condici\u00f3n y es este caso el bloque se repite hasta que la condici\u00f3n se cumpla. Esta estructura no es muy utilizada, pero siempre es bueno contar con herramientas extra. for \u00b6 Tambi\u00e9n la estructura for es sensiblemente diferente que en shellscript. Esta estructura en PowerShell tiene m\u00e1s que ver con los lenguajes de programaci\u00f3n y se utiliza cuando el programador sabe el n\u00famero de iteraciones que hay que realizar para solucionar un problema. for ( inicializaci\u00f3n ; condici\u00f3n ; incremento ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } Por ejemplo, la creaci\u00f3n de la tabla de multiplicar de un n\u00famero especificado por el usuario. Para resolver este problema s\u00ed se conoce el n\u00famero de iteraciones necesarias, concretamente diez. Example $numero = Read-Host \"Dame un n\u00famero\" Write-Host \"Esta es la tabla del $num\" for ( $i = 0 ; $i -lt 11 ; $i ++){ Write-Host \" $i x $numero = \" ( $i * $numero ) } foreach \u00b6 La estructura foreach en PowerShell es el equivalente a for en shellscript. Est\u00e1 pensada para recorrer un conjunto de valores y ejecutar el bloque de c\u00f3digo una vez por cada elemento del conjunto. foreach ( elemento in conjunto ){ bloque de c\u00f3digo a ejecutar por cada elemento del conjunto } Al igual que ocurre en GNU/Linux, el conjunto puede serlo de cualquier tipo de objetos, incluso los ficheros de una carpeta. En el siguiente ejemplo se buscan los ficheros que en su nombre contengan la cadena de texto que el usuario ha especificado: Example $ruta = \"C:\\Users\\Administrador\\Desktop\" $busca = Read-Host \"Escribe el texto a buscar\" foreach ( $archivo in Get-ChildItem $ruta ){ if ( $archivo . Name . IndexOf ( $busca ) -ge 0 ){ Write-Host $archivo . Name } } Note Las opciones que ofrece PowerShell en cuanto a estructuras de control parece una oferta m\u00e1s completa que la de shellscript, aunque para las tareas que se van a realizar en este m\u00f3dulo, ambos sistemas poseen herramientas suficientes. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"2.3- Control de flujo"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#control-de-flujo","text":"","title":"Control de Flujo"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#estructuras","text":"En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript.","title":"Estructuras"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#alternativa-simple","text":"if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera }","title":"Alternativa Simple"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#alternativa-doble","text":"if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa }","title":"Alternativa doble"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#alternativa-multiple","text":"if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas }","title":"Alternativa m\u00faltiple"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#el-equivalente-a-case-en-gnulinux","text":"switch ( $valor ){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ( $saludo ){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } { $_ -is [string] } { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ( $target ){ '^ftp\\://.*$' { \"$_ is an ftp address\" ; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\" ; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $( $matches [ 1 ]) \" ; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe un n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil: $_\" ; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones.","title":"El equivalente a case en GNU/Linux"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#estructuras-iterativas","text":"","title":"Estructuras iterativas"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html","text":"Vectores y Funciones \u00b6 Vectores \u00b6 PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1 , 2 , 3 , 4 , 5 $Texto = \u201c Lunes \u201d , \u201c Martes \u201d , \u201d Mi\u00e9rcoles \u201d , \u201c Jueves \u201d , \u201d Viernes \u201d $EnterosRango = 1 .. 10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @( For ( $i ; $i < 5 ; $i ++){ $i }) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1 , 2 , 3 , 4 , 5 -Force New-Variable -Name Texto -Value \"Lunes\" , \"Martes\" , \"Mi\u00e9rcoles\" , \"Jueves\" , \"Viernes\" \u2013 Force New-Variable -Name EnterosRango -Value ( 1 .. 5 ) -Force New-Variable -Name EnterosFor -value (. { For ( $i = 1 ; $i -lt 5 ; $i ++){ $i }}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto . Length # mostrar\u00e1 5 por pantalla $Texto [ 2 ]. Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201c S\u00e1bado \u201d , \u201c Domingo \u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados. Funciones \u00b6 Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function < NOMBRE > { Param (< Parametro >,< Parametro >,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ( [integer] $a , [integer] $b ) $sumar = $a + $b Write-Host \u201c La suma es $sumar \u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. NOTA Utiliza en la generaci\u00f3n de los scripts los cmdlets de depuraci\u00f3n si as\u00ed lo consideras al haber encontrado problemas en la ejecuci\u00f3n.","title":"Vectores y Funciones"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#vectores-y-funciones","text":"","title":"Vectores y Funciones"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#vectores","text":"PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1 , 2 , 3 , 4 , 5 $Texto = \u201c Lunes \u201d , \u201c Martes \u201d , \u201d Mi\u00e9rcoles \u201d , \u201c Jueves \u201d , \u201d Viernes \u201d $EnterosRango = 1 .. 10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @( For ( $i ; $i < 5 ; $i ++){ $i }) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1 , 2 , 3 , 4 , 5 -Force New-Variable -Name Texto -Value \"Lunes\" , \"Martes\" , \"Mi\u00e9rcoles\" , \"Jueves\" , \"Viernes\" \u2013 Force New-Variable -Name EnterosRango -Value ( 1 .. 5 ) -Force New-Variable -Name EnterosFor -value (. { For ( $i = 1 ; $i -lt 5 ; $i ++){ $i }}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto . Length # mostrar\u00e1 5 por pantalla $Texto [ 2 ]. Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201c S\u00e1bado \u201d , \u201c Domingo \u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados.","title":"Vectores"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#funciones","text":"Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function < NOMBRE > { Param (< Parametro >,< Parametro >,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ( [integer] $a , [integer] $b ) $sumar = $a + $b Write-Host \u201c La suma es $sumar \u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script.","title":"Funciones"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. NOTA Utiliza en la generaci\u00f3n de los scripts los cmdlets de depuraci\u00f3n si as\u00ed lo consideras al haber encontrado problemas en la ejecuci\u00f3n.","title":"Actividades"},{"location":"02_PowerShell/ProgramacionAula.html","text":"Programaci\u00f3n de Aula \u00b6 Resultados de Aprendizaje \u00b6 Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Planificaci\u00f3n Temporal \u00b6 Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 27/09/22 Introducci\u00f3n PowerShell, Creaci\u00f3n Primer Script, Comentarios y depuraci\u00f3n. Introducci\u00f3n PowerShell 2 28/09/22 Sintaxis, Argumentos y variables, Interacci\u00f3n con el usuario, Operadores. Sintaxis PowerShell. 3 29/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo en PWSH. 4 04/10/22 Vectores y funciones Vectores y Funciones. 5 05/10/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n.","title":"Programaci\u00f3n de Aula"},{"location":"02_PowerShell/ProgramacionAula.html#programacion-de-aula","text":"","title":"Programaci\u00f3n de Aula"},{"location":"02_PowerShell/ProgramacionAula.html#resultados-de-aprendizaje","text":"Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; }","title":"Resultados de Aprendizaje"},{"location":"02_PowerShell/ProgramacionAula.html#planificacion-temporal","text":"Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 27/09/22 Introducci\u00f3n PowerShell, Creaci\u00f3n Primer Script, Comentarios y depuraci\u00f3n. Introducci\u00f3n PowerShell 2 28/09/22 Sintaxis, Argumentos y variables, Interacci\u00f3n con el usuario, Operadores. Sintaxis PowerShell. 3 29/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo en PWSH. 4 04/10/22 Vectores y funciones Vectores y Funciones. 5 05/10/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n.","title":"Planificaci\u00f3n Temporal"},{"location":"02_PowerShell/ResumenUD.html","text":"Resumen UD \u00b6 A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"02_PowerShell/ResumenUD.html#resumen-ud","text":"A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"}]}