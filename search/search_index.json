{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Administraci\u00f3n de Sistemas Operativos \u00b6 Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Administraci\u00f3n de Sistemas Operativos , que se imparte en el segundo curso del ciclo formativo de grado superior de Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas , a raz\u00f3n de 6 horas semanales , y se desarrolla a lo largo de los dos primeros trimestres del curso . Se ha planificado bas\u00e1ndose en 3 sesiones lectivas por semana , con 2 horas de duraci\u00f3n cada una de ellas . \u00bfQu\u00e9 voy a aprender? \u00b6 Administrar sistemas operativos de servidor, instalando y configurando el software, en condiciones de calidad para asegurar el funcionamiento del sistema. Administrar servicios de recursos compartidos (acceso a directorios, impresi\u00f3n, accesos remotos, entre otros) instalando y configurando el software, en condiciones de calidad. Administrar usuarios de acuerdo a las especificaciones de explotaci\u00f3n para garantizar los accesos y la disponibilidad de los recursos del sistema. Gestionar los recursos de diferentes sistemas operativos (programando y verificando su cumplimiento). Resultados de aprendizaje \u00b6 Un Resultado de Aprendizaje \"es una declaraci\u00f3n de lo que el estudiante se espera que conozca, comprenda y sea capaz de hacer al finalizar un periodo de aprendizaje\". Los resultados de aprendizaje de ASO vienen definidos en el RD 1629/2009. Los Resultados de Aprendizaje de ASO son: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Gestiona la automatizaci\u00f3n de tareas del sistema, aplicando criterios de eficiencia y utilizando comandos y herramientas gr\u00e1ficas. Administra de forma remota el sistema operativo en red valorando su importancia y aplicando criterios de seguridad. Administra servidores de impresi\u00f3n describiendo sus funciones e integr\u00e1ndolos en una red. Integra sistemas operativos libres y propietarios, justificando y garantizando su interoperabilidad. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Unidades did\u00e1cticas / Temporalizaci\u00f3n \u00b6 A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas, repartidas en cada evaluaci\u00f3n con una duraci\u00f3n aproximada de 30 sesiones por evaluaci\u00f3n . Primera evaluaci\u00f3n \u00b6 ShellScripting. (6 sesiones, 12 horas) ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. ShellScripting, Re-direcciones, tuber\u00edas. Control de flujo en Shell, vectores. PowerShell. (6 sesiones, 12 horas) PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. PowerShell, Control de flujo, y vectores. Administraci\u00f3n de Procesos del Sistema. (6 sesiones, 12 horas) Procesos. Tipos. Estados. Estructura. Transiciones, Hilos. Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Gesti\u00f3n de procesos, demonios/servicios con Shell y Powershell. Servicios de Directorio Libres: LDAP. (6 sesiones, 12 horas) Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). LDAP, modelo informaci\u00f3n, Esquema. LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Servicios de Directorio Propietarios: Active Directory (6 sesiones, 12 horas). Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. AD, Permisos, directivas de grupo, perfiles y relaciones de confianza. Segunda evaluaci\u00f3n \u00b6 Integraci\u00f3n de Sistemas Libre: NFS (6 sesiones, 12 horas). Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de recursos compartidos. NFS, Instalaci\u00f3n, Permisos, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Integraci\u00f3n de Sistemas Propietarios: SAMBA (6 sesiones, 12 horas). SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de usuario y carpetas personales, cuotas. Informaci\u00f3n del sistema operativo (6 sesiones, 12 horas). Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. Rendimiento. Estad\u00edsticas. Planificaci\u00f3n de Tareas, Programador de tareas, crontab . Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Servicios de acceso y administraci\u00f3n remota (6 sesiones, 12 horas). Acceso remoto en modo texto SSH . Tunelizaci\u00f3n. Escritorio Remoto: RDP y xRDP. Acceso remoto de equipos en el AD con PWSH. Herramientas gr\u00e1ficas externas, TeamViewer, AnyDesk y Apache Guacamole. Administraci\u00f3n de Servidores de Impresi\u00f3n (6 sesiones, 12 horas). Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n. Servidor de impresi\u00f3n en GNU/Linux, CUPS . \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server. Evaluaci\u00f3n \u00b6 Instrumentos de calificaci\u00f3n \u00b6 Instrumento de calificaci\u00f3n 1 (IC1): : escala de valores comprendidas entre 0 y 3 puntos calificados de la siguiente forma: 0 : No entregada. 1 : Entregada pero soluci\u00f3n err\u00f3nea o incompleta. 2 : Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 3 : Entregada y soluci\u00f3n correcta. Instrumento de calificaci\u00f3n 2 (IC2): escala de valores comprendidas entre 0 y 7 puntos calificados de la siguiente forma: 0 : No entregada 1-3 : Entregada pero soluci\u00f3n err\u00f3nea o incompleta 3-6 : Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 7 : Entregada y soluci\u00f3n correcta. Instrumentos de Evaluaci\u00f3n \u00b6 La nota de cada Resultado de Aprendizaje se calcula mediante la media ponderada de los puntos obtenidos, de los siguientes instrumentos de evaluaci\u00f3n. Instrumento de Evaluaci\u00f3n 1 (IE1). Trabajo en Clase/Actividades. Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas en el moodle aplicando el IC1 . Instrumentos de Evaluaci\u00f3n 2 (IE2). Pruebas de Auditor\u00eda. Cuestionario multi-opci\u00f3n (test) de 20 preguntas sobre la teor\u00eda de la unidad. Ejercicios pr\u00e1cticos sobre las actividades realizadas de la unidad. Nota : Esta prueba se califica entre 0 y 30 puntos siguiendo las siguientes premisas: 0-10 puntos. Donde Cada dos contestaciones incorrectas contestadas resta una bien. 0-6 puntos: dos ejercicios de nivel medio-bajo , 3 puntos cada uno de ellos aplicando IC1 . 0-14 puntos: dos ejercicios de nivel medio-alto aplicando IC2","title":"Inicio"},{"location":"index.html#administracion-de-sistemas-operativos","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Administraci\u00f3n de Sistemas Operativos , que se imparte en el segundo curso del ciclo formativo de grado superior de Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red. La duraci\u00f3n del m\u00f3dulo es de 120 horas lectivas , a raz\u00f3n de 6 horas semanales , y se desarrolla a lo largo de los dos primeros trimestres del curso . Se ha planificado bas\u00e1ndose en 3 sesiones lectivas por semana , con 2 horas de duraci\u00f3n cada una de ellas .","title":"Administraci\u00f3n de Sistemas Operativos"},{"location":"index.html#que-voy-a-aprender","text":"Administrar sistemas operativos de servidor, instalando y configurando el software, en condiciones de calidad para asegurar el funcionamiento del sistema. Administrar servicios de recursos compartidos (acceso a directorios, impresi\u00f3n, accesos remotos, entre otros) instalando y configurando el software, en condiciones de calidad. Administrar usuarios de acuerdo a las especificaciones de explotaci\u00f3n para garantizar los accesos y la disponibilidad de los recursos del sistema. Gestionar los recursos de diferentes sistemas operativos (programando y verificando su cumplimiento).","title":"\u00bfQu\u00e9 voy a aprender?"},{"location":"index.html#resultados-de-aprendizaje","text":"Un Resultado de Aprendizaje \"es una declaraci\u00f3n de lo que el estudiante se espera que conozca, comprenda y sea capaz de hacer al finalizar un periodo de aprendizaje\". Los resultados de aprendizaje de ASO vienen definidos en el RD 1629/2009. Los Resultados de Aprendizaje de ASO son: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Gestiona la automatizaci\u00f3n de tareas del sistema, aplicando criterios de eficiencia y utilizando comandos y herramientas gr\u00e1ficas. Administra de forma remota el sistema operativo en red valorando su importancia y aplicando criterios de seguridad. Administra servidores de impresi\u00f3n describiendo sus funciones e integr\u00e1ndolos en una red. Integra sistemas operativos libres y propietarios, justificando y garantizando su interoperabilidad. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo.","title":"Resultados de aprendizaje"},{"location":"index.html#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas, repartidas en cada evaluaci\u00f3n con una duraci\u00f3n aproximada de 30 sesiones por evaluaci\u00f3n .","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"index.html#primera-evaluacion","text":"ShellScripting. (6 sesiones, 12 horas) ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. ShellScripting, Re-direcciones, tuber\u00edas. Control de flujo en Shell, vectores. PowerShell. (6 sesiones, 12 horas) PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. PowerShell, Control de flujo, y vectores. Administraci\u00f3n de Procesos del Sistema. (6 sesiones, 12 horas) Procesos. Tipos. Estados. Estructura. Transiciones, Hilos. Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Gesti\u00f3n de procesos, demonios/servicios con Shell y Powershell. Servicios de Directorio Libres: LDAP. (6 sesiones, 12 horas) Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). LDAP, modelo informaci\u00f3n, Esquema. LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Servicios de Directorio Propietarios: Active Directory (6 sesiones, 12 horas). Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. AD, Permisos, directivas de grupo, perfiles y relaciones de confianza.","title":"Primera evaluaci\u00f3n"},{"location":"index.html#segunda-evaluacion","text":"Integraci\u00f3n de Sistemas Libre: NFS (6 sesiones, 12 horas). Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de recursos compartidos. NFS, Instalaci\u00f3n, Permisos, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Integraci\u00f3n de Sistemas Propietarios: SAMBA (6 sesiones, 12 horas). SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de usuario y carpetas personales, cuotas. Informaci\u00f3n del sistema operativo (6 sesiones, 12 horas). Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. Rendimiento. Estad\u00edsticas. Planificaci\u00f3n de Tareas, Programador de tareas, crontab . Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Servicios de acceso y administraci\u00f3n remota (6 sesiones, 12 horas). Acceso remoto en modo texto SSH . Tunelizaci\u00f3n. Escritorio Remoto: RDP y xRDP. Acceso remoto de equipos en el AD con PWSH. Herramientas gr\u00e1ficas externas, TeamViewer, AnyDesk y Apache Guacamole. Administraci\u00f3n de Servidores de Impresi\u00f3n (6 sesiones, 12 horas). Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n. Servidor de impresi\u00f3n en GNU/Linux, CUPS . \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server.","title":"Segunda evaluaci\u00f3n"},{"location":"index.html#evaluacion","text":"","title":"Evaluaci\u00f3n"},{"location":"index.html#instrumentos-de-calificacion","text":"Instrumento de calificaci\u00f3n 1 (IC1): : escala de valores comprendidas entre 0 y 3 puntos calificados de la siguiente forma: 0 : No entregada. 1 : Entregada pero soluci\u00f3n err\u00f3nea o incompleta. 2 : Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 3 : Entregada y soluci\u00f3n correcta. Instrumento de calificaci\u00f3n 2 (IC2): escala de valores comprendidas entre 0 y 7 puntos calificados de la siguiente forma: 0 : No entregada 1-3 : Entregada pero soluci\u00f3n err\u00f3nea o incompleta 3-6 : Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 7 : Entregada y soluci\u00f3n correcta.","title":"Instrumentos de calificaci\u00f3n"},{"location":"index.html#instrumentos-de-evaluacion","text":"La nota de cada Resultado de Aprendizaje se calcula mediante la media ponderada de los puntos obtenidos, de los siguientes instrumentos de evaluaci\u00f3n. Instrumento de Evaluaci\u00f3n 1 (IE1). Trabajo en Clase/Actividades. Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas en el moodle aplicando el IC1 . Instrumentos de Evaluaci\u00f3n 2 (IE2). Pruebas de Auditor\u00eda. Cuestionario multi-opci\u00f3n (test) de 20 preguntas sobre la teor\u00eda de la unidad. Ejercicios pr\u00e1cticos sobre las actividades realizadas de la unidad. Nota : Esta prueba se califica entre 0 y 30 puntos siguiendo las siguientes premisas: 0-10 puntos. Donde Cada dos contestaciones incorrectas contestadas resta una bien. 0-6 puntos: dos ejercicios de nivel medio-bajo , 3 puntos cada uno de ellos aplicando IC1 . 0-14 puntos: dos ejercicios de nivel medio-alto aplicando IC2","title":"Instrumentos de Evaluaci\u00f3n"},{"location":"ProgramacionAula.html","text":"TABLAS UUDD \u00b6 UD1 SHELLSCRIPTING \u00b6 .heatMap td { text-align: left; } .heatMap td:nth-child(1) { background: lightblue; } .heatMap td:nth-child(3) { background: lightblue; } table caption { padding: 10px; background: #85ABB8; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } TABLA RESUMEN DE UNIDAD Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Aprendizajes de car\u00e1cter transversal Crear y ejecutar guiones en el terminal de bash de Linux/GNU. Conocer y utilizar variables, par\u00e1metros y operadores. Optimizar el c\u00f3digo de los scripts mediante tuberias y redirecciones. Dominar el control de flujo mediante estructuras alternativas e iterativas. Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento (14). Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. (16) Contenidos conceptuales Contenidos procedimentales Actividades de ense\u00f1anza y aprendizaje Actividades de ense\u00f1anza y aprendizaje Criterios de Evaluaci\u00f3n Instrumentos de Evaluaci\u00f3n Actividades de refuerzo Actividades de profundizaci\u00f3n","title":"TABLAS UUDD"},{"location":"ProgramacionAula.html#tablas-uudd","text":"","title":"TABLAS UUDD"},{"location":"ProgramacionAula.html#ud1-shellscripting","text":".heatMap td { text-align: left; } .heatMap td:nth-child(1) { background: lightblue; } .heatMap td:nth-child(3) { background: lightblue; } table caption { padding: 10px; background: #85ABB8; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } TABLA RESUMEN DE UNIDAD Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Aprendizajes de car\u00e1cter transversal Crear y ejecutar guiones en el terminal de bash de Linux/GNU. Conocer y utilizar variables, par\u00e1metros y operadores. Optimizar el c\u00f3digo de los scripts mediante tuberias y redirecciones. Dominar el control de flujo mediante estructuras alternativas e iterativas. Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento (14). Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. (16) Contenidos conceptuales Contenidos procedimentales Actividades de ense\u00f1anza y aprendizaje Actividades de ense\u00f1anza y aprendizaje Criterios de Evaluaci\u00f3n Instrumentos de Evaluaci\u00f3n Actividades de refuerzo Actividades de profundizaci\u00f3n","title":"UD1 SHELLSCRIPTING"},{"location":"RAsASO.html","text":"Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Criterios de evaluaci\u00f3n: a) Se han identificado la funci\u00f3n, los elementos y las estructuras l\u00f3gicas del servicio de directorio. b) Se ha determinado y creado el esquema del servicio de directorio. c) Se ha realizado la instalaci\u00f3n del servicio de directorio en el servidor. d) Se ha realizado la configuraci\u00f3n y personalizaci\u00f3n del servicio de directorio. e) Se ha integrado el servicio de directorio con otros servicios. f) Se han aplicado filtros de b\u00fasqueda en el servicio de directorio. g) Se ha utilizado el servicio de directorio como mecanismo de acreditaci\u00f3n centralizada de los usuarios en una red. h) Se ha realizado la configuraci\u00f3n del cliente para su integraci\u00f3n en el servicio de directorio. i) Se han utilizado herramientas gr\u00e1ficas y comandos para la administraci\u00f3n del servicio de directorio. j) Se ha documentado la estructura e implantaci\u00f3n del servicio de directorio. Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Criterios de evaluaci\u00f3n: a) Se han descrito el concepto de proceso del sistema, tipos, estados y ciclo de vida. b) Se han utilizado interrupciones y excepciones para describir los eventos internos del procesador. c) Se ha diferenciado entre proceso, hilo y trabajo. d) Se han realizado tareas de creaci\u00f3n, manipulaci\u00f3n y terminaci\u00f3n de procesos. e) Se ha utilizado el sistema de archivos como medio l\u00f3gico para el registro e identificaci\u00f3n de los procesos del sistema. f) Se han utilizado herramientas gr\u00e1ficas y comandos para el control y seguimiento de los procesos del sistema. g) Se ha comprobado la secuencia de arranque del sistema, los procesos implicados y la relaci\u00f3n entre ellos. h) Se han tomado medidas de seguridad ante la aparici\u00f3n de procesos no identificados. i) Se han documentado los procesos habituales del sistema, su funci\u00f3n y relaci\u00f3n entre ellos. Gestiona la automatizaci\u00f3n de tareas del sistema, aplicando criterios de eficiencia y utilizando comandos y herramientas gr\u00e1ficas. Criterios de evaluaci\u00f3n: a) Se han descrito las ventajas de la automatizaci\u00f3n de las tareas repetitivas en el sistema. b) Se han utilizado los comandos del sistema para la planificaci\u00f3n de tareas. c) Se han establecido restricciones de seguridad. d) Se han realizado planificaciones de tareas repetitivas o puntuales relacionadas con la administraci\u00f3n del sistema. e) Se ha automatizado la administraci\u00f3n de cuentas. f) Se han instalado y configurado herramientas gr\u00e1ficas para la planificaci\u00f3n de tareas. g) Se han utilizado herramientas gr\u00e1ficas para la planificaci\u00f3n de tareas. h) Se han documentado los procesos programados como tareas autom\u00e1ticas. Administra de forma remota el sistema operativo en red valorando su importancia y aplicando criterios de seguridad. Criterios de evaluaci\u00f3n: a) Se han descrito m\u00e9todos de acceso y administraci\u00f3n remota de sistemas. b) Se ha diferenciado entre los servicios orientados a sesi\u00f3n y los no orientados a sesi\u00f3n. c) Se han utilizado herramientas de administraci\u00f3n remota suministradas por el propio sistema operativo. d) Se han instalado servicios de acceso y administraci\u00f3n remota. e) Se han utilizado comandos y herramientas gr\u00e1ficas para gestionar los servicios de acceso y administraci\u00f3n remota. f) Se han creado cuentas de usuario para el acceso remoto. g) Se han realizado pruebas de acceso y administraci\u00f3n remota entre sistemas heterog\u00e9neos. h) Se han utilizado mecanismos de encriptaci\u00f3n de la informaci\u00f3n transferida. i) Se han documentado los procesos y servicios del sistema administrados de forma remota. Administra servidores de impresi\u00f3n describiendo sus funciones e integr\u00e1ndolos en una red. Criterios de evaluaci\u00f3n: a) Se ha descrito la funcionalidad de los sistemas y servidores de impresi\u00f3n. b) Se han identificado los puertos y los protocolos utilizados. c) Se han utilizado las herramientas para la gesti\u00f3n de impresoras integradas en el sistema operativo. d) Se ha instalado y configurado un servidor de impresi\u00f3n en entorno Web. e) Se han creado y clasificado impresoras l\u00f3gicas. f) Se han creado grupos de impresi\u00f3n. g) Se han gestionado impresoras y colas de trabajos mediante comandos y herramientas gr\u00e1ficas. h) Se han compartido impresoras en red entre sistemas operativos diferentes. i) Se ha documentado la configuraci\u00f3n del servidor de impresi\u00f3n y de las impresoras creadas. Integra sistemas operativos libres y propietarios, justificando y garantizando su interoperabilidad. Criterios de evaluaci\u00f3n: a) Se ha identificado la necesidad de compartir recursos en red entre diferentes sistemas operativos. b) Se han establecido niveles de seguridad para controlar el acceso del cliente a los recursos compartidos en red. c) Se ha comprobado la conectividad de la red en un escenario heterog\u00e9neo. d) Se ha descrito la funcionalidad de los servicios que permiten compartir recursos en red. e) Se han instalado y configurado servicios para compartir recursos en red. f) Se ha comprobado el funcionamiento de los servicios instalados. g) Se ha trabajado en grupo para acceder a sistemas de archivos e impresoras en red desde equipos con diferentes sistemas operativos. h) Se ha documentado la configuraci\u00f3n de los servicios instalados. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Criterios de evaluaci\u00f3n: a) Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b) Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. c) Se han interpretado guiones de configuraci\u00f3n del sistema operativo. d) Se han realizado cambios y adaptaciones de guiones del sistema. e) Se han creado y probado guiones de administraci\u00f3n de servicios. f) Se han creado y probado guiones de automatizaci\u00f3n de tareas. g) Se han implantado guiones en sistemas libres y propietarios. h) Se han consultado y utilizado librer\u00edas de funciones. i) Se han documentado los guiones creados.","title":"RAsASO"},{"location":"planning.html","text":"Planificaci\u00f3n ASO (120h) \u00b6 1.- ShellScripting (10h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 1.1 ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 4h 1.2 ShellScripting, Redirecciones, tuberias. Desarrollo 3h 1.3 Control de flujo en Shell, vectores. Refuerzo y ampliaci\u00f3n 3h 2.- Programaci\u00f3n de Scripts (10h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 2.1 PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 3h 2.2 PowerShell, Control de flujo, y vectores. Desarrollo 3h 2.3 Python, creaci\u00f3n scripts, automatizaci\u00f3n Redes. Refuerzo y ampliaci\u00f3n 4h 3.- Servicios de Directorio Libres: LDAP (12h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 3.1 Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). Iniciales 4h 3.2 LDAP, m\u00f3delo informaci\u00f3n, Esquema. Desarrollo 4h 3.3 LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Refuerzo y ampliaci\u00f3n 4h 4.- Servicios de Directorio Propietarios: Active Directory (16h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 4.1 Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Iniciales 5h 4.2 Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. Desarrollo 5h 4.3 AD, Permisos, directivas de grupo, perfiles y relaciones de confianza. Ampliaci\u00f3n 6h 5.- Integraci\u00f3n de Sistemas Libre: NFS (12h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 5.1 NFS, Instalaci\u00f3n, Permisos en NFS. Iniciales 2h 5.2 NFS, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. Desarrollo 4h 5.3 NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Ampliaci\u00f3n 3h 6.- Integraci\u00f3n de Sistemas Propietarios: SAMBA (10h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 6.2 SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. Desarrollo 4h 6.3 SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de ususario y carpetas personales, cuotas. Ampliaci\u00f3n 3h 7.- Administraci\u00f3n de procesos del Sistema (14h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 7.1 Procesos. Tipos. Estados. Estructura. Trancisiones, Hilos. Iniciales 2h 7.2 Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Desarrollo I 2h 7.3 Gesti\u00f3n de procesos con Shell, Powershell y Python. Desarrollo II 6h 7.4 Secuencia de arranque del sistema. Demonios y servicios, systemd . Ampliaci\u00f3n 4h 8.- Informaci\u00f3n del sistema operativo (14h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 8.1 Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. \u00d3rdenes. Herramientas gr\u00e1ficas. Iniciales 2h 8.2 VFS, DFS, Herramientas gr\u00e1ficas Rendimiento. Estad\u00edsticas. Desarrollo I 4h 8.3 Planificaci\u00f3n de Tareas, Programacor de atreas, crontab . Desarrollo II 4h 8.4 Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Ampliaci\u00f3n 4h 9.- Servicios de acceso y administraci\u00f3n remota (14h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 9.1 Escritorio Remoto RDP, xRDP y RemoteAPP Iniciales y Desarrollo I 4h 9.2 Acceso remoto en modo texto SSH . Desarrollo II 4h 9.3 Herramientas gr\u00e1ficas externas, RealVNC, TeamViewer y AnyDesk. Desarrollo III 4h 9.4 Apache Guacamole. Ampliaci\u00f3n 2h 10.- Administraci\u00f3n de Servidores de Impresi\u00f3n (8h) \u00b6 APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 10.1 Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n Iniciales 2h 10.2 \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Desarrollo I 2h 10.3 Servidor de impresi\u00f3n en GNU/Linux, CUPS . Desarrollo II 2h 10.4 Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server. Desarrollo II 2h","title":"Planificaci\u00f3n ASO (120h)"},{"location":"planning.html#planificacion-aso-120h","text":"","title":"Planificaci\u00f3n ASO (120h)"},{"location":"planning.html#1-shellscripting-10h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 1.1 ShellScripting, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 4h 1.2 ShellScripting, Redirecciones, tuberias. Desarrollo 3h 1.3 Control de flujo en Shell, vectores. Refuerzo y ampliaci\u00f3n 3h","title":"1.- ShellScripting (10h)"},{"location":"planning.html#2-programacion-de-scripts-10h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 2.1 PowerShell, creaci\u00f3n scripts, variables, par\u00e1metros, operadores. Iniciales 3h 2.2 PowerShell, Control de flujo, y vectores. Desarrollo 3h 2.3 Python, creaci\u00f3n scripts, automatizaci\u00f3n Redes. Refuerzo y ampliaci\u00f3n 4h","title":"2.- Programaci\u00f3n de Scripts (10h)"},{"location":"planning.html#3-servicios-de-directorio-libres-ldap-12h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 3.1 Servicios Directorio, LDAP, Autentificaci\u00f3n usuarios (PAM, NSS). Iniciales 4h 3.2 LDAP, m\u00f3delo informaci\u00f3n, Esquema. Desarrollo 4h 3.3 LDAP, Configuraci\u00f3n, herramientas de gesti\u00f3n. Refuerzo y ampliaci\u00f3n 4h","title":"3.- Servicios de Directorio Libres: LDAP (12h)"},{"location":"planning.html#4-servicios-de-directorio-propietarios-active-directory-16h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 4.1 Active Directory, configuraci\u00f3n b\u00e1sica Windows Server. Iniciales 5h 4.2 Active Directory, Instalaci\u00f3n AD, Creaci\u00f3n estructura empresa. Desarrollo 5h 4.3 AD, Permisos, directivas de grupo, perfiles y relaciones de confianza. Ampliaci\u00f3n 6h","title":"4.- Servicios de Directorio Propietarios: Active Directory (16h)"},{"location":"planning.html#5-integracion-de-sistemas-libre-nfs-12h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 5.1 NFS, Instalaci\u00f3n, Permisos en NFS. Iniciales 2h 5.2 NFS, Montaje autom\u00e1tico de un cliente NFS, configuraci\u00f3n de ficheros. Desarrollo 4h 5.3 NextCloud, Instalaci\u00f3n, configuraci\u00f3n de ficheros y permisos de usuario. Ampliaci\u00f3n 3h","title":"5.- Integraci\u00f3n de Sistemas Libre: NFS (12h)"},{"location":"planning.html#6-integracion-de-sistemas-propietarios-samba-10h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 6.1 Escenarios heterog\u00e9neos, Protocolos para redes heterog\u00e9neas, servicios de compartici\u00f3n de recursos. Iniciales 2h 6.2 SAMBA, fichero configuraci\u00f3n, Creaci\u00f3n directorio compartido, Integraci\u00f3n de permisos. Desarrollo 4h 6.3 SAMBA, Administraci\u00f3n de servicios con RSAT, perfiles de ususario y carpetas personales, cuotas. Ampliaci\u00f3n 3h","title":"6.- Integraci\u00f3n de Sistemas Propietarios: SAMBA (10h)"},{"location":"planning.html#7-administracion-de-procesos-del-sistema-14h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 7.1 Procesos. Tipos. Estados. Estructura. Trancisiones, Hilos. Iniciales 2h 7.2 Planificador, Tipos de algoritmos de planificaci\u00f3n, Sincronizaci\u00f3n e interrupciones entre procesos. Desarrollo I 2h 7.3 Gesti\u00f3n de procesos con Shell, Powershell y Python. Desarrollo II 6h 7.4 Secuencia de arranque del sistema. Demonios y servicios, systemd . Ampliaci\u00f3n 4h","title":"7.- Administraci\u00f3n de procesos del Sistema (14h)"},{"location":"planning.html#8-informacion-del-sistema-operativo-14h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 8.1 Estructura directorios. B\u00fasqueda de informaci\u00f3n del sistema. \u00d3rdenes. Herramientas gr\u00e1ficas. Iniciales 2h 8.2 VFS, DFS, Herramientas gr\u00e1ficas Rendimiento. Estad\u00edsticas. Desarrollo I 4h 8.3 Planificaci\u00f3n de Tareas, Programacor de atreas, crontab . Desarrollo II 4h 8.4 Servicio Monitorizaci\u00f3n, Nagios, PRTG, OpenNMS. Ampliaci\u00f3n 4h","title":"8.- Informaci\u00f3n del sistema operativo (14h)"},{"location":"planning.html#9-servicios-de-acceso-y-administracion-remota-14h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 9.1 Escritorio Remoto RDP, xRDP y RemoteAPP Iniciales y Desarrollo I 4h 9.2 Acceso remoto en modo texto SSH . Desarrollo II 4h 9.3 Herramientas gr\u00e1ficas externas, RealVNC, TeamViewer y AnyDesk. Desarrollo III 4h 9.4 Apache Guacamole. Ampliaci\u00f3n 2h","title":"9.- Servicios de acceso y administraci\u00f3n remota (14h)"},{"location":"planning.html#10-administracion-de-servidores-de-impresion-8h","text":"APARTADO DESCRIPCI\u00d3N TIPO ACTIVIDAD TIEMPO 10.1 Sistemas de Impresi\u00f3n, Puertos y protocolos de impresi\u00f3n Iniciales 2h 10.2 \u00d3rdenes para la gesti\u00f3n de impresoras y trabajos. Desarrollo I 2h 10.3 Servidor de impresi\u00f3n en GNU/Linux, CUPS . Desarrollo II 2h 10.4 Administraci\u00f3n de los Servicios de Impresi\u00f3n en Windows Server. Desarrollo II 2h","title":"10.- Administraci\u00f3n de Servidores de Impresi\u00f3n (8h)"},{"location":"01_ShellScripting/index.html","text":"Programaci\u00f3n de Aula \u00b6 Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Detalle de la programaci\u00f3n de Aula: Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 07/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Argumentos, Variables. Introducci\u00f3n ShellScripting 2 09/09/22 Sintaxis, Interacci\u00f3n con el usuario, Operadores, redirecciones y tuberias. Sintaxis ShellScripting 3 12/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 14/09/22 Vectores y funciones Vectores y Funciones. 5 16/09/22 Refuerzo y Ampliaci\u00f3n Refuerzo y Ampliaci\u00f3n. 6 19/09/22 Prueba Espec\u00edfica Prueba Espec\u00edfica.","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/index.html#programacion-de-aula","text":"Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Detalle de la programaci\u00f3n de Aula: Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 07/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Argumentos, Variables. Introducci\u00f3n ShellScripting 2 09/09/22 Sintaxis, Interacci\u00f3n con el usuario, Operadores, redirecciones y tuberias. Sintaxis ShellScripting 3 12/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 14/09/22 Vectores y funciones Vectores y Funciones. 5 16/09/22 Refuerzo y Ampliaci\u00f3n Refuerzo y Ampliaci\u00f3n. 6 19/09/22 Prueba Espec\u00edfica Prueba Espec\u00edfica.","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/011_ShellScript_Intro.html","text":"Introducci\u00f3n \u00b6 Para administrar sistemas operativos es crucial manejar y dominar las interfaces (terminales) disponibles que nos permiten gestionarlos. Entre dichas interfaces destacan los siguientes tipos: De l\u00edneas de texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos/ventanas ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario, ejemplo SIRI en IOS). Este tema se centra en Sistemas basados en c\u00f3digo libre del tipo UNIX, debido a su amplio despliegue en empresas para implementar servicios, m\u00e1s en concreto de distribuciones Linux/GNU . El CLI de las distribuciones de Linux/GNU es conocido como Shell o terminal, con esta interfaz es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas, debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura . Estructura de Linux NOTA Por lo tanto, es buena pr\u00e1ctica que el administrador del sistemas tenga conocimientos en el manejo y gesti\u00f3n del terminal Shell, as\u00ed como en la programaci\u00f3n de scripts . Shell \u00b6 En inform\u00e1tica, el shell o int\u00e9rprete de comandos , es el programa inform\u00e1tico que permite a los usuarios interactuar con el sistema, procesando las \u00f3rdenes que se le indican; adem\u00e1s provee una interfaz de usuario para acceder a los servicios del sistema operativo. Los comandos ejecutables desde el shell pueden clasificarse en internos (corresponden en realidad a \u00f3rdenes interpretadas por el propio shell) y externos (corresponden a ficheros ejecutables externos al shell, conocidos como guiones o scripts). IMPORTANTE: Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... A destacar: sh (Bourne Shell) : este shell fue usado desde las primeras versiones de Unix (Unix Versi\u00f3n 7). Recibe ese nombre por su desarrollador, Stephen Bourne , de los Laboratorios Bell de AT&T . bash : fue desarrollado para ser un superconjunto de la funcionalidad del Bourne Shell, siendo el int\u00e9rprete de comandos asignado por defecto a los usuarios en las distribuciones de Linux, por lo que es el shell empleado en la mayor\u00eda de las consolas de comandos de Linux. Se caracteriza por una gran funcionalidad adicional a la del Bourne Shell. Para intentar homogeneizar esta diversidad de shells, el IEEE defini\u00f3 un est\u00e1ndar de \u00abint\u00e9rprete de comandos\u00bb bajo la especificaci\u00f3n POSIX 1003.2 (tambi\u00e9n recogida como ISO 9945.2 ). La creaci\u00f3n de dicho est\u00e1ndar se bas\u00f3 en la sintaxis que presentaban m\u00faltiples shells de la familia Bourne shell. bash respeta completamente el est\u00e1ndar POSIX, sobre el que a\u00f1ade un n\u00famero considerable de extensiones (estructura select, arrays, mayor n\u00famero de operadores,\u2026). En este tema utilizaremos el Shell de bash . Formato comandos \u00b6 En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y min\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE . Principales comandos \u00b6 Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado Shell Script en GNU/Linux \u00b6 Un Shell script (guion) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell. Estructura general \u00b6 En su forma m\u00e1s b\u00e1sica, un shell-script puede ser un simple fichero de texto que contenga uno o varios comandos. Para ayudar a la identificaci\u00f3n del contenido a partir del nombre del archivo, es habitual que los shell scripts tengan la extensi\u00f3n \u00ab.sh\u00bb, Se seguir\u00e1 este criterio pero hay que tener en cuenta que es informativo y opcional. #!/bin/bash #********************************* #Este es mi primer script #********************************* echo Hola Mundo #Esto es un comentario, soy muy \u00fatil. Creaci\u00f3n Shell scripts \u00b6 Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: (ubicados en la carpeta que contiene el archivo), se pueden utilizar el siguiente archivo: ./script.sh Adem\u00e1s se puede utilizar otro m\u00e9todo que consiste en definir la carpeta dentro de la variable de entorno PATH (editando el fichero .bashrc .) Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH NOTA La primera forma ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado. El primer Shellscript \u00b6 Crea un ejemplo llamado listar.sh , se aconseja ejecutar los siguientes comandos de forma secuencial. cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \u201cListado realizado el \u201c $( date ) Comentarios \u00b6 Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Es el \"Shebang\" Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta. Depuraci\u00f3n \u00b6 Esta tarea no es sencilla en ShellScripting, aun as\u00ed se recomienda los siguientes m\u00e9todos de depuraci\u00f3n, apoyados en los siguientes argumentos a la hora de ejecutar el script: -x \u2192 Expande cada orden simple, e imprime por pantalla la orden con sus argumentos, y a continuaci\u00f3n su salida. -v \u2192 Imprime en pantalla cada elemento completo del script (estructura de control, \u2026) y a continuaci\u00f3n su salida. Adem\u00e1s en el propio Script se pueden utilizar los siguientes comandos: Comando Acci\u00f3n set -x set \u2013xv Activa las trazas/verbose. Se debe ubicar justo antes del trozo del script que se desea depurar. set +x set +xv Desactiva las trazas/verbose. Ubicarlo justo despu\u00e9s del trozo del script que se desea depurar. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un script que guarde en un fichero el listado de archivos y directorios de la carpeta etc , a posteriori que imprima por pantalla dicho listado. Modifica el script anterior para que adem\u00e1s muestre por pantalla el n\u00famero de l\u00edneas del archivo y el n\u00famero de palabras. Depura los ejercicios anteriores utilizando los argumentos -x y -v .","title":"1.1- Introducci\u00f3n"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#introduccion","text":"Para administrar sistemas operativos es crucial manejar y dominar las interfaces (terminales) disponibles que nos permiten gestionarlos. Entre dichas interfaces destacan los siguientes tipos: De l\u00edneas de texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos/ventanas ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario, ejemplo SIRI en IOS). Este tema se centra en Sistemas basados en c\u00f3digo libre del tipo UNIX, debido a su amplio despliegue en empresas para implementar servicios, m\u00e1s en concreto de distribuciones Linux/GNU . El CLI de las distribuciones de Linux/GNU es conocido como Shell o terminal, con esta interfaz es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas, debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura . Estructura de Linux NOTA Por lo tanto, es buena pr\u00e1ctica que el administrador del sistemas tenga conocimientos en el manejo y gesti\u00f3n del terminal Shell, as\u00ed como en la programaci\u00f3n de scripts .","title":"Introducci\u00f3n"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#shell","text":"En inform\u00e1tica, el shell o int\u00e9rprete de comandos , es el programa inform\u00e1tico que permite a los usuarios interactuar con el sistema, procesando las \u00f3rdenes que se le indican; adem\u00e1s provee una interfaz de usuario para acceder a los servicios del sistema operativo. Los comandos ejecutables desde el shell pueden clasificarse en internos (corresponden en realidad a \u00f3rdenes interpretadas por el propio shell) y externos (corresponden a ficheros ejecutables externos al shell, conocidos como guiones o scripts). IMPORTANTE: Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... A destacar: sh (Bourne Shell) : este shell fue usado desde las primeras versiones de Unix (Unix Versi\u00f3n 7). Recibe ese nombre por su desarrollador, Stephen Bourne , de los Laboratorios Bell de AT&T . bash : fue desarrollado para ser un superconjunto de la funcionalidad del Bourne Shell, siendo el int\u00e9rprete de comandos asignado por defecto a los usuarios en las distribuciones de Linux, por lo que es el shell empleado en la mayor\u00eda de las consolas de comandos de Linux. Se caracteriza por una gran funcionalidad adicional a la del Bourne Shell. Para intentar homogeneizar esta diversidad de shells, el IEEE defini\u00f3 un est\u00e1ndar de \u00abint\u00e9rprete de comandos\u00bb bajo la especificaci\u00f3n POSIX 1003.2 (tambi\u00e9n recogida como ISO 9945.2 ). La creaci\u00f3n de dicho est\u00e1ndar se bas\u00f3 en la sintaxis que presentaban m\u00faltiples shells de la familia Bourne shell. bash respeta completamente el est\u00e1ndar POSIX, sobre el que a\u00f1ade un n\u00famero considerable de extensiones (estructura select, arrays, mayor n\u00famero de operadores,\u2026). En este tema utilizaremos el Shell de bash .","title":"Shell"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#formato-comandos","text":"En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y min\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE .","title":"Formato comandos"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#principales-comandos","text":"Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado","title":"Principales comandos"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#shell-script-en-gnulinux","text":"Un Shell script (guion) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell.","title":"Shell Script en GNU/Linux"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#estructura-general","text":"En su forma m\u00e1s b\u00e1sica, un shell-script puede ser un simple fichero de texto que contenga uno o varios comandos. Para ayudar a la identificaci\u00f3n del contenido a partir del nombre del archivo, es habitual que los shell scripts tengan la extensi\u00f3n \u00ab.sh\u00bb, Se seguir\u00e1 este criterio pero hay que tener en cuenta que es informativo y opcional. #!/bin/bash #********************************* #Este es mi primer script #********************************* echo Hola Mundo #Esto es un comentario, soy muy \u00fatil.","title":"Estructura general"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#creacion-shell-scripts","text":"Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: (ubicados en la carpeta que contiene el archivo), se pueden utilizar el siguiente archivo: ./script.sh Adem\u00e1s se puede utilizar otro m\u00e9todo que consiste en definir la carpeta dentro de la variable de entorno PATH (editando el fichero .bashrc .) Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH NOTA La primera forma ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado.","title":"Creaci\u00f3n Shell scripts"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#el-primer-shellscript","text":"Crea un ejemplo llamado listar.sh , se aconseja ejecutar los siguientes comandos de forma secuencial. cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \u201cListado realizado el \u201c $( date )","title":"El primer Shellscript"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#comentarios","text":"Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Es el \"Shebang\" Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta.","title":"Comentarios"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#depuracion","text":"Esta tarea no es sencilla en ShellScripting, aun as\u00ed se recomienda los siguientes m\u00e9todos de depuraci\u00f3n, apoyados en los siguientes argumentos a la hora de ejecutar el script: -x \u2192 Expande cada orden simple, e imprime por pantalla la orden con sus argumentos, y a continuaci\u00f3n su salida. -v \u2192 Imprime en pantalla cada elemento completo del script (estructura de control, \u2026) y a continuaci\u00f3n su salida. Adem\u00e1s en el propio Script se pueden utilizar los siguientes comandos: Comando Acci\u00f3n set -x set \u2013xv Activa las trazas/verbose. Se debe ubicar justo antes del trozo del script que se desea depurar. set +x set +xv Desactiva las trazas/verbose. Ubicarlo justo despu\u00e9s del trozo del script que se desea depurar.","title":"Depuraci\u00f3n"},{"location":"01_ShellScripting/011_ShellScript_Intro.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un script que guarde en un fichero el listado de archivos y directorios de la carpeta etc , a posteriori que imprima por pantalla dicho listado. Modifica el script anterior para que adem\u00e1s muestre por pantalla el n\u00famero de l\u00edneas del archivo y el n\u00famero de palabras. Depura los ejercicios anteriores utilizando los argumentos -x y -v .","title":"Actividades"},{"location":"01_ShellScripting/011_ShellScripting_Total.html","text":"Shell Scripting \u00b6 Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas libres . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados. Introducci\u00f3n Linux \u00b6 Breve Historia \u00b6 1969 La empresa AT&T desarrolla el sistema operativo UNIX y vendido posteriormente a Novell. 1983 Richard Stallman comienza el proyecto GNU (GNU is Not Unix) para crear un SO tipo UNIX pero de software libre. Software libre: Aquel software, que una vez adquirido (no tiene porque ser gratuito), puede ser usado, copiado, modificado y redistribuido, con cambios o mejoras. 1985 Microsoft publica Windows, un sistema operativo con interfaz gr\u00e1fica de usuario (GUI) para su sistema operativo MS-DOS. 1991 Linus Torvald comienza a programar el sistema operativo Linux (Linus + UNIX). El c\u00f3digo era totalmente nuevo, pero emulaba el funcionamiento del sistema operativo MINIX (Tanenbaum), con estructura de micronucleo. 1992 Se juntan el proyecto Linux y GNU \u2192 GNU/Linux. 2001 Se lanza el primer sistema operativo MAC (MAC OS X) con interfaz de escritorio. MAC est\u00e1 basado en UNIX. Principales Actores \u00b6 Principales Actores en la creaci\u00f3n de GNU/Linux Caracter\u00edsticas \u00b6 Software Libre \u2192 Cualquiera puede usarlo o descargarlo. Licencias GPL (General Public License) de GNU. La Licencia P\u00fablica General de GNU o m\u00e1s conocida por su nombre en ingl\u00e9s GNU General Public License es una licencia de derecho de autor ampliamente usada en el mundo del software libre y c\u00f3digo abierto, \u200b y garantiza a los usuarios finales la libertad de usar, estudiar, compartir y modificar el software. C\u00f3digo Abierto \u2192 Cualquiera puede ver y modificar el c\u00f3digo. En la siguiente tabla se muestra algunas de las principales caracter\u00edsticas. Tabla con algunas caracter\u00edsticas de Linux Distribuciones \u00b6 Gratuitas: Ubuntu, CentOS, Mint, Fedora, Knoppix, OpenSUSE. En el caso de Ubuntu sacan distribuciones LTS que tienen mayor tiempo de actualizaciones. Las versiones indican el a\u00f1o y el mes en que se saca dicha versi\u00f3n. Por ejemplo 17.04 (A\u00f1o 2017, Abril). Pago: RedHat o SUSE. Se paga por el soporte, no por el software en s\u00ed. Las distribuciones de pago tambi\u00e9n suelen tener sus versiones gratuitas. Principales distribuciones \u00b6 Algunas Distribuciones de Linux Shell \u00b6 En inform\u00e1tica, el shell o int\u00e9rprete de \u00f3rdenes o int\u00e9rprete de comandos es el programa inform\u00e1tico que provee una interfaz de usuario para acceder a los servicios del sistema operativo. Dependiendo del tipo de interfaz que empleen, los shells pueden ser: De l\u00edneas texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario). En un terminal (Shell) es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas. Debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura. Estructura de Linux Tip Es buena pr\u00e1ctica que el administrador del sistema tenga conocimientos en el manejo del terminal as\u00ed como en la programaci\u00f3n de scripts. Info Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... En este tema utilizaremos el Shell bash . Formato comandos \u00b6 En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y nim\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE . Principales comandos \u00b6 Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado Shell Script en GNU/Linux \u00b6 Un Shell script (gui\u00f3n) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell. Creaci\u00f3n Shell scripts \u00b6 Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: ubicados en la carpeta que contiene el archivo, se pueden utilizar tres formas: Se teclea el nombre del archivo en el terminal precedido del comando sh sh script.sh Precedido de un punto . . script.sh ./ script.sh Definir la carpeta dentro de la variable de entorno PATH (tambi\u00e9n editando el fichero .bashrc ). Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH Info Cualquiera de estas dos primeras formas ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado. El primer Shellscript \u00b6 Crea un ejemplo llamado listar.sh cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \"Listado realizado el\" $( date ) Comentarios \u00b6 Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta. Argumentos o Par\u00e1metros \u00b6 Son especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script ./script.sh Caballo Perro 675 Nueva El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito Variables \u00b6 Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos . Variables de entorno \u00b6 Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde busca los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio Entrada y salida del Shell Script \u00b6 Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo . echo \u00b6 Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla Modificador Funci\u00f3n -e para usar las opciones hay utilizar el modificador \\c Sirve para eliminar el salto de l\u00ednea natural del comando echo . \\n nueva l\u00ednea. \\t tabulador horizontal. \\v tabulador vertical. Info Si se antepone el s\u00edmbolo del d\u00f3lar delante de una variable, mostrar\u00e1 su contenido Si es necesario mostrar frases con espacios, debe situarse entre comillas Warning La orden echo permite expandir variables siempre que se usen las comillas dobles. Ejemplo: #!/bin/bash NOMBRE = Javi echo \u201chola $NOMBRE \u201d El texto mostrado por pantalla ser\u00e1: hola javi read \u00b6 Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Lo que hace read es detener la ejecuci\u00f3n del shell script y pasa el testigo al usuario. Hasta que \u00e9ste no introduzca los datos, la ejecuci\u00f3n del programa no avanzar\u00e1. Ejemplo: #!/bin/bash echo \u201cIntroduce tu nombre: \u201d read NOMBRE echo \u201cHola $NOMBRE \u201d Info Cuando se utiliza read con varios nombres de variables, el primer campo tecleado por el usuario se asigna a la primera variable, el segundo campo a la segunda y as\u00ed sucesivamente Ejemplo: #!/bin/bash read -p \u201cIntroduce tres n\u00fameros ( separados por un espacio ) : \u201d num1 num2 num3 echo \u201cLos n\u00famero introducidos son $num1 , $num2 y $num3 \u201d Info En este ejemplo se ha usado el modificador -p el cual permite imprimir un mensaje antes de la recogida de los datos, prescindiendo de primer comando echo del ejemplo anterior. Operadores en shell script \u00b6 Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es s\u00f3lo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos aritm\u00e9ticos \u00b6 Los operadores aritm\u00e9ticos realizan operaciones matem\u00e1ticas, como sumas o restas con operandos. \"Manipulan\" datos num\u00e9ricos, tanto enteros como reales. S\u00edmbolo Funci\u00f3n + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % modulo (resto) = asignaci\u00f3n Ejemplo: #!/bin/bash #********************************* #Esto es mi tercer script #********************************* NUMERO = 4 let SUMA = NUMERO+3 echo $SUMA NUMERO = 5 let SUMA = NUMERO+5 echo $SUMA NUMERO = 10 let SUMA = NUMERO-10 relacionales \u00b6 Este tipo de operadores tan s\u00f3lo devuelven dos posibles valores; verdadero o falso . Existen subtipos seg\u00fan se comparen cadenas o n\u00fameros. 1. Operadores relacionales para n\u00fameros Operador Acci\u00f3n -eq Comprueba si dos n\u00fameros son iguales. -ne Detecta si dos n\u00fameros son diferentes. -gt Revisa si la izquierda es mayor que derecha. -lt Verifica si la izquierda es menor que derecha. -ge Coteja si la izquierda es mayor o igual que derecha. -le Constata si la izquierda es menor o igual que derecha. 2. Operadores relacionales para cadenas de texto o de cuerda Operador Acci\u00f3n -z Comprueba si la longitud de la cadena es cero. -n Eval\u00faa si la longitud de la cadena no es cero. = Verifica si las cadenas son iguales. != Coteja si las cadenas son diferentes. cadena Revisa si la cadena es nula. 3. Operadores relacionales para archivos y directorios Operador Acci\u00f3n -a Comprueba si existe el archivo. -r Eval\u00faa si la longitud de la cadena no es cero. -w Confirma si existe el archivo y tiene permisos de escritura. -x Constata si existe el archivo y tiene permisos de ejecuci\u00f3n. -f Escruta si existe y es un fichero regular. -d Escruta si existe y es un fichero regular. -h Coteja si existe y es un enlace. -s Revisa si existe el archivo y su tama\u00f1o es mayor a cero. l\u00f3gicos \u00b6 Se utilizan para evaluar condiciones, no elementos. Comprueba el resultado de dos operandos y devuelve verdadero o falso en funci\u00f3n del valor que arrojen los operandos. Los tipos son: Operador Acci\u00f3n && AND , devuelve verdadero si todas condiciones que eval\u00faa son verdaderas. Se puede representar: -a o && . || OR , da como resultado verdadero si alguna de las condiciones que eval\u00faa es verdadera. Se representar: -o o || . ! negaci\u00f3n , invierte el significado del operando. de verdadero a falso, y viceversa. Con ! o not . Info Para realizar c\u00e1lculos aritm\u00e9ticos es necesario utilizar expresiones como expr , let o los expansores . expr \u00b6 Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Cada t\u00e9rmino de la expresi\u00f3n debe ir separado por espacios en blanco. Soporta diferentes operaciones: sumar, restar, multiplicar y dividir enteros utilizando los operadores aritm\u00e9ticos para el c\u00e1lculo del m\u00f3dulo. Tip MEJOR NO UTILIZAR Desafortunadamente, expr es dif\u00edcil de utilizar debido a las colisiones entre su sintaxis y la propia del terminal. Puesto que * es el s\u00edmbolo comod\u00edn, deber\u00e1 ir precedido por una barra invertida para que el terminal lo interprete literalmente como un asterisco. Adem\u00e1s, es muy inc\u00f3modo de trabajar ya que los espacios entre los elementos de una expresi\u00f3n son cr\u00edticos. Ejemplo: #!/bin/bash var = 5 resultado = ` expr $1 + $var + 1 echo $resultado ` let \u00b6 Facilita la sintaxis de estas operaciones aritm\u00e9ticas reduci\u00e9ndolas a la m\u00ednima expresi\u00f3n. No es necesario incluir el s\u00edmbolo del d\u00f3lar que precede a las variables. Se configura como un comando m\u00e1s c\u00f3modo de ejecutar. Ejemplo: #!/bin/bash var = 5 let resultado = $1 +var+1 echo $resultado expansores \u00b6 Para las operaciones aritm\u00e9ticas se utilizan los dobles par\u00e9ntesis. Realizan la operaci\u00f3n contenida dentro de ellos lanzando la ejecuci\u00f3n fuera de ellos una vez resuelta. Ejemplo: #!/bin/bash var = 5 echo $(( $1 + $var + 1 )) echo $(( $1 + $var + 1 )) Tip Consejo de uso , ya que es mucho m\u00e1s intuitivo que las anteriores expresiones. Redirecciones \u00b6 Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado . Tuber\u00edas \u00b6 Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuberias para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo. alias \u00b6 Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019 Sistema de notaci\u00f3n \u00b6 Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos. Diagramas de flujo \u00b6 Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. Note Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En lo sucesivo se ilustrar\u00e1n las diferentes estructuras de control a trav\u00e9s de esta t\u00e9cnica la cual facilita su comprensi\u00f3n. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas. Control de flujo \u00b6 Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estrcuturas que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for . Estructuras condicionales \u00b6 Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ). Estructura alternativa doble: if \u00b6 La forma general de la orden if es: if [ expresi\u00f3n ] then realizar este c\u00f3digo si expresi\u00f3n es verdadera fi Estructura alternativa simple. Ejemplo: if [ $# -eq 1 ] then VAR = $1 fi Info El c\u00f3digo anterior comprueba se ha pasado alg\u00fan argumento ,es decir, si han pasado un par\u00e1metro. En caso afirmativo, asigna el contenido de ese par\u00e1metro a la variable VAR. Warning Hay que recordar siempre cerrar esta estructura para indicarle al terminal donde termina, en este caso, se cierra con la palabra reservada fi . Estructura alternativa multiple if then else \u00b6 En este caso se contempla tambi\u00e9n la posibilidad de ejecutar alguna acci\u00f3n si no se cumple la expresi\u00f3n. La forma general del if then else es: if [ expresi\u00f3n ] then realizar si expresi\u00f3n es verdadera else realizar si expresi\u00f3n es falsa fi Estructura alternativa doble. Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" else echo \" $a es menor que $b \" fi La estructura if then elif else \u00b6 Permite una segunda evaluaci\u00f3n para ejecutar c\u00f3digo a trav\u00e9s de la estructura elif . Es posible colocar tantos elif como condiciones se requiera evaluar. La forma general del if then elif else es: if [ exp1 ] then realizar si exp1 es verdadera elif [ exp2 ] then realizar si exp1 es falsa, pero es verdadera exp2 elif [ exp3 ] then realizar si exp1 y exp2 son falsas, pero es verdadera exp3 else realizar si todas las expresiones son falsas fi Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" elif [ $a -eq $b ] then echo \" $a es igual que $b \" else echo \" $a es menor que $b \" fi Info Este ejemplo ampl\u00eda el anterior comprobando si, adem\u00e1s, los valores de a y b son iguales. Warning El \u00faltimo caso se realiza con la sentencia else . La estructura case \u00b6 La estructura case permite realizar varias acciones en funci\u00f3n del valor de una variable. La limitaci\u00f3n que tan s\u00f3lo se comprueba si es igual a ese valor. La forma general del case es: case VARIABLE in valor1 ) Se ejecuta si VARIABLE tiene el valor1 ;; valor2 ) Se ejecuta si VARIABLE tiene el valor2 ;; * ) Se ejecuta por defecto ;; esac Estructura Alternativa Multiple. Estructuras de iteraci\u00f3n \u00b6 Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. Info La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. Info La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno, o bien los valores booleanos verdadero o falso. Info Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa. Las estructuras while y until \u00b6 Estas estructuras van a repetir el c\u00f3digo que contienen mientras la expresi\u00f3n evaluada sea verdadera. El funcionamiento es l\u00f3gico: Eval\u00faa la condici\u00f3n, si es falsa, no realiza ninguna acci\u00f3n y continua con el siguiente c\u00f3digo del programa. Si es verdadera entra en el bucle y ejecuta el c\u00f3digo que contiene. Al finalizar la ejecuci\u00f3n, al iterar, vuelve a evaluar la condici\u00f3n y vuelve a repetir la operaci\u00f3n anterior. Warning Al construir una estructura while es preciso asegurarse que en alg\u00fan momento de su ejecuci\u00f3n la condici\u00f3n dejar\u00e1 de cumplirse y se romper\u00e1 el ciclo, si no, \u00e9ste ser\u00e1 infinito, a menos que el usuario o el sistema interrumpa su ejecuci\u00f3n. WHILE while [ expresi\u00f3n ] do c\u00f3digo se repite MIENTRAS la expresi\u00f3n sea verdadera done UNTIL until [ expresi\u00f3n ] do c\u00f3digo se repite HASTA que la expresi\u00f3n sea verdadera done Info La diferencia es que un until se ejecuta como m\u00ednimo una vez, ya que ejecuta el c\u00f3digo y luego comprueba, mientras que el while es posible que nunca se ejecute, ya que es posible que la condici\u00f3n de entrada nunca se cumpla. Ejemplo: while [ expresi\u00f3n ] #! /bin/bash read -p \u201cEscribe un n\u00famero: \u201c num i = 1 while [ $i -le 10 ] do let res = num*i echo \u201c $i x $num = $res \u201d let i = i+1 done Info Este c\u00f3digo imprime por pantalla la tabla de multiplicar del n\u00famero que el usuario ha especificado. Las l\u00edneas contenidas entre do y done se ejecutar\u00e1n mientras i sea menor o igual a diez. Al final de cada iteraci\u00f3n el valor de i se incrementa en uno (es un contador) por lo que en diez iteraciones la condici\u00f3n dejar\u00e1 de cumplirse y el bucle se romper\u00e1. La estructuras for \u00b6 Esta estructura permite repetir c\u00f3digo por cada elemento de un conjunto determinado. No necesita condici\u00f3n de salida ya que al finalizar los elementos del conjunto acabar\u00e1 con su ejecuci\u00f3n. la forma general es: for variable in conjunto do estas l\u00edneas se repiten una vez por cada elemento del conjunto variable toma los valores del conjunto, uno en cada iteraci\u00f3n done * Ejemplo: #! /bin/bash read -p \u201cEscribe la direcci\u00f3n de una carpeta: \u201c car for i in $( ls $car ) do if [ -f $i ] then echo \u201c $i es un archivo de tipo regular\u201d elif [ -d $i ] then echo \u201c $i es un archivo de tipo directorio\u201d else echo \u201c $i es otro tipo de archivo o no existe\u201d fi done Info Este ejemplo se van a mostrar los nombres de los ficheros que contiene un directorio y dir\u00e1 si es un directorio o un fichero. Romper un bucle de forma deliberada \u00b6 No s\u00f3lo es posible terminar un bucle cuando se cumpla una condici\u00f3n o cuando se terminen los elementos de un conjunto, shell script proporciona dos formas de alterar el funcionamiento de la estructura en un bucle y romperla en funci\u00f3n de las necesidades del programa: break rompe el bucle que lo contiene y contin\u00faa la ejecuci\u00f3n del script. continue rompe la iteraci\u00f3n que lo contiene, pero mantiene el bucle, que continuar\u00e1 con la siguiente iteraci\u00f3n hasta que termine su ejecuci\u00f3n. exit detiene la ejecuci\u00f3n del script. Este comando no es exclusivo de las estructuras iterativas, pero cobra especial sentido en este \u00e1mbito. Vectores en shell script \u00b6 Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, por ejemplo, para recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done Funciones en shell script \u00b6 Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se identifican a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 } En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Actividades iniciales \u00b6 Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b Actividades de desarrollo UD1_01 \u00b6 Modifica el shell script realizado en el ejercicio 102 para comprobar si el fichero existe. En tal caso debe contar el n\u00famero de l\u00edneas del mismo a trav\u00e9s del comando wc y mostrar un mensaje indicando dicho n\u00famero. Si el fichero no existe, debe mostrar un mensaje de error y salir. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until . Actividades de desarrollo UD1_02 \u00b6 Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Crea un shell script para jugar a \u201cDoble o Nada\u201d. Consistir\u00e1 en adivinar un n\u00famero entre 1 y 10 (este n\u00famero ser\u00e1 generado al azar por el ordenador, para ello debes utilizar la funci\u00f3n $RANDOM de la siguiente manera numero=$RANDOM % 10 ). * A\u00f1ade al juego las siguientes caracter\u00edsticas: El jugador apuesta una cantidad de un valor inicial de 100 puntos. Si sale cara obtiene el doble de la cantidad apostada. Si sale cruz pierde todo lo apostado. El shell script debe llevar la cuenta de las tiradas y de la cantidad ganada. Al final de la partida mostrar\u00e1 un informe por pantalla a modo de resumen. Modificar el shell script anterior para que permita ir jugando hasta que el jugador decida abandonar el juego (para ello deber\u00e1 pulsar la tecla \u201cx\u201d del teclado), o no tenga m\u00e1s dinero que apostar. Tampoco podr\u00e1 apostar m\u00e1s dinero del que dispone en su \u201ccartera virtual\u201d. Actividades de desarrollo UD1_03 \u00b6 Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados.","title":"Shell Scripting"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#shell-scripting","text":"Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas libres . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados.","title":"Shell Scripting"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#introduccion-linux","text":"","title":"Introducci\u00f3n Linux"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#breve-historia","text":"1969 La empresa AT&T desarrolla el sistema operativo UNIX y vendido posteriormente a Novell. 1983 Richard Stallman comienza el proyecto GNU (GNU is Not Unix) para crear un SO tipo UNIX pero de software libre. Software libre: Aquel software, que una vez adquirido (no tiene porque ser gratuito), puede ser usado, copiado, modificado y redistribuido, con cambios o mejoras. 1985 Microsoft publica Windows, un sistema operativo con interfaz gr\u00e1fica de usuario (GUI) para su sistema operativo MS-DOS. 1991 Linus Torvald comienza a programar el sistema operativo Linux (Linus + UNIX). El c\u00f3digo era totalmente nuevo, pero emulaba el funcionamiento del sistema operativo MINIX (Tanenbaum), con estructura de micronucleo. 1992 Se juntan el proyecto Linux y GNU \u2192 GNU/Linux. 2001 Se lanza el primer sistema operativo MAC (MAC OS X) con interfaz de escritorio. MAC est\u00e1 basado en UNIX.","title":"Breve Historia"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#principales-actores","text":"Principales Actores en la creaci\u00f3n de GNU/Linux","title":"Principales Actores"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#caracteristicas","text":"Software Libre \u2192 Cualquiera puede usarlo o descargarlo. Licencias GPL (General Public License) de GNU. La Licencia P\u00fablica General de GNU o m\u00e1s conocida por su nombre en ingl\u00e9s GNU General Public License es una licencia de derecho de autor ampliamente usada en el mundo del software libre y c\u00f3digo abierto, \u200b y garantiza a los usuarios finales la libertad de usar, estudiar, compartir y modificar el software. C\u00f3digo Abierto \u2192 Cualquiera puede ver y modificar el c\u00f3digo. En la siguiente tabla se muestra algunas de las principales caracter\u00edsticas. Tabla con algunas caracter\u00edsticas de Linux","title":"Caracter\u00edsticas"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#distribuciones","text":"Gratuitas: Ubuntu, CentOS, Mint, Fedora, Knoppix, OpenSUSE. En el caso de Ubuntu sacan distribuciones LTS que tienen mayor tiempo de actualizaciones. Las versiones indican el a\u00f1o y el mes en que se saca dicha versi\u00f3n. Por ejemplo 17.04 (A\u00f1o 2017, Abril). Pago: RedHat o SUSE. Se paga por el soporte, no por el software en s\u00ed. Las distribuciones de pago tambi\u00e9n suelen tener sus versiones gratuitas.","title":"Distribuciones"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#principales-distribuciones","text":"Algunas Distribuciones de Linux","title":"Principales distribuciones"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#shell","text":"En inform\u00e1tica, el shell o int\u00e9rprete de \u00f3rdenes o int\u00e9rprete de comandos es el programa inform\u00e1tico que provee una interfaz de usuario para acceder a los servicios del sistema operativo. Dependiendo del tipo de interfaz que empleen, los shells pueden ser: De l\u00edneas texto ( CLI , Command-Line Interface, interfaz de l\u00ednea de comandos), Gr\u00e1ficos ( GUI , Graphical User Interface, interfaz gr\u00e1fica de usuario), De lenguaje natural ( NUI , Natural User Interface, interfaz natural de usuario). En un terminal (Shell) es posible crear cualquier comando que el usuario necesite, incluso para las tareas m\u00e1s espec\u00edficas. Debido a estar directamente conectado al Kernel a diferencia de las aplicaciones como se puede observar en la siguiente figura. Estructura de Linux Tip Es buena pr\u00e1ctica que el administrador del sistema tenga conocimientos en el manejo del terminal as\u00ed como en la programaci\u00f3n de scripts. Info Linux dispone de varios Shell diferentes csh , bash , sh , ksh , zsh , etc... En este tema utilizaremos el Shell bash .","title":"Shell"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#formato-comandos","text":"En general, el formato de las \u00f3rdenes de GNU/Linux es el siguiente: Comando , que indica la acci\u00f3n que se va a ejecutar. Modificadores , que cambian el comportamiento est\u00e1ndar del comando para adaptarlo a las necesidades. Argumentos , elementos necesarios para realizar la acci\u00f3n del comando. Warning Un dato a tener en cuenta cuando se trabaja con un terminal, es que GNU/Linux distingue entre may\u00fasculas y nim\u00fasculas, es decir, la ejecuci\u00f3n de comandos en el CLI de Linux es CASE SENSITIVE .","title":"Formato comandos"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#principales-comandos","text":"Comando Acci\u00f3n Comando Acci\u00f3n ls muestra el contenido de una carpeta uname muestra informaci\u00f3n del sistema df muestra estado del disco cd cambiar de directorio fsck comprueba integridad de discos mkdir crear directorios mount monta particiones y vol\u00famenes shutdown apaga el equipo ( restart o reboot ) unmount desmonta particiones y vol\u00famenes clear limpia la pantalla fdisk administra particiones date/cal muestra hora/calendario del sistema echo imprime por pantalla who muestra quien est\u00e1 conectado","title":"Principales comandos"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#shell-script-en-gnulinux","text":"Un Shell script (gui\u00f3n) es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados, es decir, es un programa escrito de comandos Shell para ser ejecutados de forma secuencial. De esta forma se pueden automatizar tareas repetitivas ahorrando tiempo al administrador. Un programa escrito en shell se denomina shellscript, programa shell o simplemente un shell.","title":"Shell Script en GNU/Linux"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#creacion-shell-scripts","text":"Para crear un script utilizaremos cualquiera de los editores de texto plano como vi , vim , nano . Despu\u00e9s de crear el archivo hay que dotarlo de permisos de lectura y ejecuci\u00f3n. chmod ugo = rx script.sh Para ejecutar el archivo: ubicados en la carpeta que contiene el archivo, se pueden utilizar tres formas: Se teclea el nombre del archivo en el terminal precedido del comando sh sh script.sh Precedido de un punto . . script.sh ./ script.sh Definir la carpeta dentro de la variable de entorno PATH (tambi\u00e9n editando el fichero .bashrc ). Una vez realizado ya se podr\u00eda ejecutar directamente el fichero con el nombre del script. mkdir /home/administrador/scripts PATH = $PATH :/home/administrador/scripts export PATH Info Cualquiera de estas dos primeras formas ejecutar\u00e1 el contenido del shell script en un subshell o hilo del terminal original. El programa se ejecuta hasta que se terminan las \u00f3rdenes del archivo, se recibe una se\u00f1al de finalizaci\u00f3n, se encuentra un error sint\u00e1ctico o se llega a una orden exit . Cuando el programa termina, el subshell muere y el terminal original toma el control del sistema. Esto no ocurre si se usa la opci\u00f3n de PATH , la cual ejecuta el contenido del shell script en el mismo terminal donde fue invocado.","title":"Creaci\u00f3n Shell scripts"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#el-primer-shellscript","text":"Crea un ejemplo llamado listar.sh cd ~ mkdir scripts cd scripts touch listar.sh nano listar.sh Genera, guarda y prueba el siguiente c\u00f3digo. #! /bin/bash clear ls -la echo \"Listado realizado el\" $( date )","title":"El primer Shellscript"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#comentarios","text":"Para realizar un comentario se usa el car\u00e1cter # Cuando el terminal encuentra una l\u00ednea que comienza con este car\u00e1cter, ignora todo lo que existe desde \u00e9l hasta el final de l\u00ednea. A esta regla existe una excepci\u00f3n: #!/bin/bash Info Indica el terminal que ser\u00e1 utilizado por el shell script, no un comentario. Esta l\u00ednea debe ser la primera del fichero que, a\u00fan siendo opcional, indica el tipo de lenguaje en el que ha sido escrito el programa. Si la versi\u00f3n de GNU/Linux dispone de el terminal especificado en esta l\u00ednea, ejecutar\u00e1 el c\u00f3digo con \u00e9l, si no es as\u00ed, utilizar\u00e1 el que por defecto tenga asignado el usuario que lo ejecuta.","title":"Comentarios"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#argumentos-o-parametros","text":"Son especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script ./script.sh Caballo Perro 675 Nueva El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito","title":"Argumentos o Par\u00e1metros"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#variables","text":"Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos .","title":"Variables"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#variables-de-entorno","text":"Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde busca los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio","title":"Variables de entorno"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#entrada-y-salida-del-shell-script","text":"Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo .","title":"Entrada y salida del Shell Script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#operadores-en-shell-script","text":"Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es s\u00f3lo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos","title":"Operadores en shell script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#redirecciones","text":"Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado .","title":"Redirecciones"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#tuberias","text":"Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuberias para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo.","title":"Tuber\u00edas"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#alias","text":"Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019","title":"alias"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#sistema-de-notacion","text":"Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos.","title":"Sistema de notaci\u00f3n"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#diagramas-de-flujo","text":"Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. Note Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En lo sucesivo se ilustrar\u00e1n las diferentes estructuras de control a trav\u00e9s de esta t\u00e9cnica la cual facilita su comprensi\u00f3n. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas.","title":"Diagramas de flujo"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#control-de-flujo","text":"Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estrcuturas que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for .","title":"Control de flujo"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#estructuras-condicionales","text":"Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ).","title":"Estructuras condicionales"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#estructuras-de-iteracion","text":"Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. Info La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. Info La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno, o bien los valores booleanos verdadero o falso. Info Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa.","title":"Estructuras de iteraci\u00f3n"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#vectores-en-shell-script","text":"Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, por ejemplo, para recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done","title":"Vectores en shell script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#funciones-en-shell-script","text":"Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se identifican a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 } En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3.","title":"Funciones en shell script"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-iniciales","text":"Crea un shell script que muestre por pantalla el mensaje \u201c \u00a1Hola Mundo! \u201d. Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b","title":"Actividades iniciales"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-de-desarrollo-ud1_01","text":"Modifica el shell script realizado en el ejercicio 102 para comprobar si el fichero existe. En tal caso debe contar el n\u00famero de l\u00edneas del mismo a trav\u00e9s del comando wc y mostrar un mensaje indicando dicho n\u00famero. Si el fichero no existe, debe mostrar un mensaje de error y salir. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until .","title":"Actividades de desarrollo UD1_01"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-de-desarrollo-ud1_02","text":"Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Crea un shell script para jugar a \u201cDoble o Nada\u201d. Consistir\u00e1 en adivinar un n\u00famero entre 1 y 10 (este n\u00famero ser\u00e1 generado al azar por el ordenador, para ello debes utilizar la funci\u00f3n $RANDOM de la siguiente manera numero=$RANDOM % 10 ). * A\u00f1ade al juego las siguientes caracter\u00edsticas: El jugador apuesta una cantidad de un valor inicial de 100 puntos. Si sale cara obtiene el doble de la cantidad apostada. Si sale cruz pierde todo lo apostado. El shell script debe llevar la cuenta de las tiradas y de la cantidad ganada. Al final de la partida mostrar\u00e1 un informe por pantalla a modo de resumen. Modificar el shell script anterior para que permita ir jugando hasta que el jugador decida abandonar el juego (para ello deber\u00e1 pulsar la tecla \u201cx\u201d del teclado), o no tenga m\u00e1s dinero que apostar. Tampoco podr\u00e1 apostar m\u00e1s dinero del que dispone en su \u201ccartera virtual\u201d.","title":"Actividades de desarrollo UD1_02"},{"location":"01_ShellScripting/011_ShellScripting_Total.html#actividades-de-desarrollo-ud1_03","text":"Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados.","title":"Actividades de desarrollo UD1_03"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html","text":"Sintaxis \u00b6 Argumentos o Par\u00e1metros \u00b6 Son especificaciones que se le hacen al programa al momento de llamarlo. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script Si por ejemplo se enviasen los siguientes par\u00e1metros: ./script.sh Caballo Perro 675 Nueva Se obtendr\u00eda la siguiente salida: El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito Variables \u00b6 Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ . Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos . Variables de entorno \u00b6 Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde se buscan los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio Entrada y salida del Shell Script \u00b6 Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo . echo \u00b6 Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla Modificador Funci\u00f3n -e para usar las opciones hay que utilizar este modificador \\c Sirve para eliminar el salto de l\u00ednea natural del comando echo . \\n nueva l\u00ednea. \\t tabulador horizontal. \\v tabulador vertical. Info Si se antepone el s\u00edmbolo del d\u00f3lar delante de una variable, mostrar\u00e1 su contenido. Si es necesario mostrar frases con espacios, debe situarse entre comillas. Warning La orden echo permite expandir variables siempre que se usen las comillas dobles. Ejemplo: #!/bin/bash NOMBRE = Javi echo \u201chola $NOMBRE \u201d El texto mostrado por pantalla ser\u00e1: hola javi read \u00b6 Esta herramienta asigna el texto que el usuario ha escrito en el terminal a una o m\u00e1s variables. Lo que hace read es detener la ejecuci\u00f3n del shell script y pasa el testigo al usuario. Hasta que \u00e9ste no introduzca los datos, la ejecuci\u00f3n del programa no avanzar\u00e1. Ejemplo: #!/bin/bash echo \u201cIntroduce tu nombre: \u201d read NOMBRE echo \u201cHola $NOMBRE \u201d Info Cuando se utiliza read con varios nombres de variables, el primer campo tecleado por el usuario se asigna a la primera variable, el segundo campo a la segunda y as\u00ed sucesivamente Ejemplo: #!/bin/bash read -p \u201cIntroduce tres n\u00fameros ( separados por un espacio ) : \u201d num1 num2 num3 echo \u201cLos n\u00famero introducidos son $num1 , $num2 y $num3 \u201d Info En este ejemplo se ha usado el modificador -p el cual permite imprimir un mensaje antes de la recogida de los datos, prescindiendo de primer comando echo del ejemplo anterior. Operadores en shell script \u00b6 Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es solo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos Aritm\u00e9ticos \u00b6 Los operadores aritm\u00e9ticos realizan operaciones matem\u00e1ticas, como sumas o restas con operandos. \"Manipulan\" datos num\u00e9ricos, tanto enteros como reales. S\u00edmbolo Funci\u00f3n + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % modulo (resto) = asignaci\u00f3n Ejemplo: #!/bin/bash #********************************* #Esto es mi tercer script #********************************* NUMERO = 4 let SUMA = NUMERO+3 echo $SUMA NUMERO = 5 let SUMA = NUMERO+5 echo $SUMA NUMERO = 10 let SUMA = NUMERO-10 Relacionales \u00b6 Este tipo de operadores tan s\u00f3lo devuelven dos posibles valores; verdadero o falso . Existen subtipos seg\u00fan se comparen cadenas o n\u00fameros. 1. Operadores relacionales para n\u00fameros Operador Acci\u00f3n -eq Comprueba si dos n\u00fameros son iguales. -ne Detecta si dos n\u00fameros son diferentes. -gt Revisa si la izquierda es mayor que derecha. -lt Verifica si la izquierda es menor que derecha. -ge Coteja si la izquierda es mayor o igual que derecha. -le Constata si la izquierda es menor o igual que derecha. 2. Operadores relacionales para cadenas de texto o de cuerda Operador Acci\u00f3n -z Comprueba si la longitud de la cadena es cero. -n Eval\u00faa si la longitud de la cadena no es cero. = Verifica si las cadenas son iguales. != Coteja si las cadenas son diferentes. cadena Revisa si la cadena es nula. 3. Operadores relacionales para archivos y directorios Operador Acci\u00f3n -a Comprueba si existe el archivo. -r Eval\u00faa si el archivo esta vac\u00edo. -w Confirma si existe el archivo y tiene permisos de escritura. -x Constata si existe el archivo y tiene permisos de ejecuci\u00f3n. -f Escruta si existe y es un archivo de tipo regular. -d Escruta si existe y es un archivo de tipo directorio. -h Coteja si existe y es un enlace. -s Revisa si existe el archivo y su tama\u00f1o es mayor a cero. L\u00f3gicos \u00b6 Se utilizan para evaluar condiciones, no elementos. Comprueba el resultado de dos operandos y devuelve verdadero o falso en funci\u00f3n del valor que arrojen los operandos. Los tipos son: Operador Acci\u00f3n && AND , devuelve verdadero si todas condiciones que eval\u00faa son verdaderas. Se puede representar: -a o && . || OR , da como resultado verdadero si alguna de las condiciones que eval\u00faa es verdadera. Se representar: -o o || . ! negaci\u00f3n , invierte el significado del operando. de verdadero a falso, y viceversa. Con ! o not . Info Para realizar c\u00e1lculos aritm\u00e9ticos es necesario utilizar expresiones como expr , let o los expansores . expr \u00b6 Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Cada t\u00e9rmino de la expresi\u00f3n debe ir separado por espacios en blanco. Soporta diferentes operaciones: sumar, restar, multiplicar y dividir enteros utilizando los operadores aritm\u00e9ticos para el c\u00e1lculo del m\u00f3dulo. Tip MEJOR NO UTILIZAR Desafortunadamente, expr es dif\u00edcil de utilizar debido a las colisiones entre su sintaxis y la propia terminal. Puesto que * es el s\u00edmbolo comod\u00edn, deber\u00e1 ir precedido por una barra invertida para que el terminal lo interprete literalmente como un asterisco. Adem\u00e1s, es muy inc\u00f3modo de trabajar ya que los espacios entre los elementos de una expresi\u00f3n son cr\u00edticos. Ejemplo: #!/bin/bash var = 5 resultado = ` expr $1 + $var + 1 echo $resultado ` let \u00b6 Facilita la sintaxis de estas operaciones aritm\u00e9ticas reduci\u00e9ndolas a la m\u00ednima expresi\u00f3n. No es necesario incluir el s\u00edmbolo del d\u00f3lar que precede a las variables. Se configura como un comando m\u00e1s c\u00f3modo de ejecutar. Ejemplo: #!/bin/bash var = 5 let resultado = $1 +var+1 echo $resultado expansores \u00b6 Para las operaciones aritm\u00e9ticas se utilizan los dobles par\u00e9ntesis. Realizan la operaci\u00f3n contenida dentro de ellos lanzando la ejecuci\u00f3n fuera de ellos una vez resuelta. Ejemplo: #!/bin/bash var = 5 echo $(( $1 + $var + 1 )) echo $(( $1 + $var + 1 )) Tip Consejo de uso , ya que es mucho m\u00e1s intuitivo que las anteriores expresiones. Redirecciones \u00b6 Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado . Tuber\u00edas \u00b6 Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuber\u00edas para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo. alias \u00b6 Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019 Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b Realiza un script que muestre por pantalla los par\u00e1metros introducidos separados por espacio, el n\u00famero de par\u00e1metros que se han pasado, y el nombre del script. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Genera un script que muestre los usuarios conectados en el sistema operativo, comprobando que son usuarios dados de alta en el mismo.","title":"1.2- Sintaxis"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#sintaxis","text":"","title":"Sintaxis"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#argumentos-o-parametros","text":"Son especificaciones que se le hacen al programa al momento de llamarlo. Introducen un valor, cadena o variable dentro del script. Utilizaci\u00f3n de par\u00e1metros: S\u00edmbolo Funci\u00f3n $1 representa el 1\u00ba par\u00e1metro pasado al script $2 representa el 2\u00ba par\u00e1metro $3 representa el 3\u00ba par\u00e1metro (podemos usar hasta $9) $* representa todos los par\u00e1metros separados por espacio $# representa el n\u00famero de par\u00e1metros que se han pasado $0 representa el par\u00e1metro 0, es decir, el nombre del script o el nombre de la funci\u00f3n Ejemplo: #!/bin/bash echo \u2018El primer par\u00e1metro que se ha pasado es \u2018 $1 echo \u2018El tercer par\u00e1metro que se ha pasado es \u2018 $3 echo \u2018El conjunto de todos los par\u00e1metros : \u2018 $* echo \u2018Me has pasado un total de \u2018 $# \u2018 par\u00e1metros\u2019\u201d echo \u2018El par\u00e1metro 0 es : \u2018 $0 #Fin del script Si por ejemplo se enviasen los siguientes par\u00e1metros: ./script.sh Caballo Perro 675 Nueva Se obtendr\u00eda la siguiente salida: El primer par\u00e1metro que se ha pasado es Caballo El tercer par\u00e1metro que se ha pasado es 675 El conjunto de todos los par\u00e1metros : Caballo Perro 675 Nueva Me has pasado un total de 4 par\u00e1metros El par\u00e1metro 0 es : ./script.sh Info Argumento especial $? Contiene el valor que devuelve la ejecuci\u00f3n de un comando. Puede tener dos valores: cero si se ha ejecutado bien y se interpreta como verdadero, o distinto de cero si se ha ejecutado mal y se interpreta como falso. 0 -> Si el \u00faltimo comando se ejecut\u00f3 con \u00e9xito !0 -> Si el \u00faltimo comando no de ejecut\u00f3 con \u00e9xito","title":"Argumentos o Par\u00e1metros"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#variables","text":"Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Se da un nombre para identificarla y recuperarla, antecedido por el car\u00e1cter $ . Info En shellscript no se declaran y no importa el tipo . El nombre de la variable puede estar compuesto por letras y n\u00fameros y por el car\u00e1cter subrayado \u201c _ \u201d. Ejemplo: #! /bin/bash #********************************* #Este es mi segundo script #********************************* MIVARIABLE = \u2018Administraci\u00f3n de Sistemas Operativos ASO\u2019 echo $MIVARIABLE Warning Deben empezar por letra o \u201c _ \u201d En ning\u00fan caso pueden empezar por un n\u00famero, ya que esa nomenclatura est\u00e1 reservada a los par\u00e1metros. El contenido de estas variables ser\u00e1 siempre tomado como si fuesen cadenas alfanum\u00e9ricas, es decir, ser\u00e1n tratadas como cadenas de texto. Por lo tanto se necesitan operandos o comandos espec\u00edficos para realizar operaciones con valores num\u00e9ricos de las variables. Explicado en el apartado de Operadores Aritm\u00e9ticos .","title":"Variables"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#variables-de-entorno","text":"Cada terminal durante su ejecuci\u00f3n tiene acceso a dos \u00e1mbitos de memoria: Datos Locales Una variable declarada en un terminal solo ser\u00e1 accesible desde el terminal en el que declara. Datos Global Engloban a todos los terminales que se est\u00e9n ejecutando. Son las denominadas Variables de Entorno . Ejemplo de principales variables de entorno: Variable Funci\u00f3n $BASH Ruta del programa Bash $HOME Ruta completa del home del usuario $PATH Lista los directorios de donde se buscan los programas $RANDOM Devuelve un valor num\u00e9rico aleatorio","title":"Variables de entorno"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#entrada-y-salida-del-shell-script","text":"Para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada de datos. Para dinamizar el resultado de los shell scripts y un dispositivo de salida que mantenga informado al usuario en todo momento de los que est\u00e1 ocurriendo. Para la entrada de datos se utiliza el comando read y para la salida el comando echo .","title":"Entrada y salida del Shell Script"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#echo","text":"Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla Modificador Funci\u00f3n -e para usar las opciones hay que utilizar este modificador \\c Sirve para eliminar el salto de l\u00ednea natural del comando echo . \\n nueva l\u00ednea. \\t tabulador horizontal. \\v tabulador vertical. Info Si se antepone el s\u00edmbolo del d\u00f3lar delante de una variable, mostrar\u00e1 su contenido. Si es necesario mostrar frases con espacios, debe situarse entre comillas. Warning La orden echo permite expandir variables siempre que se usen las comillas dobles. Ejemplo: #!/bin/bash NOMBRE = Javi echo \u201chola $NOMBRE \u201d El texto mostrado por pantalla ser\u00e1: hola javi","title":"echo"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#read","text":"Esta herramienta asigna el texto que el usuario ha escrito en el terminal a una o m\u00e1s variables. Lo que hace read es detener la ejecuci\u00f3n del shell script y pasa el testigo al usuario. Hasta que \u00e9ste no introduzca los datos, la ejecuci\u00f3n del programa no avanzar\u00e1. Ejemplo: #!/bin/bash echo \u201cIntroduce tu nombre: \u201d read NOMBRE echo \u201cHola $NOMBRE \u201d Info Cuando se utiliza read con varios nombres de variables, el primer campo tecleado por el usuario se asigna a la primera variable, el segundo campo a la segunda y as\u00ed sucesivamente Ejemplo: #!/bin/bash read -p \u201cIntroduce tres n\u00fameros ( separados por un espacio ) : \u201d num1 num2 num3 echo \u201cLos n\u00famero introducidos son $num1 , $num2 y $num3 \u201d Info En este ejemplo se ha usado el modificador -p el cual permite imprimir un mensaje antes de la recogida de los datos, prescindiendo de primer comando echo del ejemplo anterior.","title":"read"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#operadores-en-shell-script","text":"Todas las variables creadas en un terminal se tratan como cadenas de texto, incluso si su contenido es solo num\u00e9rico. Este es el motivo por el cual si lanzamos el siguiente c\u00f3digo, no se obtendr\u00e1 el resultado esperado: #!/bin/bash var1 = 15 var2 = 5 echo \u201c $var1 + $var2 \u201d Warning La salida de este programa no ser\u00e1 un n\u00famero 20 , sino la cadena de caracteres 15+5 . Esto es as\u00ed porque la suma de cadenas de texto, son esas cadenas de texto unidas de forma consecutiva. Existen tres tipos de operadores seg\u00fan el trabajo que realicen: aritm\u00e9ticos, relacionales y l\u00f3gicos","title":"Operadores en shell script"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#aritmeticos","text":"Los operadores aritm\u00e9ticos realizan operaciones matem\u00e1ticas, como sumas o restas con operandos. \"Manipulan\" datos num\u00e9ricos, tanto enteros como reales. S\u00edmbolo Funci\u00f3n + suma - resta * multiplicaci\u00f3n / divisi\u00f3n % modulo (resto) = asignaci\u00f3n Ejemplo: #!/bin/bash #********************************* #Esto es mi tercer script #********************************* NUMERO = 4 let SUMA = NUMERO+3 echo $SUMA NUMERO = 5 let SUMA = NUMERO+5 echo $SUMA NUMERO = 10 let SUMA = NUMERO-10","title":"Aritm\u00e9ticos"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#relacionales","text":"Este tipo de operadores tan s\u00f3lo devuelven dos posibles valores; verdadero o falso . Existen subtipos seg\u00fan se comparen cadenas o n\u00fameros. 1. Operadores relacionales para n\u00fameros Operador Acci\u00f3n -eq Comprueba si dos n\u00fameros son iguales. -ne Detecta si dos n\u00fameros son diferentes. -gt Revisa si la izquierda es mayor que derecha. -lt Verifica si la izquierda es menor que derecha. -ge Coteja si la izquierda es mayor o igual que derecha. -le Constata si la izquierda es menor o igual que derecha. 2. Operadores relacionales para cadenas de texto o de cuerda Operador Acci\u00f3n -z Comprueba si la longitud de la cadena es cero. -n Eval\u00faa si la longitud de la cadena no es cero. = Verifica si las cadenas son iguales. != Coteja si las cadenas son diferentes. cadena Revisa si la cadena es nula. 3. Operadores relacionales para archivos y directorios Operador Acci\u00f3n -a Comprueba si existe el archivo. -r Eval\u00faa si el archivo esta vac\u00edo. -w Confirma si existe el archivo y tiene permisos de escritura. -x Constata si existe el archivo y tiene permisos de ejecuci\u00f3n. -f Escruta si existe y es un archivo de tipo regular. -d Escruta si existe y es un archivo de tipo directorio. -h Coteja si existe y es un enlace. -s Revisa si existe el archivo y su tama\u00f1o es mayor a cero.","title":"Relacionales"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#logicos","text":"Se utilizan para evaluar condiciones, no elementos. Comprueba el resultado de dos operandos y devuelve verdadero o falso en funci\u00f3n del valor que arrojen los operandos. Los tipos son: Operador Acci\u00f3n && AND , devuelve verdadero si todas condiciones que eval\u00faa son verdaderas. Se puede representar: -a o && . || OR , da como resultado verdadero si alguna de las condiciones que eval\u00faa es verdadera. Se representar: -o o || . ! negaci\u00f3n , invierte el significado del operando. de verdadero a falso, y viceversa. Con ! o not . Info Para realizar c\u00e1lculos aritm\u00e9ticos es necesario utilizar expresiones como expr , let o los expansores .","title":"L\u00f3gicos"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#expr","text":"Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Cada t\u00e9rmino de la expresi\u00f3n debe ir separado por espacios en blanco. Soporta diferentes operaciones: sumar, restar, multiplicar y dividir enteros utilizando los operadores aritm\u00e9ticos para el c\u00e1lculo del m\u00f3dulo. Tip MEJOR NO UTILIZAR Desafortunadamente, expr es dif\u00edcil de utilizar debido a las colisiones entre su sintaxis y la propia terminal. Puesto que * es el s\u00edmbolo comod\u00edn, deber\u00e1 ir precedido por una barra invertida para que el terminal lo interprete literalmente como un asterisco. Adem\u00e1s, es muy inc\u00f3modo de trabajar ya que los espacios entre los elementos de una expresi\u00f3n son cr\u00edticos. Ejemplo: #!/bin/bash var = 5 resultado = ` expr $1 + $var + 1 echo $resultado `","title":"expr"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#let","text":"Facilita la sintaxis de estas operaciones aritm\u00e9ticas reduci\u00e9ndolas a la m\u00ednima expresi\u00f3n. No es necesario incluir el s\u00edmbolo del d\u00f3lar que precede a las variables. Se configura como un comando m\u00e1s c\u00f3modo de ejecutar. Ejemplo: #!/bin/bash var = 5 let resultado = $1 +var+1 echo $resultado","title":"let"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#expansores","text":"Para las operaciones aritm\u00e9ticas se utilizan los dobles par\u00e9ntesis. Realizan la operaci\u00f3n contenida dentro de ellos lanzando la ejecuci\u00f3n fuera de ellos una vez resuelta. Ejemplo: #!/bin/bash var = 5 echo $(( $1 + $var + 1 )) echo $(( $1 + $var + 1 )) Tip Consejo de uso , ya que es mucho m\u00e1s intuitivo que las anteriores expresiones.","title":"expansores"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#redirecciones","text":"Una redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Para ello se utilizan los siguientes s\u00edmbolos: S\u00edmbolo Acci\u00f3n < redirecciona la entrada desde el fichero stdin (entrada est\u00e1ndar) > env\u00eda la salida de stdout (salida est\u00e1ndar) a un fichero especificado >> a\u00f1ade la salida de stdout (salida est\u00e1ndar) a un fichero especificado 2> env\u00eda la salida de stderr (error est\u00e1ndar) a un fichero especificado * Ejemplo: sh script.sh 2 >/dev/null Info El objetivo de la expresi\u00f3n anterior puede ser utilizada en la administraci\u00f3n de sistemas para descartar el error est\u00e1ndar de un proceso, de esta forma no aparecer\u00e1n los mensajes de error por el terminal; es muy utilizado .","title":"Redirecciones"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#tuberias","text":"Forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Esto se logra usando el s\u00edmbolo | (pipeline). Ejemplo: $ cat archivo.txt | wc Info El comando anterior utiliza tuber\u00edas para redireccionar la salida est\u00e1ndar del comando cat y pasarla como entrada est\u00e1ndar del comando wc para contar las l\u00edneas y palabras de un archivo.","title":"Tuber\u00edas"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#alias","text":"Alias es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Cada usuario puede asignar una palabra f\u00e1cil de recordar a uno o m\u00e1s comandos que, por lo general, pueden ser m\u00e1s complicados de recordar. Ejemplo: alias listado = \u2019ls -lia>\u2019","title":"alias"},{"location":"01_ShellScripting/012_ShelScript_Sintaxis.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b Realiza un script que muestre por pantalla los par\u00e1metros introducidos separados por espacio, el n\u00famero de par\u00e1metros que se han pasado, y el nombre del script. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Genera un script que muestre los usuarios conectados en el sistema operativo, comprobando que son usuarios dados de alta en el mismo.","title":"Actividades"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html","text":"Control de Flujo \u00b6 Sistema de notaci\u00f3n \u00b6 Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos. Diagramas de flujo \u00b6 Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. NOTA Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas. Estructuras \u00b6 Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estructuras que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for . Estructuras alternativas \u00b6 Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ). Estructura alternativa doble: if \u00b6 La forma general de la orden if es: if [ expresi\u00f3n ] then realizar este c\u00f3digo si expresi\u00f3n es verdadera fi Estructura alternativa simple. Ejemplo: if [ $# -eq 1 ] then VAR = $1 fi Info El c\u00f3digo anterior comprueba se ha pasado alg\u00fan argumento ,es decir, si han pasado un par\u00e1metro. En caso afirmativo, asigna el contenido de ese par\u00e1metro a la variable VAR. Warning Hay que recordar siempre cerrar esta estructura para indicarle al terminal donde termina, en este caso, se cierra con la palabra reservada fi . Estructura alternativa multiple if then else \u00b6 En este caso se contempla tambi\u00e9n la posibilidad de ejecutar alguna acci\u00f3n si no se cumple la expresi\u00f3n. La forma general del if then else es: if [ expresi\u00f3n ] then realizar si expresi\u00f3n es verdadera else realizar si expresi\u00f3n es falsa fi Estructura alternativa doble. Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" else echo \" $a es menor que $b \" fi La estructura if then elif else \u00b6 Permite una segunda evaluaci\u00f3n para ejecutar c\u00f3digo a trav\u00e9s de la estructura elif . Es posible colocar tantos elif como condiciones se requiera evaluar. La forma general del if then elif else es: if [ exp1 ] then realizar si exp1 es verdadera elif [ exp2 ] then realizar si exp1 es falsa, pero es verdadera exp2 elif [ exp3 ] then realizar si exp1 y exp2 son falsas, pero es verdadera exp3 else realizar si todas las expresiones son falsas fi Ejemplo: if [ $a -gt $b ] then echo \" $a es mayor que $b \" elif [ $a -eq $b ] then echo \" $a es igual que $b \" else echo \" $a es menor que $b \" fi Info Este ejemplo ampl\u00eda el anterior comprobando si, adem\u00e1s, los valores de a y b son iguales. Warning El \u00faltimo caso se realiza con la sentencia else . La estructura case \u00b6 La estructura case permite realizar varias acciones en funci\u00f3n del valor de una variable. La limitaci\u00f3n que tan s\u00f3lo se comprueba si es igual a ese valor. La forma general del case es: case VARIABLE in valor1 ) Se ejecuta si VARIABLE tiene el valor1 ;; valor2 ) Se ejecuta si VARIABLE tiene el valor2 ;; * ) Se ejecuta por defecto ;; esac Estructura Alternativa Multiple. Estructuras de iteraci\u00f3n \u00b6 Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. NOTA La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. NOTA La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno , o bien los valores booleanos verdadero o falso . NOTA Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa. Las estructuras while y until \u00b6 Estas estructuras van a repetir el c\u00f3digo que contienen mientras la expresi\u00f3n evaluada sea verdadera. Funcionamiento: Eval\u00faa la condici\u00f3n, si es falsa, no realiza ninguna acci\u00f3n y continua con el siguiente c\u00f3digo del programa. Si es verdadera entra en el bucle y ejecuta el c\u00f3digo que contiene. Al finalizar la ejecuci\u00f3n, al iterar, vuelve a evaluar la condici\u00f3n y vuelve a repetir la operaci\u00f3n anterior. Warning Al construir una estructura while es preciso asegurarse que en alg\u00fan momento de su ejecuci\u00f3n la condici\u00f3n dejar\u00e1 de cumplirse y se romper\u00e1 el ciclo, si no, \u00e9ste ser\u00e1 infinito, a menos que el usuario o el sistema interrumpa su ejecuci\u00f3n. WHILE while [ expresi\u00f3n ] do c\u00f3digo se repite MIENTRAS la expresi\u00f3n sea verdadera done UNTIL until [ expresi\u00f3n ] do c\u00f3digo se repite HASTA que la expresi\u00f3n sea verdadera done Info La diferencia es que un until se ejecuta como m\u00ednimo una vez, ya que ejecuta el c\u00f3digo y luego comprueba, mientras que el while es posible que nunca se ejecute, ya que es posible que la condici\u00f3n de entrada nunca se cumpla. Ejemplo: #! /bin/bash read -p \"Escribe un n\u00famero: \" num i = 1 while [ $i -le 10 ] do let res = num*i echo \" $i x $num = $res \" let i = i+1 done Info Este c\u00f3digo imprime por pantalla la tabla de multiplicar del n\u00famero que el usuario ha especificado. Las l\u00edneas contenidas entre do y done se ejecutar\u00e1n mientras i sea menor o igual a diez. Al final de cada iteraci\u00f3n el valor de i se incrementa en uno (es un contador) por lo que en diez iteraciones la condici\u00f3n dejar\u00e1 de cumplirse y el bucle se romper\u00e1. La estructuras for \u00b6 Esta estructura permite repetir c\u00f3digo por cada elemento de un conjunto determinado. No necesita condici\u00f3n de salida ya que al finalizar los elementos del conjunto acabar\u00e1 con su ejecuci\u00f3n. la forma general es: for variable in conjunto do estas l\u00edneas se repiten una vez por cada elemento del conjunto variable toma los valores del conjunto, uno en cada iteraci\u00f3n done * Ejemplo: #! /bin/bash read -p \u201cEscribe la direcci\u00f3n de una carpeta: \u201c car for i in $( ls $car ) do if [ -f $i ] then echo \u201c $i es un archivo de tipo regular\u201d elif [ -d $i ] then echo \u201c $i es un archivo de tipo directorio\u201d else echo \u201c $i es otro tipo de archivo o no existe\u201d fi done NOTA Este ejemplo se van a mostrar los nombres de los ficheros que contiene un directorio y dir\u00e1 si es un directorio o un fichero. Romper un bucle de forma deliberada \u00b6 No s\u00f3lo es posible terminar un bucle cuando se cumpla una condici\u00f3n o cuando se terminen los elementos de un conjunto, shell script proporciona dos formas de alterar el funcionamiento de la estructura en un bucle y romperla en funci\u00f3n de las necesidades del programa: break rompe el bucle que lo contiene y contin\u00faa la ejecuci\u00f3n del script. continue rompe la iteraci\u00f3n que lo contiene, pero mantiene el bucle, que continuar\u00e1 con la siguiente iteraci\u00f3n hasta que termine su ejecuci\u00f3n. exit detiene la ejecuci\u00f3n del script. Este comando no es exclusivo de las estructuras iterativas, pero cobra especial sentido en este \u00e1mbito. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until .","title":"1.3- Control de flujo"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#control-de-flujo","text":"","title":"Control de Flujo"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#sistema-de-notacion","text":"Antes de lanzarse a escribir una sola l\u00ednea de c\u00f3digo es necesario pensar en la resoluci\u00f3n del problema tal y como se ha indicado. La creaci\u00f3n de una soluci\u00f3n a un problema siguiendo un conjunto de instrucciones se denomina algoritmo. Es necesario invertir el tiempo suficiente para construir ese algoritmo ya que esa ser\u00e1 la soluci\u00f3n que se debe implementar en c\u00f3digo. Existen varios sistemas de representaci\u00f3n para describir esos algoritmos; pseudoc\u00f3digo , la descripci\u00f3n narrada o diagramas Nassi-Shneiderman , pero en este manual se ha optado por los diagramas de flujo ya que resultan m\u00e1s intuitivos.","title":"Sistema de notaci\u00f3n"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#diagramas-de-flujo","text":"Los diagramas de flujo o flujogramas son la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Para dise\u00f1arlos se emplean figuras normalizadas que representan una acci\u00f3n dentro del procedimiento. Cada una de estas figuras representa un paso a seguir dentro del algoritmo. NOTA Para su construcci\u00f3n se han de respetar las siguientes reglas: Tiene un elemento de inicio en la parte superior y uno final en la parte inferior. Se escribe de arriba hacia abajo y de izquierda a derecha. Siempre se usan flechas verticales u horizontales, jam\u00e1s curvas u oblicuas Se debe evitar cruce de flujos. En cada paso expresar una acci\u00f3n concreta. En la siguiente figura se puede observar simbolog\u00eda para dise\u00f1ar diagramas de flujo. Simbolog\u00eda diagramas.","title":"Diagramas de flujo"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#estructuras","text":"Controlar el flujo es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. Si no existiese las estructuras de control del flujo, todo el c\u00f3digo se ejecutar\u00edan de forma secuencial, es decir, empezar\u00edan por la primera instrucci\u00f3n y se ejecutar\u00edan una a una hasta llegar a la \u00faltima. Este modo de ejecuci\u00f3n esta realizado por estructuras secuenciales . Ejemplo: Estructura secuencial. Warning La estructura secuencial no es v\u00e1lida para solucionar la mayor\u00eda de los problemas que se plantean. Para ello es necesario la elecci\u00f3n de un c\u00f3digo u otro en funci\u00f3n de ciertas condiciones, formado otro tipo de estructuras que son conocidas como estructuras condicionales ; entre las cuales podemos destacar: Estructuras Alternativas , seg\u00fan si se cumple la condici\u00f3n o no, se realizar\u00e1 una tarea u otra. Ejemplo de utilizaci\u00f3n con la sentencia: if . Estructuras Iterativas , cuando necesario ejecutar algunas instrucciones repetidas veces. Ejemplo de utilizaci\u00f3n con la sentencia: for .","title":"Estructuras"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#estructuras-alternativas","text":"Las estructuras de selecci\u00f3n permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Tambi\u00e9n se les llama ramificaciones, estructuras de decisi\u00f3n o alternativas. Cuando se usan, no todas las instrucciones del programa se ejecutan, solo las especificadas para el valor de la variable durante esa ejecuci\u00f3n. Las estructuras de selecci\u00f3n m\u00e1s comunes son las que proporcionan ramificaciones dobles ( if ) y m\u00faltiples ( elif y case ).","title":"Estructuras alternativas"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#estructuras-de-iteracion","text":"Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. El conjunto de instrucciones que se ejecuta dentro de esta estructura, se denomina ciclo, bucle o lazo. Iteraci\u00f3n es cada una de las pasadas o ejecuciones de todas las instrucciones contenidas en el bucle. Estas repeticiones de c\u00f3digo van a depender de la evaluaci\u00f3n de una condici\u00f3n o del valor de una variable. Es posible repetir un c\u00f3digo hasta que se cumpla o deje de cumplir una condici\u00f3n pero tambi\u00e9n se posible la repetici\u00f3n tantas veces como indique una variable. Warning Hay que tener mucho cuidado a la hora de dise\u00f1ar estas estructuras y no caer en el error de construir bucles infinitos , es decir, estructuras que nunca dejar\u00e1n de ejecutarse ya que no tienen condici\u00f3n de salida o, si la tienen, \u00e9sta nunca se va a cumplir. Para utilizar esta estructura en algoritmos, se usan: Contador: es una variable cuyo valor se incrementa o decrementa en una cantidad constante cada vez que se produce un determinado suceso o acci\u00f3n. Los contadores se utilizan con la finalidad de contar sucesos o acciones internas de un bucle. NOTA La inicializaci\u00f3n consiste en asignarle al contador un valor. Se situar\u00e1 antes y fuera del bucle. Acumulador o Totalizador es una variable que suma sobre s\u00ed misma un conjunto de valores para de esta manera tener el total de todos ellos en una sola variable. NOTA La diferencia entre un contador y un acumulador es que mientras el primero va aumentando de uno en uno, el acumulador va aumentando en una cantidad variable. Banderas , conocidas tambi\u00e9n como interruptores, switch, flags o conmutadores. Son variables que pueden tomar solamente dos valores durante la ejecuci\u00f3n del programa, los cuales pueden ser cero o uno , o bien los valores booleanos verdadero o falso . NOTA Se les suele llamar interruptores porque cuando toman un valor est\u00e1n simulando un interruptor abierto/cerrado o encendido/apagado. Estructura Iterativa.","title":"Estructuras de iteraci\u00f3n"},{"location":"01_ShellScripting/013_ShellScript_ControlFlujo.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un shell script que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Para obtener la hora del sistema utiliza el comando date. Construye un programa denominado AGENDA que permita mediante un men\u00fa, el mantenimiento de un peque\u00f1o archivo lista.txt con el nombre, direcci\u00f3n y tel\u00e9fono de varias personas. Debes incluir estas opciones al programa: A\u00f1adir (a\u00f1adir un registro) Buscar (buscar entradas por nombre, direcci\u00f3n o tel\u00e9fono) Listar (visualizar todo el archivo). Ordenar (ordenar los registros alfab\u00e9ticamente). Borrar (borrar el archivo). Crea un shell script que sume los n\u00fameros del 1 al 1000 mediante una estructura for , while y until .","title":"Actividades"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html","text":"Vectores y Funciones \u00b6 Vectores en shell script \u00b6 Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done Funciones en shell script \u00b6 Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se distinguen a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script utilizando funciones que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados. Genera un script que rellene un vector con diez n\u00fameros pedidos al usuario y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores los valores ordenados de menor a mayor en una sola l\u00ednea los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores cantidad de valores pares que contiene el vector la suma total de n\u00fameros impares la media aritm\u00e9tica de los valores que contiene el vector Crea un script que muestre las opciones del ejercicio anterior con select. El usuario introducir\u00e1 los valores del vector al iniciar el script. Cuando termine aparecer\u00e1 el men\u00fa de selecci\u00f3n (deber\u00e1s a\u00f1adir la opci\u00f3n para salir del script). Adem\u00e1s deber\u00e1s crear una funci\u00f3n para cada opci\u00f3n del men\u00fa y llamarla en cada una de las opciones del select.","title":"1.4- Vectores y Funciones"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#vectores-y-funciones","text":"","title":"Vectores y Funciones"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#vectores-en-shell-script","text":"Un vector es una estructura de datos que permite almacenar una colecci\u00f3n de elementos. Por el hecho de tratarse de una estructura de datos es posible realizar operaciones sobre \u00e9l como buscar, eliminar y agregar elementos a su estructura. Los elementos se encuentran ordenados en funci\u00f3n de como han sido introducidos en la estructura. Para acceder a cada elemento ser\u00e1 necesario especificar la posici\u00f3n que ocupan dentro de ella, teniendo presente que la numeraci\u00f3n de los vectores comienza desde cero, no desde uno. Info Un buen ejemplo de uso ser\u00eda, recoger el listado de archivos que hay en una carpeta. Esquema de un vector de doce elementos. Para definir un vector disponemos de dos formas: Impl\u00edcita: hace referencia a que el vector ha sido declarado y al mismo tiempo se han inicializado sus valores. Expl\u00edcitamente: cuando el vector no requiere que se inicialice mientras se declara, es decir, pueden ser inicializados con posterioridad. Para declarar un vector hay que utilizar la siguiente estructura: declare -a meses =( \"enero\" \"febrero\" \"marzo\" ) Tambi\u00e9n es posible utilizar alguna expresi\u00f3n para completar un vector, como con el operador rango ... declare -a letras =( { N..Z } { s..z } ) echo ${ letras [*] } Info Esto crear\u00e1 un vector con el siguiente contenido y lo mostrar\u00e1 por pantalla as\u00ed: N O P Q R S T U V W X Y Z s t u v w x y z Para a\u00f1adir un elemento a la estructura se debe indicar el \u00edndice o posici\u00f3n que ocupar\u00e1 el nuevo dato. Si el \u00edndice es mayor que la \u00faltima posici\u00f3n de la estructura, se escribir\u00e1 al final de la misma. Si se usa un \u00edndice que ya contiene un dato, \u00e9ste ser\u00e1 sobrescrito. meses [ 3 ]= \"abril\" Para mostrar el contenido del vector: echo ${ meses [*] } Info Mostrar\u00e1: enero febrero marzo abril Es buena idea conocer el n\u00famero de elementos que contiene un vector para poder introducir datos de forma correcta y no sobrescribir por accidente alg\u00fan valor ya almacenado. As\u00ed es posible utilizar: Comando Acci\u00f3n ${meses[*]} Muestra todos los valores del vector ${!meses[*]} Muestra todos los \u00edndices del vector ${#meses[*]} Devuelve el n\u00famero de valores del vector ${#meses[0]} Imprime la longitud del primer dato del vector Para recorrer los valores que contiene esta estructura se puede utilizar un bucle for for item in ${ meses [*] } do echo $item done * Tambi\u00e9n se puede utilizar sus \u00edndices para mostrar los datos contenidos. for index in ${ !meses[*] } do echo ${ meses [ $index ] } done Es una estructura muy \u00fatil en la que se puede guardar cualquier tipo de informaci\u00f3n, como por ejemplo los ficheros que contiene una carpeta: i = 0 ; for fichero in $( ls -a ) do ficheros [ $i ]= $fichero ; let i = i+1 ; done","title":"Vectores en shell script"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#funciones-en-shell-script","text":"Una funci\u00f3n es un conjunto de l\u00edneas de c\u00f3digo que se distinguen a trav\u00e9s de un identificador y que se ejecutan al invocar ese identificador. Se podr\u00eda definir como un shell script dentro de un shell script. Sirve para organizarlo en unidades l\u00f3gicas m\u00e1s peque\u00f1as de manera que sea m\u00e1s f\u00e1cil mantenerlo. Las funciones aceptan par\u00e1metros, de id\u00e9ntica manera que los shell script, por lo que su uso tambi\u00e9n es muy intuitivo. La estructura de una funci\u00f3n queda definida de la siguiente manera: function nombre_funci\u00f3n (){ c\u00f3digo que se ejecutar\u00e1 al llamar a la funci\u00f3n } Info source Para incluir el c\u00f3digo de un fichero en otro tan s\u00f3lo ser\u00e1 necesario utilizar la palabra source seguida de la ruta de ese fichero. * * Tambi\u00e9n es posible usar el punto para poder cargarlo: source funciones.sh o ./funciones.sh Las funciones suelen declararse al inicio del documento y luego utilizadas a lo largo del programa. Uno de los objetivos es optimizar el c\u00f3digo, mediante el \"aprovechamiento\" de c\u00f3digo. Cuando un conjunto de l\u00edneas de c\u00f3digo se repiten, es posible agruparlas bajo un nombre y utilizar ese nombre en lugar de repetir este c\u00f3digo. Ejemplo: #! /bin/bash function imprimir_tabla (){ echo \u201cTabla del n\u00famero $1 \u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res = $1 *i echo \u201c $i x $1 = $res \u201d done } read -p \u201cEscribe un n\u00famero: \u201c num imprimir_tabla $num imprimir_tabla 5 En este ejemplo se ha construido una funci\u00f3n para imprimir la tabla de multiplicar de un n\u00famero pasado como par\u00e1metro. En la siguiente l\u00ednea le pedimos al programa que imprima la tabla del n\u00famero cinco. No se ha necesitado escribir el c\u00f3digo que imprime la su tabla de multiplicar de nuevo, ya que con invocar el nombre de la funci\u00f3n el programa ya sabe que c\u00f3digo debe ejecutar. Warning N\u00f3tese que el valor de $1 no se pasa como par\u00e1metro del shell script, si no como par\u00e1metro a la funci\u00f3n imprimir_tabla tras haberlo preguntado al usuario. Hay que tener en cuenta que las variables que se declaran dentro de una funci\u00f3n existen \u00fanicamente dentro de ella. Si es preciso utilizar una variable fuera de una funci\u00f3n se puede usar return , que devuelve un valor fuera de ella, o usar la palabra reservada GLOBAL Es preferible utilizar el primer m\u00e9todo para que devuelva un valor que ser\u00e1 recogido en otra variable fuera de la funci\u00f3n que lo origin\u00f3.","title":"Funciones en shell script"},{"location":"01_ShellScripting/014_ShellScript_VectoresFunciones.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script utilizando funciones que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un script que rellene un vector con cien valores aleatorios y muestre en pantalla en una sola l\u00ednea los valores generados. Genera un script que rellene un vector con diez n\u00fameros pedidos al usuario y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores los valores ordenados de menor a mayor en una sola l\u00ednea los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores cantidad de valores pares que contiene el vector la suma total de n\u00fameros impares la media aritm\u00e9tica de los valores que contiene el vector Crea un script que muestre las opciones del ejercicio anterior con select. El usuario introducir\u00e1 los valores del vector al iniciar el script. Cuando termine aparecer\u00e1 el men\u00fa de selecci\u00f3n (deber\u00e1s a\u00f1adir la opci\u00f3n para salir del script). Adem\u00e1s deber\u00e1s crear una funci\u00f3n para cada opci\u00f3n del men\u00fa y llamarla en cada una de las opciones del select.","title":"Actividades"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html","text":"Refuerzo y Ampliaci\u00f3n \u00b6 En esta sesi\u00f3n se trabajan actividades para reforzar los contenidos estudiados en esta unidad, y actividades de ampliaci\u00f3n para profundizar en dichos contenidos. Actividades \u00b6 Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Refuerzo \u00b6 Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Modifica el shell script realizado en el ejercicio anterior para comprobar si el fichero existe. Si el fichero no existe, debe mostrar un mensaje de error y salir. Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Genera un script que muestre la tabla de multiplicar de un n\u00famero introducido por pantalla por el usuario. Ampliaci\u00f3n \u00b6 Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2). Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un shell script que funcione de manera similar a la papelera de reciclaje. El manejo de los ficheros se debe realizar a trav\u00e9s de vectores. El programa debe mostrar el siguiente men\u00fa e implementar sus operaciones que ser\u00e1n implementadas a trav\u00e9s de funciones: eliminar archivo . Esta operaci\u00f3n recibe la ruta completa de un archivo y lo mueve al directorio /home/tu_usuario/recycled. Si no existe dicho directorio, el programa ha de crearlo. restaurar archivo . Esta operaci\u00f3n recibe el nombre de un archivo y lo mueve, desde la papelera de reciclaje, al directorio en el que estuviera anteriormente. El proceso de eliminaci\u00f3n, debe haber almacenado, por tanto dicho directorio en un fichero de texto. restaurar toda la papelera. Esta operaci\u00f3n es similar a la anterior, pero se efect\u00faa sobre todos los ficheros de la papelera. vaciar la papelera . Esta opci\u00f3n vac\u00eda el contenido de la papelera. Ninguno de los archivos ser\u00e1 recuperable. mostrar la papelera . Esta opci\u00f3n muestra el contenido de la papelera. salir . Sale del programa.","title":"1.5- Refuerzo y ampliaci\u00f3n"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#refuerzo-y-ampliacion","text":"En esta sesi\u00f3n se trabajan actividades para reforzar los contenidos estudiados en esta unidad, y actividades de ampliaci\u00f3n para profundizar en dichos contenidos.","title":"Refuerzo y Ampliaci\u00f3n"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#actividades","text":"Note Escribe el c\u00f3digo de los scripts en ShellScript que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#refuerzo","text":"Realiza un shell script que admita un \u00fanico par\u00e1metro correspondiente al nombre de un fichero de texto. Mostrar\u00e1 por pantalla el n\u00famero de l\u00edneas del mismo utilizando el comando wc . Modifica el shell script realizado en el ejercicio anterior para comprobar si el fichero existe. Si el fichero no existe, debe mostrar un mensaje de error y salir. Construye los siguientes dos shell script utilizando estructuras iterativas: el primero ej108A.sh , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej108B.sh , que muestre las 10 primeras tablas de multiplicar por pantalla. Existir\u00e1 un tiempo de espera de dos segundos entre tabla (usa el comando sleep para ello). Genera un script que muestre la tabla de multiplicar de un n\u00famero introducido por pantalla por el usuario.","title":"Refuerzo"},{"location":"01_ShellScripting/015_ShellScript_RefuerzoAmpliacion.html#ampliacion","text":"Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2). Realiza un script que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: El informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libe o no (usa el comando ping). En el informe debe aparecer el tipo de red (rango CIDR) en el que est\u00e1 inmerso el ordenador con el nombre de la red , su broadcast y su m\u00e1scara de subred . Esta informaci\u00f3n la pod\u00e9is obtener desde el comando ifconfig. Note Para facilitar los c\u00e1lculos asumimos que el equipo donde se ejecuta el script se encuentra en una \u00fanica red, es decir, solo posee una tarjeta de red. Crea un shell script que funcione de manera similar a la papelera de reciclaje. El manejo de los ficheros se debe realizar a trav\u00e9s de vectores. El programa debe mostrar el siguiente men\u00fa e implementar sus operaciones que ser\u00e1n implementadas a trav\u00e9s de funciones: eliminar archivo . Esta operaci\u00f3n recibe la ruta completa de un archivo y lo mueve al directorio /home/tu_usuario/recycled. Si no existe dicho directorio, el programa ha de crearlo. restaurar archivo . Esta operaci\u00f3n recibe el nombre de un archivo y lo mueve, desde la papelera de reciclaje, al directorio en el que estuviera anteriormente. El proceso de eliminaci\u00f3n, debe haber almacenado, por tanto dicho directorio en un fichero de texto. restaurar toda la papelera. Esta operaci\u00f3n es similar a la anterior, pero se efect\u00faa sobre todos los ficheros de la papelera. vaciar la papelera . Esta opci\u00f3n vac\u00eda el contenido de la papelera. Ninguno de los archivos ser\u00e1 recuperable. mostrar la papelera . Esta opci\u00f3n muestra el contenido de la papelera. salir . Sale del programa.","title":"Ampliaci\u00f3n"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html","text":"Prueba Espec\u00edfica \u00b6 Esta prueba consta de dos partes: Una primera parte con preguntas tipo test , con car\u00e1cter te\u00f3rico, con un peso del 40% en el total de la prueba. La segunda parte consta de ejercicios pr\u00e1cticos basados en los realizados durante la Unidad Did\u00e1ctica, con un valor del 60% del total. Test: \u00b6 En shell Script para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada y salida de datos, en este sentido se utilizan los siguientes comandos: listen/echo listen/write read/echo read/write \u00bfQu\u00e9 es un Script? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando echo... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. Una Tuber\u00eda ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. Los scripts de Shell son uno de los tipos de programas m\u00e1s habituales en todos los sistemas LINUX/GNU. #!/bin/bash en la primera l\u00ednea del shell script indica: Cambia el directorio a /bin/bash. Indica que se debe usar la shell bash para ejecutar el script. Ejecuta el comando /bin/bash y presenta el resultado en pantalla. Es un comentario que no indica nada. \u00bfQu\u00e9 es una variable? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. Una Redirecci\u00f3n ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. \u00bfQu\u00e9 es un Argumento o par\u00e1metro? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando read... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. El comando expr... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$resultado\" \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar del n\u00famero introducido por el usuario. Muestra por pantalla la tabla de multiplicar de la variable num. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash read -p \u201cEscribe un n\u00famero : \u201c num i=1 while [ $i -le 10 ] do let res=num*i echo \u201c$i x $num = $res\u201d let i=i+1 done Diagramas de Flujo ... Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\" + \"$num2\" Diagramas de Flujo ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa Estructuras condicionales ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar el par\u00e1metro 1 introducido al ejecutar el script. Muestra por pantalla la tabla de multiplicar del argumento $1. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash echo \u201cTabla del n\u00famero $1\u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res=$1*i echo \u201c$i x $1 = $res\u201d done \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1+$num2\" Estructuras iterativas ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\"\"$num2\" Pr\u00e1ctica \u00b6 Escribe un shell script que pida al usuario tres n\u00fameros y los muestre ordenados de mayor a menor. Realiza un shell script que a partir de una fecha introducida por teclado con el formato D\u00cdA, MES, A\u00d1O, se obtenga la fecha del d\u00eda siguiente. Crea un shell script que acepte una calificaci\u00f3n num\u00e9rica y visualice la correspondiente en letra, seg\u00fan la figura adjunta. Se deber\u00e1 comprobar que los datos introducidos por el usuario son v\u00e1lidos. Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2) .","title":"1.6- Prueba Auditoria"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html#prueba-especifica","text":"Esta prueba consta de dos partes: Una primera parte con preguntas tipo test , con car\u00e1cter te\u00f3rico, con un peso del 40% en el total de la prueba. La segunda parte consta de ejercicios pr\u00e1cticos basados en los realizados durante la Unidad Did\u00e1ctica, con un valor del 60% del total.","title":"Prueba Espec\u00edfica"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html#test","text":"En shell Script para poder interactuar con un programa de terminal es necesario disponer de un mecanismo de entrada y salida de datos, en este sentido se utilizan los siguientes comandos: listen/echo listen/write read/echo read/write \u00bfQu\u00e9 es un Script? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando echo... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. Una Tuber\u00eda ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. Los scripts de Shell son uno de los tipos de programas m\u00e1s habituales en todos los sistemas LINUX/GNU. #!/bin/bash en la primera l\u00ednea del shell script indica: Cambia el directorio a /bin/bash. Indica que se debe usar la shell bash para ejecutar el script. Ejecuta el comando /bin/bash y presenta el resultado en pantalla. Es un comentario que no indica nada. \u00bfQu\u00e9 es una variable? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. Una Redirecci\u00f3n ... Una Redirecci\u00f3n consiste en trasladar la informaci\u00f3n de un fichero de dispositivo a otro. Es la forma pr\u00e1ctica de redireccionar la salida est\u00e1ndar de un programa hacia la entrada est\u00e1ndar de otro. Es un comando que se ejecuta desde un terminal que permite configurar v\u00ednculos entre varios comandos. Ninguna de las anteriores. \u00bfQu\u00e9 es un Argumento o par\u00e1metro? Es un archivo de texto que contiene una serie de comandos que, ordenados de forma espec\u00edfica, realizan la tarea para la que fueron dise\u00f1ados. Conjunto de especificaciones que se le hacen al programa al momento de llamarlo para obtener un efecto diferente. Es un par\u00e1metro que cambia su valor durante la ejecuci\u00f3n del programa. Ninguna de las anteriores. El comando read... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. El comando expr... Su tarea es la de mostrar informaci\u00f3n con mensajes de texto lanzados por pantalla. Esta herramienta asigna el texto que el usuario ha escrito en el terminal y a una o m\u00e1s variables. Este comando toma los argumentos dados como expresiones num\u00e9ricas, los eval\u00faa e imprime el resultado. Ninguna de las anteriores. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$resultado\" \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar del n\u00famero introducido por el usuario. Muestra por pantalla la tabla de multiplicar de la variable num. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash read -p \u201cEscribe un n\u00famero : \u201c num i=1 while [ $i -le 10 ] do let res=num*i echo \u201c$i x $num = $res\u201d let i=i+1 done Diagramas de Flujo ... Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\" + \"$num2\" Diagramas de Flujo ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa Estructuras condicionales ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla la tabla de multiplicar el par\u00e1metro 1 introducido al ejecutar el script. Muestra por pantalla la tabla de multiplicar del argumento $1. Muestra por pantalla la tabla de multiplicar de la variable i. a y b son verdaderas. #! /bin/bash echo \u201cTabla del n\u00famero $1\u201d for i in 1 2 3 4 5 6 7 8 9 10 do let res=$1*i echo \u201c$i x $1 = $res\u201d done \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1+$num2\" Estructuras iterativas ... Es la representaci\u00f3n gr\u00e1fica de la soluci\u00f3n algor\u00edtmica de un problema. Permiten ejecutar diferentes instrucciones dependiendo del valor de una variable o expresi\u00f3n. Son operaciones que se deben ejecutar un n\u00famero repetido de veces para resolver un problema. Es determinar el orden en el que se ejecutar\u00e1n las instrucciones en un programa. \u00bfQu\u00e9 hace el siguiente script adjunto? Muestra por pantalla 10 Muestra por pantalla 7+3 Muestra por pantalla 73 Ninguna de las anteriores. #! /bin/bash num1=7 num2=3 let resultado=num1+num2 echo \"$num1\"\"$num2\"","title":"Test:"},{"location":"01_ShellScripting/016_ShellScript_PruebaEspecifica.html#practica","text":"Escribe un shell script que pida al usuario tres n\u00fameros y los muestre ordenados de mayor a menor. Realiza un shell script que a partir de una fecha introducida por teclado con el formato D\u00cdA, MES, A\u00d1O, se obtenga la fecha del d\u00eda siguiente. Crea un shell script que acepte una calificaci\u00f3n num\u00e9rica y visualice la correspondiente en letra, seg\u00fan la figura adjunta. Se deber\u00e1 comprobar que los datos introducidos por el usuario son v\u00e1lidos. Escribe un shell script que genere dos vectores de quince elementos cada uno y los rellene con n\u00famero aleatorios comprendidos entre 0 y 100. Despu\u00e9s sume esas dos estructuras y muestre los tres vectores por pantalla. Para ello crea las funciones imprimir_array(array_a_imprimir) y sumar_array(array1, array2) .","title":"Pr\u00e1ctica"},{"location":"01_ShellScripting/ProgramacionAula.html","text":"Programaci\u00f3n de Aula \u00b6 Resultados de Aprendizaje \u00b6 Esta unidad cubre parte del Resultado de aprendizaje 1 (RA1) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Planificaci\u00f3n Temporal \u00b6 Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 13/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Comentarios, Depuraci\u00f3n. Introducci\u00f3n ShellScripting 2 14/09/22 Sintaxis, Argumentos, Variables, Interacci\u00f3n con el usuario, Operadores, re-direcciones y tuber\u00edas. Sintaxis ShellScripting 3 15/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 20/09/22 Vectores y funciones Vectores y Funciones. 5 22/09/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n. 6 19/09/22 Prueba Espec\u00edfica Prueba Espec\u00edfica.","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/ProgramacionAula.html#programacion-de-aula","text":"","title":"Programaci\u00f3n de Aula"},{"location":"01_ShellScripting/ProgramacionAula.html#resultados-de-aprendizaje","text":"Esta unidad cubre parte del Resultado de aprendizaje 1 (RA1) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; }","title":"Resultados de Aprendizaje"},{"location":"01_ShellScripting/ProgramacionAula.html#planificacion-temporal","text":"Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 13/09/22 Introducci\u00f3n ShellScripting, Creaci\u00f3n ShellScript, Comentarios, Depuraci\u00f3n. Introducci\u00f3n ShellScripting 2 14/09/22 Sintaxis, Argumentos, Variables, Interacci\u00f3n con el usuario, Operadores, re-direcciones y tuber\u00edas. Sintaxis ShellScripting 3 15/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 20/09/22 Vectores y funciones Vectores y Funciones. 5 22/09/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n. 6 19/09/22 Prueba Espec\u00edfica Prueba Espec\u00edfica.","title":"Planificaci\u00f3n Temporal"},{"location":"01_ShellScripting/ResumenUD.html","text":"Resumen UD \u00b6 A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. IC1. Actividades DESARROLLO (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 108 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 109 a la 111 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 112 a la 115 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 116 a la 119 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. IC1. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 120 a la 122 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Prueba de Auditor\u00eda. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Cuestionario multi-opci\u00f3n (test) de 20 preguntas sobre la teor\u00eda de la unidad. Ejercicios pr\u00e1cticos sobre las actividades realizadas de la unidad. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1 e IC2.","title":"Resumen UD"},{"location":"01_ShellScripting/ResumenUD.html#resumen-ud","text":"A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. IC1. Actividades DESARROLLO (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 108 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 109 a la 111 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 112 a la 115 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 116 a la 119 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. IC1. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 120 a la 122 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Prueba de Auditor\u00eda. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Cuestionario multi-opci\u00f3n (test) de 20 preguntas sobre la teor\u00eda de la unidad. Ejercicios pr\u00e1cticos sobre las actividades realizadas de la unidad. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1 e IC2.","title":"Resumen UD"},{"location":"02_PowerShell/012_PowerShellTotal.html","text":"Power Shell \u00b6 Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas propietarios . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados. Introducci\u00f3n \u00b6 Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de autocompletado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsar la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un gui\u00f3n y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas. Primer Script \u00b6 Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./Script.ps1 Aunque tambi\u00e9n es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro . PowerShell ISE \u00b6 PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE. Comentarios \u00b6 Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multil\u00ednea. Par\u00e1metros en PowerShell \u00b6 Como ocurr\u00eda en GNU/Linux, los par\u00e1metros que reciba el script se deben recoger de forma interna en una variable para poder operar con ellos. Example param ([string]$nombre) Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"Hola de nuevo, tu nombre es $nombre\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable nombre. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./Script.ps1 \u201cF\u00ba Javier Hern\u00e1ndez Ill\u00e1n\u201d Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables . Variables \u00b6 Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable. Implicita \u00b6 Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9.99 $Final_2021 = 30 ${Mi variable} = \u201cContiene espacios en el nombre\u201d En la forma implicita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $feo.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable . Explicita \u00b6 Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [ float ] $numero = 9.99 [int] $Final_2021 = 30 [string] ${Mi variable} = \u201cContiene espacios en el nombre\u201d Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: que las caracter\u00edsticas del dato se modifiquen para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, o que se producir\u00e1 un error si esa conversi\u00f3n no es posible y se detenga el script. Interacci\u00f3n con el usuario \u00b6 PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [ string ] $feo = Read-Host \u201c\u00bfCu\u00e1l es el nombre del marine de Doom?\u201d Write-Host \u201cNo se sabe, pero lo has intentado con $feo\u201d Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript. Operadores \u00b6 Aritm\u00e9ticos \u00b6 Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [ int ] $a=10 [float] $b=20 [int] $res=$a+$b Write-Host $res Write-Host $a+$b Write-Host \"$a x $b = \" ($a*$b) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores. L\u00f3gicos \u00b6 Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host ((6 -ge 4) -and (7 -le 7)) Write-Host ((10 -gt 1) -or (2 -lt 2)) Write-Host ((1 -gt 0) -xor (4 -le 1)) Write-Host ( -not (12 -lt 10)) Write-Host (!(12 -lt 10)) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \u201cJavi\u201d -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \u201cJavi\u201d -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int]) Comparaci\u00f3n \u00b6 los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \u201cJavi\u201d -ieq \u201cjavi\u201d es verdadero -ceq Iguales. En cadenas es casesensitive. \u201cJavi\u201d -ceq \u201cjavi\u201d es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \u201ces como\u201d. \u201cPerro\u201d -like \u201cPe*\u201d es verdadero -notlike Eval\u00faa un patr\u00f3n \u201cno es como\u201d. \u201cPerro\u201d -notlike \u201cPe*\u201d es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso Control del flujo en PowerShell \u00b6 En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript. Alternativa Simple \u00b6 if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } Alternativa doble \u00b6 if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa } Alternativa m\u00faltiple \u00b6 if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas } El equivalente a case en GNU/Linux \u00b6 switch ($valor){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ($saludo){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } {$_ -is [string]} { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ($target){ '^ftp\\://.*$' { \"$_ is an ftp address\"; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\"; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $($matches[1])\"; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe u n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil : $_\"; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones. Estructuras iterativas \u00b6 while \u00b6 A diferencia de lo que ocurr\u00eda en GNU/Linux, en PowerShell existen diferencias entre las estructuras while, do while y do until . En este caso, la \u00fanica de las tres que evaluar\u00e1 la condici\u00f3n al inicio del bloque de c\u00f3digo ser\u00e1 la primera. El resto comprueba la condici\u00f3n al final del bloque ejecutando como m\u00ednimo una vez el c\u00f3digo que contiene. while ( condici\u00f3n ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } do { bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } while ( condici\u00f3n ) Existe una variante de esta estructura que se crea sustituyendo el while por un until . Esto cambia el sentido de la condici\u00f3n y es este caso el bloque se repite hasta que la condici\u00f3n se cumpla. Esta estructura no es muy utilizada, pero siempre es bueno contar con herramientas extra. for \u00b6 Tambi\u00e9n la estructura for es sensiblemente diferente que en shellscript. Esta estructura en PowerShell tiene m\u00e1s que ver con los lenguajes de programaci\u00f3n y se utiliza cuando el programador sabe el n\u00famero de iteraciones que hay que realizar para solucionar un problema. for ( inicializaci\u00f3n; condici\u00f3n; incremento ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } Por ejemplo, la creaci\u00f3n de la tabla de multiplicar de un n\u00famero especificado por el usuario. Para resolver este problema s\u00ed se conoce el n\u00famero de iteraciones necesarias, concretamente diez. Example $numero = Read-Host \"Dame un n\u00famero\" Write-Host \"Esta es la tabla del $num\" for ( $i=0; $i -lt 11; $i++){ Write-Host \" $i x $numero = \"($i*$numero) } foreach \u00b6 La estructura foreach en PowerShell es el equivalente a for en shellscript. Est\u00e1 pensada para recorrer un conjunto de valores y ejecutar el bloque de c\u00f3digo una vez por cada elemento del conjunto. foreach ( elemento in conjunto ){ bloque de c\u00f3digo a ejecutar por cada elemento del conjunto } Al igual que ocurre en GNU/Linux, el conjunto puede serlo de cualquier tipo de objetos, incluso los ficheros de una carpeta. En el siguiente ejemplo se buscan los ficheros que en su nombre contengan la cadena de texto que el usuario ha especificado: Example $ruta = \"C:\\Users\\Administrador\\Desktop\" $busca = Read-Host \"Escribe el texto a buscar\" foreach ($archivo in Get-ChildItem $ruta){ if ($archivo.Name.IndexOf($busca) -ge 0){ Write-Host $archivo.Name } } Note Las opciones que ofrece PowerShell en cuanto a estructuras de control parece una oferta m\u00e1s completa que la de shellscript, aunque para las tareas que se van a realizar en este m\u00f3dulo, ambos sistemas poseen herramientas suficientes. Vectores \u00b6 PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1,2,3,4,5 $Texto = \u201cLunes\u201d,\u201cMartes\u201d,\u201dMi\u00e9rcoles\u201d, \u201cJueves\u201d,\u201dViernes\u201d $EnterosRango = 1..10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @(For($i;$i < 5;$i++){$i}) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1,2,3,4,5 -Force New-Variable -Name Texto -Value \"Lunes\",\"Martes\",\"Mi\u00e9rcoles\",\"Jueves\",\"Viernes\" \u2013Force New-Variable -Name EnterosRango -Value (1..5) -Force New-Variable -Name EnterosFor -value (. {For($i=1;$i -lt 5;$i++){$i}}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto.Length # mostrar\u00e1 5 por pantalla $Texto[2].Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201cS\u00e1bado\u201d, \u201cDomingo\u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados. Funciones \u00b6 Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function <NOMBRE> { Param (<Parametro>,<Parametro>,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ([integer] $a, [integer] $b) $sumar = $a + $b Write-Host \u201cLa suma es $sumar\u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script. Actividades PowerShell \u00b6 Note Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Actividades Iniciales PowerShell \u00b6 Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script. Crea un script que si no se le pasa ning\u00fan argumento nos lo diga. Actividades de desarrollo UD1_04 \u00b6 Dise\u00f1a un script PowerShell que pida al usuario dos n\u00famero (comprobando que sean n\u00fameros) y muestre por pantalla el mayor de ellos o si son iguales. Crea un script PowerShell que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Usa el cmdlet Get-Date . Construye tres script PowerShell utilizando estructuras iterativas: el primero ej118A.ps1 , que imprima la tabla de multiplicar de un n\u00famero preguntado al usuario. Este n\u00famero debe ser entero positivo. el segundo ej118B.ps1 , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej118C.ps1 , que muestre las diez primeras tablas de multiplicar por pantalla. Hay un tiempo de espera de un segundo entre ellas. Utiliza las estructuras while, do while, for y foreach y el cmdlet Start-Sleep. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random. Actividades de desarrollo UD1_05 \u00b6 Crea un script PowerShell que rellene un vector con diez n\u00fameros de forma aleatoria y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores. los valores ordenados de menor a mayor en una sola l\u00ednea. los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores. cantidad de valores pares que contiene el vector. la suma total de n\u00fameros impares. la media aritm\u00e9tica de los valores que contiene el vector. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. Dise\u00f1a un script PowerShell que muestre un men\u00fa al usuario con cuatro operaciones disponibles: Crear directorio, Eliminar directorio, Mostrar directorio, Informe de directorio, Copia de directorio y Salir . Una vez elegida una opci\u00f3n correcta, el programa debe solicitar un nombre de directorio y hacer la operaci\u00f3n seleccionada. Tras esto debe mostrar un mensaje con el resultado de la operaci\u00f3n. Crea una funci\u00f3n para cada una de estas opciones. Si se elige la opci\u00f3n Informe de directorio , mostrar\u00e1 por pantalla el n\u00famero de ficheros que contiene, cuantos son carpetas, cuantos directorios y el tama\u00f1o total de ellos. Si la carpeta no existe, mostrar\u00e1 un error. Si elige la opci\u00f3n Copia de directorio , preguntar\u00e1 la carpeta de destino y mostrar\u00e1 fichero a fichero la copia. Realiza un script PowerShell que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: el informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libre o no (usa el comando ping). en el informe debe aparecer el tipo de red (A, B o C) en el que est\u00e1 inmerso el ordenador con el nombre de la red, su broadcast y su m\u00e1scara de subred.","title":"Power Shell"},{"location":"02_PowerShell/012_PowerShellTotal.html#power-shell","text":"Duraci\u00f3n y criterios de evaluaci\u00f3n Duraci\u00f3n estimada: 3 sesiones (2h por sesi\u00f3n) Resultado de aprendizaje y Criterios de evaluaci\u00f3n: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. Se han interpretado guiones de configuraci\u00f3n del sistema operativo. Se han realizado cambios y adaptaciones de guiones del sistema. Se han creado y probado guiones de administraci\u00f3n de servicios. Se han creado y probado guiones de automatizaci\u00f3n de tareas. Se han implantado guiones en sistemas propietarios . Se han consultado y utilizado librer\u00edas de funciones. Se han documentado los guiones creados.","title":"Power Shell"},{"location":"02_PowerShell/012_PowerShellTotal.html#introduccion","text":"Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de autocompletado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsar la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un gui\u00f3n y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas.","title":"Introducci\u00f3n"},{"location":"02_PowerShell/012_PowerShellTotal.html#primer-script","text":"Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./Script.ps1 Aunque tambi\u00e9n es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro .","title":"Primer Script"},{"location":"02_PowerShell/012_PowerShellTotal.html#powershell-ise","text":"PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE.","title":"PowerShell ISE"},{"location":"02_PowerShell/012_PowerShellTotal.html#comentarios","text":"Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multil\u00ednea.","title":"Comentarios"},{"location":"02_PowerShell/012_PowerShellTotal.html#parametros-en-powershell","text":"Como ocurr\u00eda en GNU/Linux, los par\u00e1metros que reciba el script se deben recoger de forma interna en una variable para poder operar con ellos. Example param ([string]$nombre) Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"Hola de nuevo, tu nombre es $nombre\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable nombre. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./Script.ps1 \u201cF\u00ba Javier Hern\u00e1ndez Ill\u00e1n\u201d Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables .","title":"Par\u00e1metros en PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#variables","text":"Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable.","title":"Variables"},{"location":"02_PowerShell/012_PowerShellTotal.html#implicita","text":"Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9.99 $Final_2021 = 30 ${Mi variable} = \u201cContiene espacios en el nombre\u201d En la forma implicita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $feo.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable .","title":"Implicita"},{"location":"02_PowerShell/012_PowerShellTotal.html#explicita","text":"Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [ float ] $numero = 9.99 [int] $Final_2021 = 30 [string] ${Mi variable} = \u201cContiene espacios en el nombre\u201d Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: que las caracter\u00edsticas del dato se modifiquen para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, o que se producir\u00e1 un error si esa conversi\u00f3n no es posible y se detenga el script.","title":"Explicita"},{"location":"02_PowerShell/012_PowerShellTotal.html#interaccion-con-el-usuario","text":"PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [ string ] $feo = Read-Host \u201c\u00bfCu\u00e1l es el nombre del marine de Doom?\u201d Write-Host \u201cNo se sabe, pero lo has intentado con $feo\u201d Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript.","title":"Interacci\u00f3n con el usuario"},{"location":"02_PowerShell/012_PowerShellTotal.html#operadores","text":"","title":"Operadores"},{"location":"02_PowerShell/012_PowerShellTotal.html#aritmeticos","text":"Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [ int ] $a=10 [float] $b=20 [int] $res=$a+$b Write-Host $res Write-Host $a+$b Write-Host \"$a x $b = \" ($a*$b) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores.","title":"Aritm\u00e9ticos"},{"location":"02_PowerShell/012_PowerShellTotal.html#logicos","text":"Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host ((6 -ge 4) -and (7 -le 7)) Write-Host ((10 -gt 1) -or (2 -lt 2)) Write-Host ((1 -gt 0) -xor (4 -le 1)) Write-Host ( -not (12 -lt 10)) Write-Host (!(12 -lt 10)) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \u201cJavi\u201d -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \u201cJavi\u201d -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int])","title":"L\u00f3gicos"},{"location":"02_PowerShell/012_PowerShellTotal.html#comparacion","text":"los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \u201cJavi\u201d -ieq \u201cjavi\u201d es verdadero -ceq Iguales. En cadenas es casesensitive. \u201cJavi\u201d -ceq \u201cjavi\u201d es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \u201ces como\u201d. \u201cPerro\u201d -like \u201cPe*\u201d es verdadero -notlike Eval\u00faa un patr\u00f3n \u201cno es como\u201d. \u201cPerro\u201d -notlike \u201cPe*\u201d es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso","title":"Comparaci\u00f3n"},{"location":"02_PowerShell/012_PowerShellTotal.html#control-del-flujo-en-powershell","text":"En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript.","title":"Control del flujo en PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#alternativa-simple","text":"if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera }","title":"Alternativa Simple"},{"location":"02_PowerShell/012_PowerShellTotal.html#alternativa-doble","text":"if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa }","title":"Alternativa doble"},{"location":"02_PowerShell/012_PowerShellTotal.html#alternativa-multiple","text":"if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas }","title":"Alternativa m\u00faltiple"},{"location":"02_PowerShell/012_PowerShellTotal.html#el-equivalente-a-case-en-gnulinux","text":"switch ($valor){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ($saludo){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } {$_ -is [string]} { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ($target){ '^ftp\\://.*$' { \"$_ is an ftp address\"; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\"; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $($matches[1])\"; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe u n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo : $_\"; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil : $_\"; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones.","title":"El equivalente a case en GNU/Linux"},{"location":"02_PowerShell/012_PowerShellTotal.html#estructuras-iterativas","text":"","title":"Estructuras iterativas"},{"location":"02_PowerShell/012_PowerShellTotal.html#vectores","text":"PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1,2,3,4,5 $Texto = \u201cLunes\u201d,\u201cMartes\u201d,\u201dMi\u00e9rcoles\u201d, \u201cJueves\u201d,\u201dViernes\u201d $EnterosRango = 1..10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @(For($i;$i < 5;$i++){$i}) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1,2,3,4,5 -Force New-Variable -Name Texto -Value \"Lunes\",\"Martes\",\"Mi\u00e9rcoles\",\"Jueves\",\"Viernes\" \u2013Force New-Variable -Name EnterosRango -Value (1..5) -Force New-Variable -Name EnterosFor -value (. {For($i=1;$i -lt 5;$i++){$i}}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto.Length # mostrar\u00e1 5 por pantalla $Texto[2].Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201cS\u00e1bado\u201d, \u201cDomingo\u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados.","title":"Vectores"},{"location":"02_PowerShell/012_PowerShellTotal.html#funciones","text":"Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function <NOMBRE> { Param (<Parametro>,<Parametro>,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ([integer] $a, [integer] $b) $sumar = $a + $b Write-Host \u201cLa suma es $sumar\u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script.","title":"Funciones"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-powershell","text":"Note Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle.","title":"Actividades PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-iniciales-powershell","text":"Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script. Crea un script que si no se le pasa ning\u00fan argumento nos lo diga.","title":"Actividades Iniciales PowerShell"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-de-desarrollo-ud1_04","text":"Dise\u00f1a un script PowerShell que pida al usuario dos n\u00famero (comprobando que sean n\u00fameros) y muestre por pantalla el mayor de ellos o si son iguales. Crea un script PowerShell que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Usa el cmdlet Get-Date . Construye tres script PowerShell utilizando estructuras iterativas: el primero ej118A.ps1 , que imprima la tabla de multiplicar de un n\u00famero preguntado al usuario. Este n\u00famero debe ser entero positivo. el segundo ej118B.ps1 , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej118C.ps1 , que muestre las diez primeras tablas de multiplicar por pantalla. Hay un tiempo de espera de un segundo entre ellas. Utiliza las estructuras while, do while, for y foreach y el cmdlet Start-Sleep. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random.","title":"Actividades de desarrollo UD1_04"},{"location":"02_PowerShell/012_PowerShellTotal.html#actividades-de-desarrollo-ud1_05","text":"Crea un script PowerShell que rellene un vector con diez n\u00fameros de forma aleatoria y que los muestre por pantalla de la siguiente forma: en orden inverso a como han sido introducidos los valores. los valores ordenados de menor a mayor en una sola l\u00ednea. los valores ordenados de mayor a menor en una sola l\u00ednea la suma total de sus valores. cantidad de valores pares que contiene el vector. la suma total de n\u00fameros impares. la media aritm\u00e9tica de los valores que contiene el vector. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. Dise\u00f1a un script PowerShell que muestre un men\u00fa al usuario con cuatro operaciones disponibles: Crear directorio, Eliminar directorio, Mostrar directorio, Informe de directorio, Copia de directorio y Salir . Una vez elegida una opci\u00f3n correcta, el programa debe solicitar un nombre de directorio y hacer la operaci\u00f3n seleccionada. Tras esto debe mostrar un mensaje con el resultado de la operaci\u00f3n. Crea una funci\u00f3n para cada una de estas opciones. Si se elige la opci\u00f3n Informe de directorio , mostrar\u00e1 por pantalla el n\u00famero de ficheros que contiene, cuantos son carpetas, cuantos directorios y el tama\u00f1o total de ellos. Si la carpeta no existe, mostrar\u00e1 un error. Si elige la opci\u00f3n Copia de directorio , preguntar\u00e1 la carpeta de destino y mostrar\u00e1 fichero a fichero la copia. Realiza un script PowerShell que permita crear un informe de las IP libres en la red en la que se encuentra el equipo. Debe contener las siguientes opciones: el informe contendr\u00e1 un listado de todas las IP de la red a la que pertenece el equipo indicando si est\u00e1 libre o no (usa el comando ping). en el informe debe aparecer el tipo de red (A, B o C) en el que est\u00e1 inmerso el ordenador con el nombre de la red, su broadcast y su m\u00e1scara de subred.","title":"Actividades de desarrollo UD1_05"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html","text":"Power Shell \u00b6 Introducci\u00f3n \u00b6 Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de auto-completado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsa la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un guion y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas. Primer Script \u00b6 Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./ Script . ps1 PowerShell ISE \u00b6 PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE. Es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro . Comentarios \u00b6 Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multi-l\u00ednea. Depuraci\u00f3n \u00b6 La depuraci\u00f3n es el proceso de examinar un script mientras se ejecuta para identificar y corregir errores en las instrucciones del script. El depurador de PowerShell puede ayudarle a examinar e identificar errores e ineficiencias en los scripts, funciones, comandos, configuraciones o expresiones de PowerShell Desired State Configuration (DSC). El depurador de PowerShell incluye el siguiente conjunto de cmdlets: Set-PSBreakpoint : establece puntos de interrupci\u00f3n en l\u00edneas, variables y comandos. Get-PSBreakpoint : obtiene puntos de interrupci\u00f3n en la sesi\u00f3n actual. Disable-PSBreakpoint : desactiva los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Enable-PSBreakpoint : vuelve a habilitar los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Remove-PSBreakpoint : elimina puntos de interrupci\u00f3n de la sesi\u00f3n actual. Get-PSCallStack : muestra la pila de llamadas actual. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script.","title":"2.1- Introducci\u00f3n"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#power-shell","text":"","title":"Power Shell"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#introduccion","text":"Los sistemas operativos basados en Microsoft Windows cuentan con la herramienta PowerShell , que surgi\u00f3 ante las carencias que presenta el viejo terminal basado en MS-DOS . PowerShell es una interfaz de consola (CLI) con posibilidad de escritura y uni\u00f3n de comandos por medio de instrucciones (scripts). Esta interfaz de consola est\u00e1 dise\u00f1ada para su uso por parte de administradores de sistemas , con el prop\u00f3sito de automatizar tareas o realizarlas de forma m\u00e1s controlada. En abril de 2006 Microsoft lanz\u00f3 una nueva interfaz CLI, con una sintaxis moderna que comparte similitudes con el lenguaje Perl. Perl es un lenguaje de programaci\u00f3n dise\u00f1ado por Larry Wall en 1987. Perl toma caracter\u00edsticas del lenguaje C, del lenguaje interpretado bourne shell, AWK, sed, Lisp y, en un grado inferior, de muchos otros lenguajes de programaci\u00f3n. Se trata de una interfaz gratuita, y que antes de Microsoft Windows 7 no se inclu\u00eda con el sistema operativo. En la actualidad, est\u00e1 incluida en todos los sistemas operativos de Microsoft, aunque requiere la presencia de .NET framework del que hereda sus caracter\u00edsticas orientadas a objetos. En agosto de 2016, Microsoft public\u00f3 su c\u00f3digo en GitHub para que pueda portarse a otros sistemas como GNU/Linux y MAC OSX. Los comandos incluidas en PowerShell reciben el nombre de cmdlets (command-let) y posee conjuntos espec\u00edficos para trabajar con Active Directory, Exchange , entre otros roles de servidor. Info cmdlets Existen cientos de cdmlet en la versi\u00f3n 5.1 de PowerShell. Es posible consultar la ayuda de cada uno de ellos en la p\u00e1gina oficial de Microsoft. Otra ventaja de PowerShell es que se dispone de la mayor\u00eda de comandos que del CLI tradicional de Microsoft. De ese modo, es posible ejecutar el comando dir en lugar del Get-ChildItem , cmdlet que realiza la misma tarea. En realidad lo que est\u00e1 usando es un alias del segundo para lanzar el primero. Dispone de auto-completado de comandos y par\u00e1metros que facilitar\u00e1 las tareas de creaci\u00f3n de scripts. Basta con comenzar a escribir un cmdlet y pulsarla tecla Tab. Si utilizamos PowerShell ISE al escribir aparecer\u00e1 una ventana con todos los cmdlets que coincidan con el texto escrito, incluso puede aparecer un recuadro con ayuda sobre su sintaxis. Para aceptar la sugerencia se pulsa la tecla Intro . Note Los nombres de todos los cmdlets est\u00e1n formados por un verbo, un guion y un nombre en singular. Habitualmente, se escribe con may\u00fasculas la primera letra de cada palabra, pero no se trata m\u00e1s que de una norma de estilo, porque PowerShell no distingue entre may\u00fasculas y min\u00fasculas.","title":"Introducci\u00f3n"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#primer-script","text":"Al igual que ocurre en GNU/Linux un script de PowerShell no es m\u00e1s que un archivo de texto plano que contiene una secuencia de comando y de cmdlets para realizar una tarea. La diferencia con ellos es que aqu\u00ed ser\u00e1 necesario dotarlos de una extensi\u00f3n; ps1 . Example Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" A continuaci\u00f3n, se guarda el script desde el men\u00fa Acci\u00f3n \u2192 Guardar Como\u2026 asign\u00e1ndole un nombre. Para ejecutarlo tan s\u00f3lo es necesario escribir su nombre en el terminal de PowerShell anteponiendo un punto y una barra. Example ./ Script . ps1","title":"Primer Script"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#powershell-ise","text":"PowerShell viene acompa\u00f1ado de una herramienta gr\u00e1fica que facilita la administraci\u00f3n de todos los scripts. Se denomina Microsoft PowerShell ISE (Integrated Scripting Environment) , y se accede a trav\u00e9s de: Administrador del servidor \u2192 Herramientas \u2192 Windows PowerShell ISE . El uso de esta herramienta gr\u00e1fica va a facilitar la creaci\u00f3n de los scripts de forma significativa. Es pr\u00e1ctico comenzar con esta ayuda ya que la sintaxis de los cmdlets, aunque sea l\u00f3gica y sencilla, tambi\u00e9n lo es amplia y desconocida. Interfaz de la herramienta Windows PowerShell ISE Info Uno de los aspectos m\u00e1s interesantes que posee esta aplicaci\u00f3n es la barra de informaci\u00f3n que muestra un listado de todos los cmdlets de esta herramienta. Permite filtrarlos por funci\u00f3n y consultar la ayuda de cada uno de ellos. Tambi\u00e9n posee un formulario destinado a generar el c\u00f3digo de un cmdlet de forma autom\u00e1tica. Example Creaci\u00f3n de un comando que realice una copia de seguridad de los scripts de trabajo en una memoria externa. Es necesario el uso de Copy-Item para ello, pero no se conoce su sintaxis. Si escribimos este cmdlet en el recuadro Nombre y se pulsa sobre Mostrar Ayuda , aparecer\u00e1 un formulario con sus opciones. Tras completar las necesarias y pulsando el bot\u00f3n Insertar situado en la parte inferior, el c\u00f3digo completo ser\u00e1 escrito la parte destinada al terminal. Creaci\u00f3n autom\u00e1tica de scripts en Windows PowerShell ISE. Es posible ejecutar el script desde la herramienta gr\u00e1fica pulsando la tecla F5 , ejecutar una parte de \u00e9l con F8 o detener la ejecuci\u00f3n con Ctrl+Intro .","title":"PowerShell ISE"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#comentarios","text":"Note Los comentarios en PowerShell se realizan precediendo a la l\u00ednea con el car\u00e1cter # si se trata de una sola l\u00ednea y <# y #> si es multi-l\u00ednea.","title":"Comentarios"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#depuracion","text":"La depuraci\u00f3n es el proceso de examinar un script mientras se ejecuta para identificar y corregir errores en las instrucciones del script. El depurador de PowerShell puede ayudarle a examinar e identificar errores e ineficiencias en los scripts, funciones, comandos, configuraciones o expresiones de PowerShell Desired State Configuration (DSC). El depurador de PowerShell incluye el siguiente conjunto de cmdlets: Set-PSBreakpoint : establece puntos de interrupci\u00f3n en l\u00edneas, variables y comandos. Get-PSBreakpoint : obtiene puntos de interrupci\u00f3n en la sesi\u00f3n actual. Disable-PSBreakpoint : desactiva los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Enable-PSBreakpoint : vuelve a habilitar los puntos de interrupci\u00f3n en la sesi\u00f3n actual. Remove-PSBreakpoint : elimina puntos de interrupci\u00f3n de la sesi\u00f3n actual. Get-PSCallStack : muestra la pila de llamadas actual.","title":"Depuraci\u00f3n"},{"location":"02_PowerShell/021_Introduccio%CC%81nPwSh.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Genera un Script que muestre los procesos del sistema ordenados por el id . Muestra los servicios cuyo nombre empiece por la letra n , utilizando la creaci\u00f3n de un script.","title":"Actividades"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html","text":"Sintaxis \u00b6 Par\u00e1metros en PowerShell \u00b6 A diferencia de GNU/Linux, los par\u00e1metros que reciba el script en PowerShell se reciben en el array args , Cada posici\u00f3n del array args[] guarda los par\u00e1metros introducidos al script en el orden indicado. Por lo tanto para acceder a los par\u00e1metros introducidos se debe acceder al valor de la posici\u00f3n que se desee. Example [string] $param1 = $args [ 0 ] Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"El primer par\u00e1metro introducido es $param1\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable $param1. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./ Script . ps1 \"F\u00ba Javier Hern\u00e1ndez Ill\u00e1n\" Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables . Variables \u00b6 Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable. Impl\u00edcita \u00b6 Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9 . 99 $Final_2021 = 30 ${ Mi variable } = \"Contiene espacios en el nombre\" En la forma impl\u00edcita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $numero.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable . Explicita \u00b6 Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [float] $numero = 9 . 99 [int] $Final_2021 = 30 [string] ${ Mi variable } = \"Contiene espacios en el nombre\" Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: Se modifiquen las caracter\u00edsticas del dato para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, Se produzca un error si esa conversi\u00f3n no es posible y se detenga el script. Interacci\u00f3n con el usuario \u00b6 PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [string] $marine = Read-Host \"\u00bfCu\u00e1l es el nombre del marine de Doom?\" Write-Host \"No se sabe, pero lo has intentado con $marine Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript. Operadores \u00b6 Aritm\u00e9ticos \u00b6 Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [int] $a = 10 [float] $b = 20 [int] $res = $a + $b Write-Host $res Write-Host $a + $b Write-Host \"$a x $b = \" ( $a * $b ) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores. L\u00f3gicos \u00b6 Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host (( 6 -ge 4 ) -and ( 7 -le 7 )) Write-Host (( 10 -gt 1 ) -or ( 2 -lt 2 )) Write-Host (( 1 -gt 0 ) -xor ( 4 -le 1 )) Write-Host ( -not ( 12 -lt 10 )) Write-Host (!( 12 -lt 10 )) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \"Javi\" -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \"Javi\" -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int]) Comparaci\u00f3n \u00b6 los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \"Javi\" -ieq \"javi\" es verdadero -ceq Iguales. En cadenas es casesensitive. \"Javi\" -ceq \"javi\" es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \"es como\". \"Perro\" -like \"Pe*\" es verdadero -notlike Eval\u00faa un patr\u00f3n \"no es como\". \"Perro\" -notlike \"Pe*\" es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un script que se le introduzca dos n\u00fameros como argumentos y los muestre por pantalla. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b","title":"2.2- Sintaxis"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#sintaxis","text":"","title":"Sintaxis"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#parametros-en-powershell","text":"A diferencia de GNU/Linux, los par\u00e1metros que reciba el script en PowerShell se reciben en el array args , Cada posici\u00f3n del array args[] guarda los par\u00e1metros introducidos al script en el orden indicado. Por lo tanto para acceder a los par\u00e1metros introducidos se debe acceder al valor de la posici\u00f3n que se desee. Example [string] $param1 = $args [ 0 ] Write-Host \"Hola!. Esto es mi primer script en PowerShell\" Write-Host \"Y esto es una segunda l\u00ednea\" Write-Host \"El primer par\u00e1metro introducido es $param1\" Note El script anterior esperar\u00e1 un par\u00e1metro de tipo string que ser\u00e1 contenido en la variable $param1. En la cuarta l\u00ednea mostrar\u00e1 el contenido de la variable por pantalla. Para poder ejecutar este script, ser\u00e1 necesario acompa\u00f1arlo de un par\u00e1metro del siguiente modo. ./ Script . ps1 \"F\u00ba Javier Hern\u00e1ndez Ill\u00e1n\" Para entender por completo el ejemplo anterior, ser\u00e1 necesario ver como PowerShell maneja las variables .","title":"Par\u00e1metros en PowerShell"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#variables","text":"Para definir una variable en PowerShell s\u00f3lo tenemos que nombrarla utilizando para ello cualquier combinaci\u00f3n de caracteres, ya sean n\u00fameros, letras o s\u00edmbolos. Es posible utilizar espacios en el nombre, aunque en este caso el nombre debe ir rodeado por s\u00edmbolos de llaves {} . Al contrario que ocurre en shellscript, PowerShell es fuertemente tipado , lo que significa que las variables no son tratadas como cadenas de texto, sino que hay que especificar el tipo de dato que se guardar\u00e1 en ella. Para definir variables es posible utilizar el m\u00e9todo expl\u00edcito (adem\u00e1s con New-Variable y sus opciones), pero tambi\u00e9n se puede utilizar el m\u00e9todo impl\u00edcito anteponiendo el s\u00edmbolo $ delante del nombre. Info Get-Variable En cualquier momento puedes obtener una lista completa de las variables que se hayan definido hasta ese momento. Para lograrlo, basta con utilizar Get- Variable.","title":"Variables"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#implicita","text":"Tipo Descripci\u00f3n [string] Cadena de caracteres Unicode [char] Un s\u00f3lo car\u00e1cter Unicode de 16 bits [byte] Un s\u00f3lo car\u00e1cter Unicode de 8 bits [int] Entero con signo de 32 bits [float] N\u00famero con coma flotante de 32 bits [double] N\u00famero con coma flotante de 64 bits [datetime] Fecha y Hora [bool] Valor l\u00f3gico booleano Example $numero = 9 . 99 $Final_2021 = 30 ${ Mi variable } = \"Contiene espacios en el nombre\" En la forma impl\u00edcita el shell establece el tipo de dato de la variable en funci\u00f3n del dato que se le asigne en su creaci\u00f3n. En el ejemplo anterior $numero es de forma autom\u00e1tica de tipo [double] , ya que al crearla se ha inicializado con un n\u00famero con decimales. Por contra la variable $Final_2021 es de tipo [int] ya que se ha guardado un n\u00famero entero en ella. Info GetType Para poder obtener el tipo de dato de una variable hay que usar el m\u00e9todo GetType().Name sobre cualquier variable: Write-Host $numero.GetType().Name. Tip Una variable cuya definici\u00f3n de tipo se ha realizado de forma impl\u00edcita, podr\u00e1 cambiar el tipo de dato almacenado durante la ejecuci\u00f3n del programa sin experimentar ning\u00fan tipo de error. Esta pr\u00e1ctica aunque c\u00f3moda no es muy recomendable .","title":"Impl\u00edcita"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#explicita","text":"Es buena idea tomar el control del tipado de las variables y asignarlo en funci\u00f3n de las necesidades del programa. De esta forma se ahorrar\u00e1n futuras conversiones de datos y posibles p\u00e9rdidas de informaci\u00f3n. Para ello se usa la forma expl\u00edcita de crear variables y junto con su creaci\u00f3n se define el tipo de dato que va a contener. Example [float] $numero = 9 . 99 [int] $Final_2021 = 30 [string] ${ Mi variable } = \"Contiene espacios en el nombre\" Al contrario que en el caso anterior, cuando el dato asignado no coincida con el tipo esperado, pueden ocurrir dos cosas: Se modifiquen las caracter\u00edsticas del dato para amoldarse al tipo de variable, lo que puede traducirse en la p\u00e9rdida de datos y un mal funcionamiento del script, Se produzca un error si esa conversi\u00f3n no es posible y se detenga el script.","title":"Explicita"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#interaccion-con-el-usuario","text":"PowerShell posee dos cmdlets para realizar estas tareas. El primero de ellos es Write-Host y tiene un comportamiento similar al echo en GNU/Linux. El segundo comando para interactuar con el usuario es Read-Host el cual permite imprimir un mensaje por el terminal y recoger aquello que el usuario ha escrito. Funciona de forma muy parecida al comando read en el terminal de GNU/Linux. [string] $marine = Read-Host \"\u00bfCu\u00e1l es el nombre del marine de Doom?\" Write-Host \"No se sabe, pero lo has intentado con $marine Note Este script detendr\u00e1 su ejecuci\u00f3n en la l\u00ednea donde aparece Read-Host , esperar\u00e1 a que el usuario conteste a la pregunta y seguir\u00e1 con la ejecuci\u00f3n, del mismo modo que ocurre con shellscript.","title":"Interacci\u00f3n con el usuario"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#operadores","text":"","title":"Operadores"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#aritmeticos","text":"Las operaciones aritm\u00e9ticas en PowerShell son m\u00e1s intuitivas que en shellscript. Son las mismas que en el caso anterior: + , - , * , / y % . Su uso es m\u00e1s sencillo puesto que es el propio terminal en que realiza los c\u00e1lculos aritm\u00e9ticos y no a trav\u00e9s de un comando. [int] $a = 10 [float] $b = 20 [int] $res = $a + $b Write-Host $res Write-Host $a + $b Write-Host \"$a x $b = \" ( $a * $b ) Tambi\u00e9n se dispone de expansores de terminal como en GNU/Linux. Note N\u00f3tese que en la \u00faltima l\u00ednea aparece directamente el producto $a*$b ya que al rodear la operaci\u00f3n con par\u00e9ntesis, se convierte en un expansor, realiza la operaci\u00f3n en su interior y env\u00eda el resultado fuera. Existen variantes que simplifican el uso de algunos operadores. Operador Uso Equivalencia += $contador += 5 $contador = $contador+5 -= $contador -= 5 $contador = $contador-5 *= $contador *= 5 $contador = $contador*5 /= $contador /= 5 $contador = $contador/5 Adem\u00e1s de estos operadores existen dos espec\u00edficos para el incremento ( ++ ) y decremento ( -- ) de una unidad, ideal para el uso de variables como contadores.","title":"Aritm\u00e9ticos"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#logicos","text":"Operador Descripci\u00f3n -and Devuelve verdadero si las dos expresiones son verdaderas. -or Devuelve verdadero si una de las dos expresiones o las dos son verdaderas. -xor Devuelve verdadero si tan s\u00f3lo una de las expresiones es verdadera. -not o ! Devuelve verdadero cuando la expresi\u00f3n da el valor falso. Example Write-Host (( 6 -ge 4 ) -and ( 7 -le 7 )) Write-Host (( 10 -gt 1 ) -or ( 2 -lt 2 )) Write-Host (( 1 -gt 0 ) -xor ( 4 -le 1 )) Write-Host ( -not ( 12 -lt 10 )) Write-Host (!( 12 -lt 10 )) Note En el ejemplo anterior si se ejecuta el script en un terminal PowerShell, todos los resultados ser\u00e1n verdaderos. Como en todos los lenguajes de programaci\u00f3n fuertemente tipados, existen operadores l\u00f3gicos para comprobar el tipo de dato de una variable, que resultan muy \u00fatiles para la interacci\u00f3n con los usuarios. Operador Acci\u00f3n Ejemplo -is Devuelve verdadero si es del tipo indicado. \"Javi\" -is [string] es verdadero -isnot Devuelve falso si es del tipo indicado. \"Javi\" -isnot [string] es falso -as Convierte tipos de datos compatibles. $valor = 19.90 ; Write-Host ($valor -as [int])","title":"L\u00f3gicos"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#comparacion","text":"los operadores tipo l\u00f3gicos devuelven tan s\u00f3lo un valor booleano que puede tener dos valores; verdadero o falso . Operador Acci\u00f3n Ejemplo -eq Comprueba si son iguales. 5 -eq 3 es falso -ieq Iguales. En cadenas no es casesensitive. \"Javi\" -ieq \"javi\" es verdadero -ceq Iguales. En cadenas es casesensitive. \"Javi\" -ceq \"javi\" es falso -ne Verifica si son diferentes. 5 -ne 3 es verdadero -lt Coteja si la izquierda es menor que derecha. 5 -lt 3 es falso -le Constata si la izquierda es menor o igual que derecha. 5 -le 3 es falso -gt Examina si la izquierda en mayor que la derecha. 5 -gt 3 es verdadero -ge Revisa si la izquierda en mayor o igual que la derecha. 5 -ge 3 es verdadero PowerShell a\u00f1ade operadores de comparaci\u00f3n que aportan un nivel de complejidad mayor. Operador Acci\u00f3n Ejemplo -like Eval\u00faa un patr\u00f3n \"es como\". \"Perro\" -like \"Pe*\" es verdadero -notlike Eval\u00faa un patr\u00f3n \"no es como\". \"Perro\" -notlike \"Pe*\" es falso -contains Contiene un valor. 1,2,3 -contains 2 es verdadero -notcontains No contiene un valor. 1,2,3 -notcontains 2 es falso","title":"Comparaci\u00f3n"},{"location":"02_PowerShell/022_PowerShell_Sintaxis.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un script que se le introduzca dos n\u00fameros como argumentos y los muestre por pantalla. Dise\u00f1a un script en Shell que pida al usuario dos n\u00fameros, los guarde en dos variables y los muestre por pantalla. Crea un shell script que muestre por pantalla el resultado de de las siguientes operaciones. Debes tener en cuenta que a, b y c son variables enteras que son preguntadas al usuario al iniciar el script. a%b a/c 2 * b + 3 * (a-c) a * (b/c) (a*c)%b","title":"Actividades"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html","text":"Control de Flujo \u00b6 Estructuras \u00b6 En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript. Alternativa Simple \u00b6 if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } Alternativa doble \u00b6 if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa } Alternativa m\u00faltiple \u00b6 if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas } El equivalente a case en GNU/Linux \u00b6 switch ( $valor ){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ( $saludo ){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } { $_ -is [string] } { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ( $target ){ '^ftp\\://.*$' { \"$_ is an ftp address\" ; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\" ; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $( $matches [ 1 ]) \" ; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe un n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil: $_\" ; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones. Estructuras iterativas \u00b6 while \u00b6 A diferencia de lo que ocurr\u00eda en GNU/Linux, en PowerShell existen diferencias entre las estructuras while, do while y do until . En este caso, la \u00fanica de las tres que evaluar\u00e1 la condici\u00f3n al inicio del bloque de c\u00f3digo ser\u00e1 la primera. El resto comprueba la condici\u00f3n al final del bloque ejecutando como m\u00ednimo una vez el c\u00f3digo que contiene. while ( condici\u00f3n ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } do { bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } while ( condici\u00f3n ) Existe una variante de esta estructura que se crea sustituyendo el while por un until . Esto cambia el sentido de la condici\u00f3n y es este caso el bloque se repite hasta que la condici\u00f3n se cumpla. Esta estructura no es muy utilizada, pero siempre es bueno contar con herramientas extra. for \u00b6 Tambi\u00e9n la estructura for es sensiblemente diferente que en shellscript. Esta estructura en PowerShell tiene m\u00e1s que ver con los lenguajes de programaci\u00f3n y se utiliza cuando el programador sabe el n\u00famero de iteraciones que hay que realizar para solucionar un problema. for ( inicializaci\u00f3n ; condici\u00f3n ; incremento ){ bloque de c\u00f3digo a ejecutar mientras condici\u00f3n sea verdadera } Por ejemplo, la creaci\u00f3n de la tabla de multiplicar de un n\u00famero especificado por el usuario. Para resolver este problema s\u00ed se conoce el n\u00famero de iteraciones necesarias, concretamente diez. Example $numero = Read-Host \"Dame un n\u00famero\" Write-Host \"Esta es la tabla del $num\" for ( $i = 0 ; $i -lt 11 ; $i ++){ Write-Host \" $i x $numero = \" ( $i * $numero ) } foreach \u00b6 La estructura foreach en PowerShell es el equivalente a for en shellscript. Est\u00e1 pensada para recorrer un conjunto de valores y ejecutar el bloque de c\u00f3digo una vez por cada elemento del conjunto. foreach ( elemento in conjunto ){ bloque de c\u00f3digo a ejecutar por cada elemento del conjunto } Al igual que ocurre en GNU/Linux, el conjunto puede serlo de cualquier tipo de objetos, incluso los ficheros de una carpeta. En el siguiente ejemplo se buscan los ficheros que en su nombre contengan la cadena de texto que el usuario ha especificado: Example $ruta = \"C:\\Users\\Administrador\\Desktop\" $busca = Read-Host \"Escribe el texto a buscar\" foreach ( $archivo in Get-ChildItem $ruta ){ if ( $archivo . Name . IndexOf ( $busca ) -ge 0 ){ Write-Host $archivo . Name } } Note Las opciones que ofrece PowerShell en cuanto a estructuras de control parece una oferta m\u00e1s completa que la de shellscript, aunque para las tareas que se van a realizar en este m\u00f3dulo, ambos sistemas poseen herramientas suficientes. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un script que si no se la pasa ning\u00fan argumento nos lo diga. Crea un script PowerShell que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Usa el cmdlet Get-Date . Construye tres script PowerShell utilizando estructuras iterativas: el primero ej208A.ps1 , que imprima la tabla de multiplicar de un n\u00famero preguntado al usuario. Este n\u00famero debe ser entero positivo. el segundo ej208B.ps1 , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej208C.ps1 , que muestre las diez primeras tablas de multiplicar por pantalla. Hay un tiempo de espera de un segundo entre ellas. Utiliza las estructuras while, do while, for y foreach y el cmdlet Start-Sleep. NOTA Utiliza en la generaci\u00f3n de los scripts los cmdlets de depuraci\u00f3n si as\u00ed lo consideras al haber encontrado problemas en la ejecuci\u00f3n.","title":"2.3- Control de flujo"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#control-de-flujo","text":"","title":"Control de Flujo"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#estructuras","text":"En esta parte se indicar\u00e1 tan s\u00f3lo la sintaxis de las estructuras alternativas e iterativas, ya que los conceptos te\u00f3ricos ya se han abordado en el apartado de Shellscript.","title":"Estructuras"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#alternativa-simple","text":"if ( condici\u00f3n ){ ejecutar este c\u00f3digo si la condici\u00f3n es verdadera }","title":"Alternativa Simple"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#alternativa-doble","text":"if ( condici\u00f3n ) { ejecutar este c\u00f3digo si la condici\u00f3n es verdadera } else { ejecutar este c\u00f3digo si la condici\u00f3n es falsa }","title":"Alternativa doble"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#alternativa-multiple","text":"if ( condici\u00f3n1 ) { ejecutar este c\u00f3digo si la condici\u00f3n1 es verdadera } elseif ( condici\u00f3n2 ) { ejecutar este c\u00f3digo si la condici\u00f3n2 es verdadera } else { ejecutar este c\u00f3digo si todas las condiciones son falsas }","title":"Alternativa m\u00faltiple"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#el-equivalente-a-case-en-gnulinux","text":"switch ( $valor ){ opci\u00f3n1 { c\u00f3digo a ejecutar si opci\u00f3n1 coincide con $valor } opci\u00f3n2 { c\u00f3digo a ejecutar si opci\u00f3n2 coincide con $valor } opci\u00f3nN { c\u00f3digo a ejecutar si opci\u00f3nN coincide con $valor } default { c\u00f3digo a ejecutar si ninguna de las opciones coincide } } Example $saludo = Read-Host \"Escribe un saludo\" switch ( $saludo ){ \"Buenos d\u00edas\" { Write-Host \"Saludaste en Castellano\" } \"Bon dia\" { Write-Host \"Saludaste en Catal\u00e1n\" } \"Bo dias\" { Write-Host \"Saludaste en Gallego\" } \"Egun on\" { Write-Host \"Saludaste en Euskera\" } \"Good morning\" { Write-Host \"Saludaste en Ingl\u00e9s\" } \"Bonjour\" { Write-Host \"Saludaste en Franc\u00e9s\" } \"Buon Giorno\" { Write-Host \"Saludaste en Italiano\" } \"Bom d\u00eda\" { Write-Host \"Saludaste en Portugu\u00e9s\" } \"Guten Tag\" { Write-Host \"Saludaste en Alem\u00e1n\" } { $_ -is [string] } { Write Host \"La variable que has pasado es una cadena\" } default { \"Eso no parece un saludo\" } } Note Existe la posibilidad de colocar operadores l\u00f3gicos como opciones de un switch , si estos operadores l\u00f3gicos devuelven un valor verdadero, se ejecutar\u00e1 esa parte del c\u00f3digo, si se eval\u00faa a falso, no realizar\u00e1 esa parte del c\u00f3digo. El car\u00e1cter $_ hace referencia a la variable $saludo, de ese modo es posible realizar operaciones l\u00f3gicas con el valor pasado. Adem\u00e1s de todo esto, switch posee una serie de opciones que no est\u00e1n presentes en GNU/Linux, aunque es posible realizarlas de otra manera. Operador Descripci\u00f3n -wildcard S\u00f3lo aplicable a [string] . Indica si cumple un patr\u00f3n determinado. -exact S\u00f3lo aplicable a [string] . Debe coincidir exactamente con alguno de los patrones. -casesensitive S\u00f3lo aplicable a [string] . Debe coincidir en may\u00fasculas y min\u00fasculas. -file La entrada es un archivo. Se evaluar\u00e1 cada l\u00ednea del archivo. -regex S\u00f3lo aplicable a [string] . Permite usar expresiones regulares en la comparaci\u00f3n. Example -regex $target = 'https://bing.com' switch -Regex ( $target ){ '^ftp\\://.*$' { \"$_ is an ftp address\" ; Break } '^\\w+@\\w+\\.com|edu|org$' { \"$_ is an email address\" ; Break } '^(http[s]?)\\://.*$' { \"$_ is a web address that uses $( $matches [ 1 ]) \" ; Break } } Example -wildcard switch -wildcard ( Read-Host \"Escribe un n\u00famero de tel\u00e9fono\" ){ \"8*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"9*\" { Write-Host \"Es un tel\u00e9fono fijo: $_\" ; break } \"6*\" { Write-Host \"Es un tel\u00e9fono m\u00f3vil: $_\" ; break } default { \"$_ no parece un tel\u00e9fono\" } } El comando break que aparece al final de cada opci\u00f3n indica que si encuentra una coincidencia no siga buscando m\u00e1s y rompa el switch, ahorr\u00e1ndose as\u00ed el resto de comprobaciones.","title":"El equivalente a case en GNU/Linux"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#estructuras-iterativas","text":"","title":"Estructuras iterativas"},{"location":"02_PowerShell/023_PowerShell_ControlFlujo.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Crea un script que si no se la pasa ning\u00fan argumento nos lo diga. Crea un script PowerShell que al ejecutarlo muestre por pantalla uno de estos mensajes \u201cBuenos d\u00edas\u201d , \u201cBuenas tardes\u201d o \u201cBuenas noches\u201d , en funci\u00f3n de la hora que sea en el sistema (de 8:00 de la ma\u00f1ana a 15:00 ser\u00e1 ma\u00f1ana, de 15:00 a 20:00 ser\u00e1 tarde y el resto ser\u00e1 noche). Usa el cmdlet Get-Date . Construye tres script PowerShell utilizando estructuras iterativas: el primero ej208A.ps1 , que imprima la tabla de multiplicar de un n\u00famero preguntado al usuario. Este n\u00famero debe ser entero positivo. el segundo ej208B.ps1 , que pida un n\u00famero e indique si se trata de un n\u00famero par y si es n\u00famero primo. el tercero ej208C.ps1 , que muestre las diez primeras tablas de multiplicar por pantalla. Hay un tiempo de espera de un segundo entre ellas. Utiliza las estructuras while, do while, for y foreach y el cmdlet Start-Sleep. NOTA Utiliza en la generaci\u00f3n de los scripts los cmdlets de depuraci\u00f3n si as\u00ed lo consideras al haber encontrado problemas en la ejecuci\u00f3n.","title":"Actividades"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html","text":"Vectores y Funciones \u00b6 Vectores \u00b6 PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1 , 2 , 3 , 4 , 5 $Texto = \u201c Lunes \u201d , \u201c Martes \u201d , \u201d Mi\u00e9rcoles \u201d , \u201c Jueves \u201d , \u201d Viernes \u201d $EnterosRango = 1 .. 10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @( For ( $i ; $i < 5 ; $i ++){ $i }) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1 , 2 , 3 , 4 , 5 -Force New-Variable -Name Texto -Value \"Lunes\" , \"Martes\" , \"Mi\u00e9rcoles\" , \"Jueves\" , \"Viernes\" \u2013 Force New-Variable -Name EnterosRango -Value ( 1 .. 5 ) -Force New-Variable -Name EnterosFor -value (. { For ( $i = 1 ; $i -lt 5 ; $i ++){ $i }}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto . Length # mostrar\u00e1 5 por pantalla $Texto [ 2 ]. Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201c S\u00e1bado \u201d , \u201c Domingo \u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados. Funciones \u00b6 Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function < NOMBRE > { Param (< Par\u00e1metro >,< Par\u00e1metro >,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ( [integer] $a , [integer] $b ) $sumar = $a + $b Write-Host \u201c La suma es $sumar \u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. NOTA Utiliza en la generaci\u00f3n de los scripts los cmdlets de depuraci\u00f3n si as\u00ed lo consideras al haber encontrado problemas en la ejecuci\u00f3n.","title":"2.4- Vectores y Funciones"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#vectores-y-funciones","text":"","title":"Vectores y Funciones"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#vectores","text":"PowerShell considera como un vector a toda colecci\u00f3n de objetos, sea cual sea su tipo. Los elementos que lo conforman pueden estar separados por comas, estar expresados por el operador de rango .. o ser el resultado de alguna expresi\u00f3n que devuelva una colecci\u00f3n, como as\u00ed lo hacen muchos cmdlets. Example $Vacia = @{} $Enteros = 1 , 2 , 3 , 4 , 5 $Texto = \u201c Lunes \u201d , \u201c Martes \u201d , \u201d Mi\u00e9rcoles \u201d , \u201c Jueves \u201d , \u201d Viernes \u201d $EnterosRango = 1 .. 10 De esta forma se han definido cuatro vectores; el segundo contendr\u00e1 enteros y el tercero cadenas de caracteres. La \u00faltima l\u00ednea asigna los valores desde el 1 al 10 utilizando el operador rango .. . Note El operador de rango representa una secuencia de enteros, con los l\u00edmites superior e inferior separados por dos puntos decimales. Permite expresar el rango en orden ascendente o descendente, as\u00ed como tambi\u00e9n que los l\u00edmites inferior o superior sean establecidos por medio de variables que contengan enteros. Un vector tambi\u00e9n puede definirse como el resultado de una expresi\u00f3n. Example $EnterosFor = @( For ( $i ; $i < 5 ; $i ++){ $i }) $Comando = Get-Process | Sort-Object ProcessName En la primera l\u00ednea $enteros ser\u00e1 completado a trav\u00e9s del resultado de una estructura iterativa, mientras que la segunda contendr\u00e1 el resultado del cmdlet indicado. Adem\u00e1s de todas estas formas de declaraci\u00f3n, tambi\u00e9n se puede realizar a trav\u00e9s del cmdlet New-Variable Example New-Variable -Name Enteros -Value 1 , 2 , 3 , 4 , 5 -Force New-Variable -Name Texto -Value \"Lunes\" , \"Martes\" , \"Mi\u00e9rcoles\" , \"Jueves\" , \"Viernes\" \u2013 Force New-Variable -Name EnterosRango -Value ( 1 .. 5 ) -Force New-Variable -Name EnterosFor -value (. { For ( $i = 1 ; $i -lt 5 ; $i ++){ $i }}) -Force Note El atributo -Force sobrescribe la variable si esta ya existe, de ese modo no saltar\u00e1 ning\u00fan error a la hora de definir estas variables. Para obtener el n\u00famero de elementos de un vector se utiliza el m\u00e9todo Length, si se aplica a un elemento del vector, devolver\u00e1 el tama\u00f1o de este elemento, no del vector completo. Example $Texto . Length # mostrar\u00e1 5 por pantalla $Texto [ 2 ]. Length # mostrar\u00e1 9, las letras de \u201cMi\u00e9rcoles\u201d Para a\u00f1adir elementos al final de un vector se utiliza el operador += . Example $Enteros += 6 $Texto += \u201c S\u00e1bado \u201d , \u201c Domingo \u201d Note La primera l\u00ednea a\u00f1ade el entero 6 al vector $Enteros , mientras que en la segunda se a\u00f1aden los elementos \u201cS\u00e1bado\u201d y \u201cDomingo\u201d al vector $Texto . Para eliminar un elemento de un vector PowerShell no ofrece un sistema parecido al de a\u00f1adir valores, sino que tendr\u00e1 que reescribirse el vector de nuevo sin los valores no deseados.","title":"Vectores"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#funciones","text":"Tambi\u00e9n en PowerShell es posible utilizar funciones a trav\u00e9s de la siguiente estructura: Function < NOMBRE > { Param (< Par\u00e1metro >,< Par\u00e1metro >,...) Comandos PowerShell } Warning El paso de par\u00e1metros a una funci\u00f3n se realiza de id\u00e9ntica forma que en shell script. La principal diferencia entre las funciones usadas en shell script es que ahora es preferible declarar y tipar antes de iniciar con el c\u00f3digo de la funci\u00f3n. Example Function Get-Sumar { param ( [integer] $a , [integer] $b ) $sumar = $a + $b Write-Host \u201c La suma es $sumar \u201d } Note Si se ejecuta la siguiente instrucci\u00f3n: Get-Sumar 2 8 La salida del terminal ser\u00e1 La suma es 10 . Si se necesita que las funciones est\u00e9n disponibles durante la sesi\u00f3n del usuario o si es necesario enlazarlas desde otro script, se deber\u00e1 utilizar la notaci\u00f3n de punto, del mismo modo que ocurr\u00eda en shell script.","title":"Funciones"},{"location":"02_PowerShell/024_PowerShell_VectoresFunciones.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Dise\u00f1a un script PowerShell que lea un vector con 365 temperaturas y calcule la media y cuantos d\u00edas han estado por encima y cuantos por debajo de ella. Rellena el vector con valores aleatorios entre -5 y 35, para ello usa Get-Random. Crea un script PowerShell para que haga una copias de seguridad de todos los archivos del directorio de trabajo del usuario actual. Deber\u00e1 realizar las siguientes acciones: comprobar\u00e1 si el archivo ya existe en la copia de seguridad, si es as\u00ed comprobar\u00e1 cual de los dos es m\u00e1s reciente y que tama\u00f1o tienen. Si es m\u00e1s reciente o posee un tama\u00f1o mayor, lo copiar\u00e1. En cualquier otro caso, no lo copia. llevar\u00e1 un registro de todos los archivos copiados cada vez que se ejecute mediante un archivo de bit\u00e1cora. Guarda este fichero el directorio que contiene el script. Crea una funci\u00f3n para cada tarea realizada en este script. NOTA Utiliza en la generaci\u00f3n de los scripts los cmdlets de depuraci\u00f3n si as\u00ed lo consideras al haber encontrado problemas en la ejecuci\u00f3n.","title":"Actividades"},{"location":"02_PowerShell/ProgramacionAula.html","text":"Programaci\u00f3n de Aula \u00b6 Resultados de Aprendizaje \u00b6 Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Planificaci\u00f3n Temporal \u00b6 Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 27/09/22 Introducci\u00f3n PowerShell, Creaci\u00f3n Primer Script, Comentarios y depuraci\u00f3n. Introducci\u00f3n PowerShell 2 28/09/22 Sintaxis, Argumentos y variables, Interacci\u00f3n con el usuario, Operadores. Sintaxis PowerShell 3 29/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 04/10/22 Vectores y funciones Vectores y Funciones. 5 05/10/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n.","title":"Programaci\u00f3n de Aula"},{"location":"02_PowerShell/ProgramacionAula.html#programacion-de-aula","text":"","title":"Programaci\u00f3n de Aula"},{"location":"02_PowerShell/ProgramacionAula.html#resultados-de-aprendizaje","text":"Esta unidad cubre el Resultado de aprendizaje 7 (RA7) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. g. Se han implantado guiones en sistemas libres y propietario. h. Se han consultado y utilizado librer\u00edas de funciones. i. Se han documentado los guiones creados. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; }","title":"Resultados de Aprendizaje"},{"location":"02_PowerShell/ProgramacionAula.html#planificacion-temporal","text":"Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 27/09/22 Introducci\u00f3n PowerShell, Creaci\u00f3n Primer Script, Comentarios y depuraci\u00f3n. Introducci\u00f3n PowerShell 2 28/09/22 Sintaxis, Argumentos y variables, Interacci\u00f3n con el usuario, Operadores. Sintaxis PowerShell 3 29/09/22 Control de Flujo. Estructuras condicionales e iterativas. Control de Flujo. 4 04/10/22 Vectores y funciones Vectores y Funciones. 5 05/10/22 Refuerzo y Ampliaci\u00f3n. Refuerzo y Ampliaci\u00f3n.","title":"Planificaci\u00f3n Temporal"},{"location":"02_PowerShell/ResumenUD.html","text":"Resumen UD \u00b6 A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"02_PowerShell/ResumenUD.html#resumen-ud","text":"A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"03_Procesos/031_Planificador.html","text":"Procesos. \u00b6 Tipos. Estados. Estructura. \u00b6 Un proceso es una instancia de un programa en ejecuci\u00f3n . Es decir, cada vez que se lanza un programa, se crea un proceso, de forma que si lanzo el mismo programa dos veces, tendr\u00e9 dos procesos distintos aunque partan de las mismas instrucciones. Cuando el usuario o una aplicaci\u00f3n pide la ejecuci\u00f3n de un determinado programa, el sistema operativo debe proveer de los recursos necesarios para esta tarea. Para ello debe buscar espacio en memoria RAM tanto para las instrucciones que van a ejecutarse como para los datos que necesita el programa y saber qu\u00e9 ficheros, dispositivos de E/S, etc... van a ser utilizados. Warning La CPU se encarga de un solo proceso en cada instante de tiempo, para optimizar el rendimiento de la misma se utilizan t\u00e9cnicas como la multiprogramaci\u00f3n y multihilado , conceptos que se ver\u00e1n en esta Unidad. La multiprogramaci\u00f3n es una t\u00e9cnica de multiplexaci\u00f3n que permite la ejecuci\u00f3n simult\u00e1nea de m\u00faltiples procesos en un \u00fanico procesador. En realidad, esta t\u00e9cnica produce una ilusi\u00f3n de paralelismo, de manera que parece que todos los procesos se est\u00e1n ejecutando a la vez. Sin embargo, hay un \u00fanico proceso ejecut\u00e1ndose en el procesador a la vez. Ejemplo de Multiprogramaci\u00f3n Estructura \u00b6 Los procesos se estructuran de forma jer\u00e1rquica . EL sistema operativo lanza el primero y a partir de este se crean todos los dem\u00e1s. El sistema operativo crear\u00e1 una estructura de control en la que tenga toda la informaci\u00f3n de dicho proceso. A esta estructura se le llama BCP (Bloque de control de proceso), y contiene diferente informaci\u00f3n dependiendo del sistema operativo del que hablemos, pero por lo general tiene: PID (Process IDentifier): Identifica de forma un\u00edvoca al proceso en el sistema, generalmente se emplea un entero sin signo . Estado del proceso : listo o espera, ejecuci\u00f3n o bloqueado. Registros del procesador : cada vez que se ejecuta el planificador y se realiza una conmutaci\u00f3n de procesos, la informaci\u00f3n sobre en qu\u00e9 lugar se encontraba la ejecuci\u00f3n del proceso debe guardarse, as\u00ed como el lugar en el que se par\u00f3 la ejecuci\u00f3n del anterior proceso (en su respectivo BCP). Gesti\u00f3n de memoria : tales como el espacio de direcciones y la cantidad de memoria asignada a un proceso. Aspectos relacionados con la administraci\u00f3n de ficheros : por ejemplo con que ficheros est\u00e1 el proceso actualmente operando. Los procesadores en los que el proceso puede ejecutarse: en caso de soportar el sistema multiprocesador. En el caso de un sistema operativo tipo UNIX: el proceso padre de dicho proceso y la relaci\u00f3n de procesos. Estad\u00edsticas Tiempo de lanzamiento del proceso, tiempo en estado activo, etc. Componentes de BCP Tipos de Procesos \u00b6 Los procesos pueden clasificarse de distintas formas, por ejemplo, atendiendo a la interacci\u00f3n con el usuario podemos encontrarnos: Procesos en primer plano (foreground) : precisan de la intervenci\u00f3n del usuario. Procesos en segundo plano (background) : Se ejecutan sin que el usuario tenga que hacer nada. Tambi\u00e9n podemos atender al modo en el que se ejecutan estos, aunque puede ser que un mismo proceso pase de un modo a otro durante su ejecuci\u00f3n. Procesos en modo kernel : Son procesos que tienen acceso privilegiado a todo el equipo. Son mucho m\u00e1s seguros. La mayor\u00eda de los procesos del sistema operativo son de este tipo. Procesos en modo usuario : Menos seguros. Todos los que ejecutan los usuarios y/o aplicaciones de usuario suelen ser de ese tipo. Dependiendo de qui\u00e9n lo ejecut\u00f3: Procesos del sistema : Los que han sido lanzados por el propio sistema operativo. Procesos de usuario : Los que ha lanzado un usuario. Tambi\u00e9n podemos encontrar procesos monohilo o multihilo . Estados \u00b6 Hay tres estados b\u00e1sicos en los que puede estar un proceso: En ejecuci\u00f3n : el proceso tiene asignada la CPU, por la tanto est\u00e1 en ejecuci\u00f3n en ese instante. Listo o En espera : Est\u00e1 en la listo para que se le conceda el procesador. Es una especie de buffer que guarda el orden de llegada de los procesos. Bloqueado : Est\u00e1 esperando a que se libere un recurso para poder seguir con su ejecuci\u00f3n. Estados en los que puede estar un proceso Note Podemos encontrar m\u00e1s estados intermedios hasta 13, a destacar los definidos anteriormente, ya que los que contemplan todos los sistemas operativos multitarea. Aunque es recomendable tambi\u00e9n conocer los siguientes: Parado : Le ha llegado una se\u00f1al para que se pare y espera a que le llegue otra para reiniciarse. Por ejemplo, el proceso tiene configurado un tiempo de inactividad, como una especie de reloj despertador de forma que cuando pase ese tiempo, le llegar\u00e1 una se\u00f1al y se reiniciar\u00e1. ( sleep ) Zombie : El proceso, que es hijo de otro, ha terminado pero por alg\u00fan motivo no puede comunicarse con su proceso padre y terminar completamente. Estos procesos quedan ocupando una entrada en la tabla de procesos y los recursos correspondientes. Transiciones de estados \u00b6 Los procesos pueden pasar desde su ejecuci\u00f3n por tres estados, que son los que indicamos en el punto anterior: En espera, bloqueado y en ejecuci\u00f3n. Cuando un usuario o el sistema operativo ejecuta un programa, ocurre lo siguiente: Se crea una nueva entrada en la tabla de procesos del sistema, Se asigna un PID al proceso. Se le asignan los recursos y la zona de memoria necesaria. Se cargan las p\u00e1ginas del programa en memoria RAM. Se pone el proceso en la lista de espera para que el planificador le conceda el procesador. En ese momento el planificador debe cambiar de estado a los procesos en funci\u00f3n de sus caracter\u00edsticas, del quantum o de si posee o no los recursos necesarios para su ejecuci\u00f3n. Se pueden dar las siguientes transiciones: El proceso se encuentra listo para su ejecuci\u00f3n y le toca el turno para pasar al procesador. En este momento el proceso cuenta con todos los recursos que necesita. Cuando un proceso se encuentra en ejecuci\u00f3n pero pierde alguno de sus recursos y no puede continuar. En este momento el planificador lo coloca en estado bloqueado. Cuando un proceso en estado bloqueado (le falta alg\u00fan recurso) ha obtenido todo lo que necesita para seguir con su ejecuci\u00f3n. El planificador lo coloca en estado Preparado. Cuando un proceso se encuentra en ejecuci\u00f3n y no pierde ninguno de sus recursos, pero ha terminado el tiempo asignado por el planificador para usar el procesador. Pasa al estado Preparado. La transici\u00f3n que nunca se dar\u00e1 , si el planificador es adecuado, es la que va desde el estado En espera o Bloqueado al de En Ejecuci\u00f3n . Si ocurriera esto, es decir, si un proceso decidiera tomar el control de los recursos sin consultarle al planificador, los resultados podr\u00edan ser catastr\u00f3ficos. Estados en los que puede estar un proceso El planificador \u00b6 El planificador se encarga de decidir a qu\u00e9 proceso o hilo se le va a ceder el procesador y por cu\u00e1nto tiempo. Para esto, se utilizan una serie de algoritmos matem\u00e1ticos que intentan cumplir las siguientes premisas en el reparto de la cpu: Equidad: Todos los procesos deben ser atendidos. Eficacia: El procesador debe estar ocupado el 100% del tiempo. Tiempo de respuesta: El tiempo empleado en dar respuesta a las solicitudes del usuario debe ser el menor posible. Tiempo de regreso: Reducir al m\u00ednimo el tiempo de espera de los resultado esperados por los usuarios por lotes. Rendimiento: Maximizar el n\u00famero de tareas que se procesan por cada hora. Tipos de algoritmo de programaci\u00f3n de CPU \u00b6 Existen principalmente seis tipos de algoritmos de programaci\u00f3n de procesos: First Come First Serve (FCFS) o First In First Out ( FIFO ) Shortest-Job-First ( SJF ) Shortest Remaining Time First ( SRTF ) Prioridades: Expulsivo o no Expulsivo. Round Robin. FIFO \u00b6 El primero en llegar es el primero en ser servido es la forma completa de FCFS. Es el algoritmo de programaci\u00f3n de CPU m\u00e1s f\u00e1cil y simple . En este tipo de algoritmo, el proceso que solicita la CPU obtiene primero la asignaci\u00f3n de CPU. Caracter\u00edsticas : No expulsivo. Los trabajos siempre se ejecutan por orden de llegada. Es f\u00e1cil de implementar y usar. Sin embargo, este m\u00e9todo tiene un rendimiento deficiente y el tiempo de espera general es bastante alto. Ejemplo FIFO SJF \u00b6 Este m\u00e9todo utiliza una pol\u00edtica de programaci\u00f3n que selecciona para la ejecuci\u00f3n el proceso de espera con el menor tiempo de ejecuci\u00f3n. Caracter\u00edsticas : No expulsivo. Es ventajoso debido a su simplicidad y porque minimiza la cantidad promedio de tiempo que cada proceso tiene que esperar hasta que se completa su ejecuci\u00f3n. El tiempo total de ejecuci\u00f3n de un trabajo debe conocerse antes de su ejecuci\u00f3n. Ejemplo SJF SRTF \u00b6 Este m\u00e9todo es la evoluci\u00f3n del anterior pero con la caracter\u00edstica de ser Expulsivo. Caracter\u00edsticas : Expulsivo. Este m\u00e9todo se aplica principalmente en entornos por lotes donde se requiere dar preferencia a los trabajos cortos. Este no es un m\u00e9todo ideal para implementarlo en un sistema compartido donde se desconoce el tiempo de CPU requerido. Ejemplo SRTF Prioridades \u00b6 Es un m\u00e9todo de programaci\u00f3n de procesos en funci\u00f3n de la prioridad. Los procesos con mayor prioridad deben llevarse a cabo en primer lugar, mientras que los trabajos con igual prioridad se llevan a cabo por turnos o FCFS. La prioridad se puede decidir en funci\u00f3n de los requisitos de memoria, los requisitos de tiempo, etc. Ejemplo Prioridades no expulsivo Ejemplo Prioridades expulsivo Round Robin \u00b6 El nombre de este algoritmo proviene del principio de turnos, en el que cada persona obtiene una parte igual de algo a su vez. Se utiliza principalmente para programar algoritmos en multitarea. Este m\u00e9todo de algoritmo ayuda a la ejecuci\u00f3n libre de inanici\u00f3n de procesos. Caracter\u00edsticas : Round robin es un modelo h\u00edbrido que funciona con reloj Es un sistema en tiempo real que responde al evento dentro de un l\u00edmite de tiempo espec\u00edfico. Aumenta los tiempos medios. Ejemplo Round Robin Actividades \u00b6 En las siguientes actividades se debe realizar: Calcular el tiempo de espera y tiempo de respuesta de cada proceso. Gr\u00e1ficamente y de forma num\u00e9rica con ayuda de la plantilla en ods adjunta en el moodle. Calcular el tiempo medio de espera y respuesta de cada algoritmo. Realizar una conclusi\u00f3n comparando los resultados de tiempos de los algoritmos. Utilizando los algoritmos de planificaci\u00f3n FIFO, SJF y SRTF: Utilizando los algoritmos de planificaci\u00f3n FIFO, Round Robin y Prioridades no expulsivo: En Round Robin utiliza el Quantum igual a 2. Utilizando los algoritmos de planificaci\u00f3n FIFO, Round Robin y SJF: En Round Robin utiliza el Quantum igual a 2. Utilizando los algoritmos de planificaci\u00f3n SRTF, Prioridades no expulsivo y Prioridades expulsivo:","title":"3.1- Introducci\u00f3n Procesos, Planificador"},{"location":"03_Procesos/031_Planificador.html#procesos","text":"","title":"Procesos."},{"location":"03_Procesos/031_Planificador.html#tipos-estados-estructura","text":"Un proceso es una instancia de un programa en ejecuci\u00f3n . Es decir, cada vez que se lanza un programa, se crea un proceso, de forma que si lanzo el mismo programa dos veces, tendr\u00e9 dos procesos distintos aunque partan de las mismas instrucciones. Cuando el usuario o una aplicaci\u00f3n pide la ejecuci\u00f3n de un determinado programa, el sistema operativo debe proveer de los recursos necesarios para esta tarea. Para ello debe buscar espacio en memoria RAM tanto para las instrucciones que van a ejecutarse como para los datos que necesita el programa y saber qu\u00e9 ficheros, dispositivos de E/S, etc... van a ser utilizados. Warning La CPU se encarga de un solo proceso en cada instante de tiempo, para optimizar el rendimiento de la misma se utilizan t\u00e9cnicas como la multiprogramaci\u00f3n y multihilado , conceptos que se ver\u00e1n en esta Unidad. La multiprogramaci\u00f3n es una t\u00e9cnica de multiplexaci\u00f3n que permite la ejecuci\u00f3n simult\u00e1nea de m\u00faltiples procesos en un \u00fanico procesador. En realidad, esta t\u00e9cnica produce una ilusi\u00f3n de paralelismo, de manera que parece que todos los procesos se est\u00e1n ejecutando a la vez. Sin embargo, hay un \u00fanico proceso ejecut\u00e1ndose en el procesador a la vez. Ejemplo de Multiprogramaci\u00f3n","title":"Tipos. Estados. Estructura."},{"location":"03_Procesos/031_Planificador.html#estructura","text":"Los procesos se estructuran de forma jer\u00e1rquica . EL sistema operativo lanza el primero y a partir de este se crean todos los dem\u00e1s. El sistema operativo crear\u00e1 una estructura de control en la que tenga toda la informaci\u00f3n de dicho proceso. A esta estructura se le llama BCP (Bloque de control de proceso), y contiene diferente informaci\u00f3n dependiendo del sistema operativo del que hablemos, pero por lo general tiene: PID (Process IDentifier): Identifica de forma un\u00edvoca al proceso en el sistema, generalmente se emplea un entero sin signo . Estado del proceso : listo o espera, ejecuci\u00f3n o bloqueado. Registros del procesador : cada vez que se ejecuta el planificador y se realiza una conmutaci\u00f3n de procesos, la informaci\u00f3n sobre en qu\u00e9 lugar se encontraba la ejecuci\u00f3n del proceso debe guardarse, as\u00ed como el lugar en el que se par\u00f3 la ejecuci\u00f3n del anterior proceso (en su respectivo BCP). Gesti\u00f3n de memoria : tales como el espacio de direcciones y la cantidad de memoria asignada a un proceso. Aspectos relacionados con la administraci\u00f3n de ficheros : por ejemplo con que ficheros est\u00e1 el proceso actualmente operando. Los procesadores en los que el proceso puede ejecutarse: en caso de soportar el sistema multiprocesador. En el caso de un sistema operativo tipo UNIX: el proceso padre de dicho proceso y la relaci\u00f3n de procesos. Estad\u00edsticas Tiempo de lanzamiento del proceso, tiempo en estado activo, etc. Componentes de BCP","title":"Estructura"},{"location":"03_Procesos/031_Planificador.html#tipos-de-procesos","text":"Los procesos pueden clasificarse de distintas formas, por ejemplo, atendiendo a la interacci\u00f3n con el usuario podemos encontrarnos: Procesos en primer plano (foreground) : precisan de la intervenci\u00f3n del usuario. Procesos en segundo plano (background) : Se ejecutan sin que el usuario tenga que hacer nada. Tambi\u00e9n podemos atender al modo en el que se ejecutan estos, aunque puede ser que un mismo proceso pase de un modo a otro durante su ejecuci\u00f3n. Procesos en modo kernel : Son procesos que tienen acceso privilegiado a todo el equipo. Son mucho m\u00e1s seguros. La mayor\u00eda de los procesos del sistema operativo son de este tipo. Procesos en modo usuario : Menos seguros. Todos los que ejecutan los usuarios y/o aplicaciones de usuario suelen ser de ese tipo. Dependiendo de qui\u00e9n lo ejecut\u00f3: Procesos del sistema : Los que han sido lanzados por el propio sistema operativo. Procesos de usuario : Los que ha lanzado un usuario. Tambi\u00e9n podemos encontrar procesos monohilo o multihilo .","title":"Tipos de Procesos"},{"location":"03_Procesos/031_Planificador.html#estados","text":"Hay tres estados b\u00e1sicos en los que puede estar un proceso: En ejecuci\u00f3n : el proceso tiene asignada la CPU, por la tanto est\u00e1 en ejecuci\u00f3n en ese instante. Listo o En espera : Est\u00e1 en la listo para que se le conceda el procesador. Es una especie de buffer que guarda el orden de llegada de los procesos. Bloqueado : Est\u00e1 esperando a que se libere un recurso para poder seguir con su ejecuci\u00f3n. Estados en los que puede estar un proceso Note Podemos encontrar m\u00e1s estados intermedios hasta 13, a destacar los definidos anteriormente, ya que los que contemplan todos los sistemas operativos multitarea. Aunque es recomendable tambi\u00e9n conocer los siguientes: Parado : Le ha llegado una se\u00f1al para que se pare y espera a que le llegue otra para reiniciarse. Por ejemplo, el proceso tiene configurado un tiempo de inactividad, como una especie de reloj despertador de forma que cuando pase ese tiempo, le llegar\u00e1 una se\u00f1al y se reiniciar\u00e1. ( sleep ) Zombie : El proceso, que es hijo de otro, ha terminado pero por alg\u00fan motivo no puede comunicarse con su proceso padre y terminar completamente. Estos procesos quedan ocupando una entrada en la tabla de procesos y los recursos correspondientes.","title":"Estados"},{"location":"03_Procesos/031_Planificador.html#transiciones-de-estados","text":"Los procesos pueden pasar desde su ejecuci\u00f3n por tres estados, que son los que indicamos en el punto anterior: En espera, bloqueado y en ejecuci\u00f3n. Cuando un usuario o el sistema operativo ejecuta un programa, ocurre lo siguiente: Se crea una nueva entrada en la tabla de procesos del sistema, Se asigna un PID al proceso. Se le asignan los recursos y la zona de memoria necesaria. Se cargan las p\u00e1ginas del programa en memoria RAM. Se pone el proceso en la lista de espera para que el planificador le conceda el procesador. En ese momento el planificador debe cambiar de estado a los procesos en funci\u00f3n de sus caracter\u00edsticas, del quantum o de si posee o no los recursos necesarios para su ejecuci\u00f3n. Se pueden dar las siguientes transiciones: El proceso se encuentra listo para su ejecuci\u00f3n y le toca el turno para pasar al procesador. En este momento el proceso cuenta con todos los recursos que necesita. Cuando un proceso se encuentra en ejecuci\u00f3n pero pierde alguno de sus recursos y no puede continuar. En este momento el planificador lo coloca en estado bloqueado. Cuando un proceso en estado bloqueado (le falta alg\u00fan recurso) ha obtenido todo lo que necesita para seguir con su ejecuci\u00f3n. El planificador lo coloca en estado Preparado. Cuando un proceso se encuentra en ejecuci\u00f3n y no pierde ninguno de sus recursos, pero ha terminado el tiempo asignado por el planificador para usar el procesador. Pasa al estado Preparado. La transici\u00f3n que nunca se dar\u00e1 , si el planificador es adecuado, es la que va desde el estado En espera o Bloqueado al de En Ejecuci\u00f3n . Si ocurriera esto, es decir, si un proceso decidiera tomar el control de los recursos sin consultarle al planificador, los resultados podr\u00edan ser catastr\u00f3ficos. Estados en los que puede estar un proceso","title":"Transiciones de estados"},{"location":"03_Procesos/031_Planificador.html#el-planificador","text":"El planificador se encarga de decidir a qu\u00e9 proceso o hilo se le va a ceder el procesador y por cu\u00e1nto tiempo. Para esto, se utilizan una serie de algoritmos matem\u00e1ticos que intentan cumplir las siguientes premisas en el reparto de la cpu: Equidad: Todos los procesos deben ser atendidos. Eficacia: El procesador debe estar ocupado el 100% del tiempo. Tiempo de respuesta: El tiempo empleado en dar respuesta a las solicitudes del usuario debe ser el menor posible. Tiempo de regreso: Reducir al m\u00ednimo el tiempo de espera de los resultado esperados por los usuarios por lotes. Rendimiento: Maximizar el n\u00famero de tareas que se procesan por cada hora.","title":"El planificador"},{"location":"03_Procesos/031_Planificador.html#tipos-de-algoritmo-de-programacion-de-cpu","text":"Existen principalmente seis tipos de algoritmos de programaci\u00f3n de procesos: First Come First Serve (FCFS) o First In First Out ( FIFO ) Shortest-Job-First ( SJF ) Shortest Remaining Time First ( SRTF ) Prioridades: Expulsivo o no Expulsivo. Round Robin.","title":"Tipos de algoritmo de programaci\u00f3n de CPU"},{"location":"03_Procesos/031_Planificador.html#fifo","text":"El primero en llegar es el primero en ser servido es la forma completa de FCFS. Es el algoritmo de programaci\u00f3n de CPU m\u00e1s f\u00e1cil y simple . En este tipo de algoritmo, el proceso que solicita la CPU obtiene primero la asignaci\u00f3n de CPU. Caracter\u00edsticas : No expulsivo. Los trabajos siempre se ejecutan por orden de llegada. Es f\u00e1cil de implementar y usar. Sin embargo, este m\u00e9todo tiene un rendimiento deficiente y el tiempo de espera general es bastante alto. Ejemplo FIFO","title":"FIFO"},{"location":"03_Procesos/031_Planificador.html#sjf","text":"Este m\u00e9todo utiliza una pol\u00edtica de programaci\u00f3n que selecciona para la ejecuci\u00f3n el proceso de espera con el menor tiempo de ejecuci\u00f3n. Caracter\u00edsticas : No expulsivo. Es ventajoso debido a su simplicidad y porque minimiza la cantidad promedio de tiempo que cada proceso tiene que esperar hasta que se completa su ejecuci\u00f3n. El tiempo total de ejecuci\u00f3n de un trabajo debe conocerse antes de su ejecuci\u00f3n. Ejemplo SJF","title":"SJF"},{"location":"03_Procesos/031_Planificador.html#srtf","text":"Este m\u00e9todo es la evoluci\u00f3n del anterior pero con la caracter\u00edstica de ser Expulsivo. Caracter\u00edsticas : Expulsivo. Este m\u00e9todo se aplica principalmente en entornos por lotes donde se requiere dar preferencia a los trabajos cortos. Este no es un m\u00e9todo ideal para implementarlo en un sistema compartido donde se desconoce el tiempo de CPU requerido. Ejemplo SRTF","title":"SRTF"},{"location":"03_Procesos/031_Planificador.html#prioridades","text":"Es un m\u00e9todo de programaci\u00f3n de procesos en funci\u00f3n de la prioridad. Los procesos con mayor prioridad deben llevarse a cabo en primer lugar, mientras que los trabajos con igual prioridad se llevan a cabo por turnos o FCFS. La prioridad se puede decidir en funci\u00f3n de los requisitos de memoria, los requisitos de tiempo, etc. Ejemplo Prioridades no expulsivo Ejemplo Prioridades expulsivo","title":"Prioridades"},{"location":"03_Procesos/031_Planificador.html#round-robin","text":"El nombre de este algoritmo proviene del principio de turnos, en el que cada persona obtiene una parte igual de algo a su vez. Se utiliza principalmente para programar algoritmos en multitarea. Este m\u00e9todo de algoritmo ayuda a la ejecuci\u00f3n libre de inanici\u00f3n de procesos. Caracter\u00edsticas : Round robin es un modelo h\u00edbrido que funciona con reloj Es un sistema en tiempo real que responde al evento dentro de un l\u00edmite de tiempo espec\u00edfico. Aumenta los tiempos medios. Ejemplo Round Robin","title":"Round Robin"},{"location":"03_Procesos/031_Planificador.html#actividades","text":"En las siguientes actividades se debe realizar: Calcular el tiempo de espera y tiempo de respuesta de cada proceso. Gr\u00e1ficamente y de forma num\u00e9rica con ayuda de la plantilla en ods adjunta en el moodle. Calcular el tiempo medio de espera y respuesta de cada algoritmo. Realizar una conclusi\u00f3n comparando los resultados de tiempos de los algoritmos. Utilizando los algoritmos de planificaci\u00f3n FIFO, SJF y SRTF: Utilizando los algoritmos de planificaci\u00f3n FIFO, Round Robin y Prioridades no expulsivo: En Round Robin utiliza el Quantum igual a 2. Utilizando los algoritmos de planificaci\u00f3n FIFO, Round Robin y SJF: En Round Robin utiliza el Quantum igual a 2. Utilizando los algoritmos de planificaci\u00f3n SRTF, Prioridades no expulsivo y Prioridades expulsivo:","title":"Actividades"},{"location":"03_Procesos/032_Hilos.html","text":"Hilos \u00b6 Definici\u00f3n \u00b6 Un hilo o hebra (Thread), proceso ligero o subproceso es la secuencia de instrucciones m\u00e1s elemental, que puede ser gestionada por el planificador . NOTA A priori los procesos pueden ejecutarse como un solo hilo , es decir, las instrucciones v\u00e1n siguiendo un orden y nunca se pueden ejecutar a la vez dos instrucciones del mismo proceso. El concepto de multihilo consiste en que partes del mismo proceso pueden ejecutarse en paralelo, es decir , el mismo programa tiene partes que pueden ejecutarse a la vez. De este modo, se puede ahorrar tiempo. Por ejemplo, un navegador de internet puede tener varios hilos, uno muestra las im\u00e1genes mientras otro recupera datos de la red. Estados en los que puede estar los procesos e hilos en el navegador. NOTA Es f\u00e1cil confundir hilos y procesos. La diferencia principal es que un proceso tiene asignado un un BCP y los hilos son parte del mismo proceso. Esto significa entre otras cosas que la memoria que se asigna al proceso la compartir\u00e1n todos los hilos. Tambi\u00e9n comparten el resto de recursos como ficheros abiertos, etc. Por lo tanto si uno de los hilos modifica un recurso o una variable de memoria, el cambio afectar\u00e1 al resto de hilos del proceso. Debido a esto es importante la sincronizaci\u00f3n entre hilos . Cada hilo tendr\u00e1 un identificador, un contador de programa y una pila propias. Se pueden distinguir los siguientes tipos de hilos: Hilos a nivel de usuario : Son los que crean los programadores y de los cuales el kernel o n\u00facleo del sistema no es consciente de que existan, por lo que el propio programador debe encargarse de la sincronizaci\u00f3n de estos. Hilos a nivel de kernel : Estos son gestionados por el sistema operativo, por lo que si tenemos un procesador con varios n\u00facleos y /o varios procesadores, se acelerar\u00e1 la ejecuci\u00f3n del proceso . El sistema operativo se encarga del cambio entre hilos. Adem\u00e1s contamos con sistemas operativos que son capaces de gestionar hilos (a nivel de kernel , claro) y sistemas operativos que no lo son. Estados en los que puede estar un proceso Ventajas de los hilos frente a los procesos \u00b6 Los hilos son mucho m\u00e1s ligeros que los procesos. En la creaci\u00f3n de procesos se necesita un tiempo para la adjudicaci\u00f3n de memoria y de recursos que no es necesaria en el caso de cambio entre hilos. Tambi\u00e9n el cambio de contexto es mucho m\u00e1s \"Pesado\" en el caso de los procesos. La utilizaci\u00f3n de hilos hace que los procesos sean m\u00e1s \u00e1giles , debido a que si una de las partes del proceso se bloquea esperando un recurso, otra en otro hilo puede avanzar con otras tareas. En caso de procesadores multin\u00facleo o sistemas multiprocesador, la eficiencia de los procesos que utilizan hilos es evidente, al poder realizar varias tareas realmente en paralelo (un hilo en cada procesador). INFO Un proceso multihilo no desaparece hasta que no han terminado todos sus hilos. Sincronizaci\u00f3n y Comunicaci\u00f3n entre procesos \u00b6 Hay procesos independientes y otros que deben comunicarse y sincronizarse con otros. En este caso se utilizan se\u00f1ales para enviar informaci\u00f3n entre procesos , y de este modo poder gestionar recursos y zonas de memoria compartida. Ejemplo Un proceso (P1) puede necesitar un dato que otro proceso (P2) produce y hasta que esto no ocurra, no podr\u00e1 continuar con su ejecuci\u00f3n. En este caso el proceso P1 se quedar\u00e1 bloqueado hasta que reciba una se\u00f1al que le enviar\u00e1 P2, indic\u00e1ndole que ya tiene disponible el dato. Consejo Antes de conocer diferentes casos problem\u00e1ticos y sus posibles soluciones se debe conocer los siguientes elementos que interact\u00faan en la comunicaci\u00f3n de procesos. Mensajes \u00b6 Cuando los procesos tienen que compartir informaci\u00f3n, incluso en equipos remotos, pueden utilizar colas de mensajes para enviarla. Los procesos introducen y extraen los mensajes, con la informaci\u00f3n necesaria a enviar al proceso o entidad que se necesite en cada caso. Existen varios \"tipos\" de mensajes distintos, de forma que cada tipo de mensaje contiene una informaci\u00f3n distinta y va identificado por un entero. Se\u00f1ales \u00b6 Las se\u00f1ales se utilizan para sincronizar procesos. Cada se\u00f1al tiene un comportamiento por defecto, como puede ser pausar un proceso o pararlo. La mayor\u00eda de ellas pueden ser tratadas de forma que el programa la recoja y realice una serie de instrucciones cuando esta llegue. Ejemplo Hay formas de pasar se\u00f1ales al sistema operativo, por ejemplo, cuando pulsamos control+C, o utilizando funciones del sistema para enviar una determinada se\u00f1al a un proceso para modificar la forma de actuar de \u00e9ste en ese momento dado. Interrupciones y excepciones \u00b6 Una Interrupci\u00f3n es una se\u00f1al que env\u00eda un dispositivo de E/S al procesador para pedir que se le atienda. Cada interrupci\u00f3n tiene asociada una rutina que debe pasar a ejecutarse cuando esta se produzca. Tambi\u00e9n existen las interrupciones de Software, que env\u00edan los programas de usuario al sistema operativo para requerir su atenci\u00f3n. El siguiente esquema muestra un resumen del concepto de Interrupci\u00f3n. Resumen Interrupci\u00f3n NOTA Una excepci\u00f3n se produce cuando hay una instrucci\u00f3n err\u00f3nea en un programa, por ejemplo, una divisi\u00f3n por 0. En ese momento el sistema operativo debe realizar las acciones oportunas. En ciertos intervalos de tiempo puede convenir no aceptar se\u00f1ales de interrupci\u00f3n. Por ello las interrupciones pueden inhibirse por software, seg\u00fan lo necesite el sistema. Casos y soluciones de sincronizaci\u00f3n \u00b6 Una vez conocidos los elementos que se relacionan en la sincronizaci\u00f3n, en los siguientes apartados se muestran varias situaciones en los que se evidencia la necesidad de sincronizaci\u00f3n entre procesos, por problemas de acceso a recursos compartidos y las principales posibles soluciones planteadas. Casos de necesidad de sincronizaci\u00f3n \u00b6 Condiciones de competencia \u00b6 Existen una serie de casos en los que pueden aparecer ciertos problemas denominados Condiciones de competencia ; los cuales ocurren cuando dos o m\u00e1s procesos intentan acceder a un mismo recurso. Ejemplo P1 y P2 intentan acceder a una variable global en memoria que llamaremos A pongamos que con un valor inicial de 5 . P1 se encarga de sumar 2 a la variable y P2 de restarle 1.Lo normal es que si entra P1 , modifica A y luego lo hace P2, el resultado de A sea 6. Pero puede darse el siguiente caso : P1 recoge el valor de la variable, por ejemplo, (5) la pase a un registro interno de la cpu para operar con este valor y antes de dejar el resultado en memoria pierda el procesador. En ese momento P2 entra en el procesador y pone sus registros, etc. Recoge el valor de A (5, puesto que a P1 no le ha dado tiempo a dejar el resultado en memoria), lo cambia con un resultado de 4 y lo deja en memoria. Cuando el proceso P1 vuelva a tener el procesador, dejar\u00e1 su resultado (5+2=7) en la variable A de memoria, machacando el resultado de P2 y se habr\u00e1 perdido la operaci\u00f3n que realiz\u00f3 dicho proceso. Interbloqueo o abrazo \u00b6 En el caso de competencia por recursos, el sistema operativo tambi\u00e9n se debe asegurar de que no se produce Interbloqueo o abrazo Esto ocurre, por ejemplo, cuando un proceso P1 necesita dos recursos R1 y R2; A su vez otro proceso P2 precisa tambi\u00e9n los mismos recursos. M\u00e1s en detalle puede ocurrir: P1 recibe la cpu y ocupa el recurso R1 , y pierde el procesador. Entra P2 en el sistema y coge el recurso R2 , como no puede coger el recurso R1 se bloquea. Pasa el procesador al proceso P1 , pero este no puede coger el recurso R2 , con lo que tambi\u00e9n se bloquea. El resultado es que tenemos dos procesos que se bloquean mutuamente y no pueden avanzar en su ejecuci\u00f3n. Interbloqueo Para solucionar las condiciones de competencia se implement\u00f3 un modelo para prohibir que dos procesos accedan al mismo recurso. El modelo en cuesti\u00f3n se denomina exclusi\u00f3n mutua , explicado en el siguiente sub-apartado. Soluciones \u00b6 La soluci\u00f3n principal que se plantea para los casos anteriores es la exclusi\u00f3n mutua , explicada a continuaci\u00f3n. Exclusi\u00f3n mutua \u00b6 La Exclusi\u00f3n mutua evita que dos Procesos accedan a datos compartidos y los modifiquen simult\u00e1neamente, para ello utiliza La secci\u00f3n cr\u00edtica de un programa, la cual es la zona del programa en la que se puede modificar el recurso que comparten varios procesos, dependiendo de permisos preestablecidos. El siguiente esquema/resumen aclara estos conceptos: Resumen Exclusi\u00f3n Mutua Las soluciones de exclusi\u00f3n mutua con espera ocupada funcionan de la siguiente manera: Cuando un proceso intenta entrar a su regi\u00f3n cr\u00edtica, verifica si est\u00e1 permitida la entrada. Si no, el proceso se queda esperando hasta obtener el permiso. Tip Siguiendo la anterior premisa se destacan los siguientes m\u00e9todos: Desactivaci\u00f3n de interrupciones El m\u00e9todo m\u00e1s simple para evitar las condiciones de competencia es hacer que cada proceso desactive todas sus interrupciones antes de entrar a su secci\u00f3n cr\u00edtica y las active una vez que sali\u00f3 de la misma. De esta forma, no sale de la cpu hasta que no ha terminado la ejecuci\u00f3n del la secci\u00f3n cr\u00edtica. Este modelo tiene un gran problema y es que si se produce un fallo mientras que el proceso est\u00e1 en la regi\u00f3n cr\u00edtica no puede salir de la misma el sistema operativo no recuperar\u00eda el control. Sem\u00e1foros y variable cerradura : En \u00e9ste caso se genera una variable, con dos valores 0 o 1: 0 : no hay ning\u00fan proceso en su secci\u00f3n cr\u00edtica. 1 : indica que la secci\u00f3n cr\u00edtica est\u00e1 ocupada. Entonces cada proceso antes de ingresar a la secci\u00f3n cr\u00edtica verifica el estado de la variable de cerradura y en caso de que la misma este en 0, le cambia el valor y accede a la misma y en caso de que la misma sea 1 el proceso se queda esperando hasta que el mismo sea 0. El problema aqu\u00ed se presenta si dos procesos verifican al mismo tiempo que la variable cerradura ingresando a la regi\u00f3n cr\u00edtica al mismo tiempo. Alternancia estricta : El algoritmo de alternancia estricta no bloquea el acceso a la regi\u00f3n cr\u00edtica cuando otro proceso se est\u00e1 ejecutando, sino que coge el recurso para s\u00ed durante toda la ejecuci\u00f3n del programa. Esta soluci\u00f3n requiere que los dos procesos se alternen de manera estricta. Su desventaja es que acopla los procesos fuertemente, esto significa que los procesos lentos atrasan a los procesos r\u00e1pidos.. Monitores : Un monitor es una colecci\u00f3n de procedimientos, variables y estructuras de datos que est\u00e1n todos agrupados juntos en un tipo especial de m\u00f3dulo o paquete. Para poder acceder a un recurso , el proceso debe utilizar obligatoriamente los procedimientos del monitor, y este se encarga de realizar la exclusi\u00f3n mutua del recurso. Herramientas gr\u00e1ficas \u00b6 En GNU/Linux existen diversas herramientas gr\u00e1ficas para obtener informaci\u00f3n de los distintos procesos o programas activos. Como existen varios servidores gr\u00e1ficos: KDE, GNOME, etc. Se destacan dos: ksysguard para KDE y gnome-system-monitor para GNOME. En Debian/ubuntu la herramienta gr\u00e1fica se encuentra en aplicaciones > herramientas del sistema > monitor del sistema . En el caso de Windows , existe en el administrador de tareas, sobre la pesta\u00f1a \" rendimiento \". Luego pulsaremos abajo en el enlace de \" monitor de recursos \". En esta nueva ventana tendremos dividido cada proceso en consumo de la CPU y en sub-procesos (threads). Monitor de recursos (Windows) En el monitor de actividad de Mac, se muestran directamente los sub-procesos enumerados en la pantalla principal. Monitor de actividad (Mac) Actividades \u00b6 Investiga y analiza las diferentes funciones de las herramientas gr\u00e1ficas para identificar y gestionar procesos e hilos de ubuntu client y Windows 10. Genera m\u00e1quinas virtuales de los respectivos Sistemas Operativos si fuera necesario. Se debe realizar un informe al menos con la b\u00fasqueda y resultado de las siguientes funciones (se debe especificar c\u00f3mo se realizan): Identificar : entre procesos e hilos. Detener : cuando detiene un proceso se est\u00e1 indicando al sistema operativo que pause la ejecuci\u00f3n de ese programa. Continuar : use esta opci\u00f3n para reiniciar un proceso que se paus\u00f3 o detuvo. Finalizar : para finalizar un proceso de forma limpia. Matar : finaliza un proceso inmediatamente sin tener en cuenta si termina limpiamente. Cambiar : la prioridad del proceso. NOTA Si alguna de las funciones no existe en las herramientas gr\u00e1ficas, simplemente se indicar\u00e1 en el informe como que no es posible realizarla, justific\u00e1ndolo. La mayor\u00eda de los procesos tendr\u00e1n la prioridad predeterminada establecida en Normal ( 0 ). En Linux, los n\u00fameros que van de -20 a +19 representan la prioridad del proceso. Cuanto menor sea el n\u00famero de prioridad del proceso, m\u00e1s prioridad tendr\u00e1 en la CPU. Por ejemplo, un proceso con una prioridad de -3 tendr\u00e1 m\u00e1s tiempo de CPU que otro proceso con una prioridad de 6.","title":"3.2- Hilos, Sincronizaci\u00f3n e interrupciones, Herramientas gr\u00e1ficas"},{"location":"03_Procesos/032_Hilos.html#hilos","text":"","title":"Hilos"},{"location":"03_Procesos/032_Hilos.html#definicion","text":"Un hilo o hebra (Thread), proceso ligero o subproceso es la secuencia de instrucciones m\u00e1s elemental, que puede ser gestionada por el planificador . NOTA A priori los procesos pueden ejecutarse como un solo hilo , es decir, las instrucciones v\u00e1n siguiendo un orden y nunca se pueden ejecutar a la vez dos instrucciones del mismo proceso. El concepto de multihilo consiste en que partes del mismo proceso pueden ejecutarse en paralelo, es decir , el mismo programa tiene partes que pueden ejecutarse a la vez. De este modo, se puede ahorrar tiempo. Por ejemplo, un navegador de internet puede tener varios hilos, uno muestra las im\u00e1genes mientras otro recupera datos de la red. Estados en los que puede estar los procesos e hilos en el navegador. NOTA Es f\u00e1cil confundir hilos y procesos. La diferencia principal es que un proceso tiene asignado un un BCP y los hilos son parte del mismo proceso. Esto significa entre otras cosas que la memoria que se asigna al proceso la compartir\u00e1n todos los hilos. Tambi\u00e9n comparten el resto de recursos como ficheros abiertos, etc. Por lo tanto si uno de los hilos modifica un recurso o una variable de memoria, el cambio afectar\u00e1 al resto de hilos del proceso. Debido a esto es importante la sincronizaci\u00f3n entre hilos . Cada hilo tendr\u00e1 un identificador, un contador de programa y una pila propias. Se pueden distinguir los siguientes tipos de hilos: Hilos a nivel de usuario : Son los que crean los programadores y de los cuales el kernel o n\u00facleo del sistema no es consciente de que existan, por lo que el propio programador debe encargarse de la sincronizaci\u00f3n de estos. Hilos a nivel de kernel : Estos son gestionados por el sistema operativo, por lo que si tenemos un procesador con varios n\u00facleos y /o varios procesadores, se acelerar\u00e1 la ejecuci\u00f3n del proceso . El sistema operativo se encarga del cambio entre hilos. Adem\u00e1s contamos con sistemas operativos que son capaces de gestionar hilos (a nivel de kernel , claro) y sistemas operativos que no lo son. Estados en los que puede estar un proceso","title":"Definici\u00f3n"},{"location":"03_Procesos/032_Hilos.html#ventajas-de-los-hilos-frente-a-los-procesos","text":"Los hilos son mucho m\u00e1s ligeros que los procesos. En la creaci\u00f3n de procesos se necesita un tiempo para la adjudicaci\u00f3n de memoria y de recursos que no es necesaria en el caso de cambio entre hilos. Tambi\u00e9n el cambio de contexto es mucho m\u00e1s \"Pesado\" en el caso de los procesos. La utilizaci\u00f3n de hilos hace que los procesos sean m\u00e1s \u00e1giles , debido a que si una de las partes del proceso se bloquea esperando un recurso, otra en otro hilo puede avanzar con otras tareas. En caso de procesadores multin\u00facleo o sistemas multiprocesador, la eficiencia de los procesos que utilizan hilos es evidente, al poder realizar varias tareas realmente en paralelo (un hilo en cada procesador). INFO Un proceso multihilo no desaparece hasta que no han terminado todos sus hilos.","title":"Ventajas de los hilos frente a los procesos"},{"location":"03_Procesos/032_Hilos.html#sincronizacion-y-comunicacion-entre-procesos","text":"Hay procesos independientes y otros que deben comunicarse y sincronizarse con otros. En este caso se utilizan se\u00f1ales para enviar informaci\u00f3n entre procesos , y de este modo poder gestionar recursos y zonas de memoria compartida. Ejemplo Un proceso (P1) puede necesitar un dato que otro proceso (P2) produce y hasta que esto no ocurra, no podr\u00e1 continuar con su ejecuci\u00f3n. En este caso el proceso P1 se quedar\u00e1 bloqueado hasta que reciba una se\u00f1al que le enviar\u00e1 P2, indic\u00e1ndole que ya tiene disponible el dato. Consejo Antes de conocer diferentes casos problem\u00e1ticos y sus posibles soluciones se debe conocer los siguientes elementos que interact\u00faan en la comunicaci\u00f3n de procesos.","title":"Sincronizaci\u00f3n y Comunicaci\u00f3n entre procesos"},{"location":"03_Procesos/032_Hilos.html#mensajes","text":"Cuando los procesos tienen que compartir informaci\u00f3n, incluso en equipos remotos, pueden utilizar colas de mensajes para enviarla. Los procesos introducen y extraen los mensajes, con la informaci\u00f3n necesaria a enviar al proceso o entidad que se necesite en cada caso. Existen varios \"tipos\" de mensajes distintos, de forma que cada tipo de mensaje contiene una informaci\u00f3n distinta y va identificado por un entero.","title":"Mensajes"},{"location":"03_Procesos/032_Hilos.html#senales","text":"Las se\u00f1ales se utilizan para sincronizar procesos. Cada se\u00f1al tiene un comportamiento por defecto, como puede ser pausar un proceso o pararlo. La mayor\u00eda de ellas pueden ser tratadas de forma que el programa la recoja y realice una serie de instrucciones cuando esta llegue. Ejemplo Hay formas de pasar se\u00f1ales al sistema operativo, por ejemplo, cuando pulsamos control+C, o utilizando funciones del sistema para enviar una determinada se\u00f1al a un proceso para modificar la forma de actuar de \u00e9ste en ese momento dado.","title":"Se\u00f1ales"},{"location":"03_Procesos/032_Hilos.html#interrupciones-y-excepciones","text":"Una Interrupci\u00f3n es una se\u00f1al que env\u00eda un dispositivo de E/S al procesador para pedir que se le atienda. Cada interrupci\u00f3n tiene asociada una rutina que debe pasar a ejecutarse cuando esta se produzca. Tambi\u00e9n existen las interrupciones de Software, que env\u00edan los programas de usuario al sistema operativo para requerir su atenci\u00f3n. El siguiente esquema muestra un resumen del concepto de Interrupci\u00f3n. Resumen Interrupci\u00f3n NOTA Una excepci\u00f3n se produce cuando hay una instrucci\u00f3n err\u00f3nea en un programa, por ejemplo, una divisi\u00f3n por 0. En ese momento el sistema operativo debe realizar las acciones oportunas. En ciertos intervalos de tiempo puede convenir no aceptar se\u00f1ales de interrupci\u00f3n. Por ello las interrupciones pueden inhibirse por software, seg\u00fan lo necesite el sistema.","title":"Interrupciones y excepciones"},{"location":"03_Procesos/032_Hilos.html#casos-y-soluciones-de-sincronizacion","text":"Una vez conocidos los elementos que se relacionan en la sincronizaci\u00f3n, en los siguientes apartados se muestran varias situaciones en los que se evidencia la necesidad de sincronizaci\u00f3n entre procesos, por problemas de acceso a recursos compartidos y las principales posibles soluciones planteadas.","title":"Casos y soluciones de sincronizaci\u00f3n"},{"location":"03_Procesos/032_Hilos.html#casos-de-necesidad-de-sincronizacion","text":"","title":"Casos de necesidad de sincronizaci\u00f3n"},{"location":"03_Procesos/032_Hilos.html#soluciones","text":"La soluci\u00f3n principal que se plantea para los casos anteriores es la exclusi\u00f3n mutua , explicada a continuaci\u00f3n.","title":"Soluciones"},{"location":"03_Procesos/032_Hilos.html#herramientas-graficas","text":"En GNU/Linux existen diversas herramientas gr\u00e1ficas para obtener informaci\u00f3n de los distintos procesos o programas activos. Como existen varios servidores gr\u00e1ficos: KDE, GNOME, etc. Se destacan dos: ksysguard para KDE y gnome-system-monitor para GNOME. En Debian/ubuntu la herramienta gr\u00e1fica se encuentra en aplicaciones > herramientas del sistema > monitor del sistema . En el caso de Windows , existe en el administrador de tareas, sobre la pesta\u00f1a \" rendimiento \". Luego pulsaremos abajo en el enlace de \" monitor de recursos \". En esta nueva ventana tendremos dividido cada proceso en consumo de la CPU y en sub-procesos (threads). Monitor de recursos (Windows) En el monitor de actividad de Mac, se muestran directamente los sub-procesos enumerados en la pantalla principal. Monitor de actividad (Mac)","title":"Herramientas gr\u00e1ficas"},{"location":"03_Procesos/032_Hilos.html#actividades","text":"Investiga y analiza las diferentes funciones de las herramientas gr\u00e1ficas para identificar y gestionar procesos e hilos de ubuntu client y Windows 10. Genera m\u00e1quinas virtuales de los respectivos Sistemas Operativos si fuera necesario. Se debe realizar un informe al menos con la b\u00fasqueda y resultado de las siguientes funciones (se debe especificar c\u00f3mo se realizan): Identificar : entre procesos e hilos. Detener : cuando detiene un proceso se est\u00e1 indicando al sistema operativo que pause la ejecuci\u00f3n de ese programa. Continuar : use esta opci\u00f3n para reiniciar un proceso que se paus\u00f3 o detuvo. Finalizar : para finalizar un proceso de forma limpia. Matar : finaliza un proceso inmediatamente sin tener en cuenta si termina limpiamente. Cambiar : la prioridad del proceso. NOTA Si alguna de las funciones no existe en las herramientas gr\u00e1ficas, simplemente se indicar\u00e1 en el informe como que no es posible realizarla, justific\u00e1ndolo. La mayor\u00eda de los procesos tendr\u00e1n la prioridad predeterminada establecida en Normal ( 0 ). En Linux, los n\u00fameros que van de -20 a +19 representan la prioridad del proceso. Cuanto menor sea el n\u00famero de prioridad del proceso, m\u00e1s prioridad tendr\u00e1 en la CPU. Por ejemplo, un proceso con una prioridad de -3 tendr\u00e1 m\u00e1s tiempo de CPU que otro proceso con una prioridad de 6.","title":"Actividades"},{"location":"03_Procesos/033B_GestionProcesosGlobal.html","text":"Gesti\u00f3n de procesos en los Sistemas Opertivos. \u00b6 Gesti\u00f3n de procesos de Linux. \u00b6 Un proceso en Linux es, en resumen, un programa en ejecuci\u00f3n. Un proceso puede crear a su vez otros procesos. Al proceso que genera otro proceso se le llama proceso padre. Al proceso generado por otro proceso se le llama proceso hijo. Los procesos pueden ser padres e hijos y adem\u00e1s, varios procesos pueden ser hijos del mismo padre a la vez. Veamos un ejemplo. Note El terminal o consola es un proceso , ya que se trata de un programa que ejecutamos. Si en el terminal escribimos, por ejemplo, el comando \u201cls -l\u201d, se estar\u00eda generando un nuevo proceso que ser\u00eda proceso hijo del terminal. En este caso el shell ser\u00eda el proceso padre y el comando \u201cls -l\u201d ser\u00eda el proceso hijo. Resumen de comandos de manejo de procesos Ejemplo de Multiprogramaci\u00f3n Trabajando con procesos. \u00b6 El comando ps. \u00b6 El comando ps proporciona informaci\u00f3n sobre los procesos que se est\u00e1n ejecutando en el sistema. Si escribimos en el terminal ps , obtendremos como salida un listado de los procesos lanzados con el usuario actual que a\u00fan se est\u00e1n ejecutando. Veamos qu\u00e9 significan cada una de las columnas que se muestran cuando ejecutamos el comando ps. La primera columna es el PID o identificador de proceso. Cada proceso tiene un asociado identificador que es \u00fanico, es decir que no puede haber dos procesos con el mismo identificador. La segunda columna nos informa del terminal en el que se est\u00e1 ejecutando el proceso. Si aparece una interrogaci\u00f3n (?), el proceso no tiene asociada ninguna terminal. La tercera columna indica el tiempo total que ha estado ejecut\u00e1ndose el proceso. La cuarta columna es el nombre del proceso. En la imagen anterior observamos que hay dos procesos corriendo: el bash, que es el shell o int\u00e9rprete de comandos, y el comando ps. El comando ps admite algunos par\u00e1metros/modificadores : -e devuelve un listado de todos los procesos que se est\u00e1n ejecutando. -f devuelve un listado extendido. En este \u00faltimo caso veremos en pantalla el PPID del proceso (identificador del proceso padre) y la hora en la que se ejecut\u00f3 el proceso (STIME). -ef obtendr\u00edamos un listado extendido de todos los procesos que se est\u00e1n ejecutando en el sistema. -u informa de los procesos lanzado por un determinado usuario. De tal forma que si escribimos \u201c ps -u alex \u201d, aparecer\u00e1 un listado de los procesos que est\u00e1 ejecutando el usuario alex. El comando pstree \u00b6 El comando pstree visualiza, en forma de \u00e1rbol, todos los procesos del sistema. As\u00ed podemos ver las relaciones que existen entre los procesos. El comando top \u00b6 El comando top devuelve un listado de los procesos de forma parecida a como lo hace ps, con la diferencia que la informaci\u00f3n mostrada se va actualizando peri\u00f3dicamente lo que nos permite ver la evoluci\u00f3n del estado de los procesos. Adem\u00e1s, en la parte superior muestra informaci\u00f3n adicional, como el espacio en memoria ocupado por los procesos, el espacio ocupado por la memoria de intercambio o swap, el n\u00famero total de tareas o procesos que se est\u00e1n ejecutando, el n\u00famero de usuarios o el porcentaje de uso del procesador. Note Mientras el comando top est\u00e1 en marcha podremos cambiar f\u00e1cilmente la prioridad de los procesos. A modo de resumen cada proceso en Linux tiene un nivel de prioridad que va de -20 (prioridad m\u00e1s alta) hasta 20 (prioridad m\u00e1s baja). Cuanto mayor sea el nivel de prioridad, m\u00e1s lentamente se ejecutar\u00e1 el proceso. \u00bfY c\u00f3mo podemos cambiar con top la prioridad de un proceso? Muy sencillo. Con el comando top en marcha pulsamos la tecla \"r\" . A continuaci\u00f3n introducimos el PID del proceso al que vamos a cambiar la prioridad, y acto seguido el nivel de prioridad que vamos a asignar. Debemos tener en cuenta una consideraci\u00f3n, solamente el superusuario \"root\" puede asignar valores negativos a la prioridad de un proceso. Procesos en primer plano y segundo plano \u00b6 Los procesos pueden ejecutarse en primer plano o segundo plano. El proceso que est\u00e1 en primer plano es aquel con el que se interact\u00faa. Si ejecutamos, por ejemplo, el comando ls -l , se mostrar\u00e1 por pantalla el resultado, y hasta que no acabe de mostrarse el listado no podremos ejecutar ning\u00fan otro comando. En este caso el terminal permanece bloqueado, sin poder introducir ning\u00fan otro comando, hasta que el proceso en primer plano termine. Pondremos un proceso en segundo plano a\u00f1adiendo el s\u00edmbolo ampersand (&) al final del comando. Cuando se ejecuta un proceso en segundo plano, se permite al usuario iniciar y trabajar con otros procesos. Ejemplo: $ sleep 10 & El comando sleep simplemente espera el n\u00famero de segundos que le pasemos como par\u00e1metro. En la imagen anterior se observa que al ejecutar un proceso en segundo plano se devuelve un n\u00famero entre corchetes seguido de otro n\u00famero. El n\u00famero entre corchetes indica el n\u00famero de procesos que se tienen ejecut\u00e1ndose en segundo plano. El segundo n\u00famero es el PID o identificador del proceso. Para ver que trabajos se est\u00e1n ejecutando en segundo plano, se usa el comando jobs . El signo + seguido del n\u00famero de trabajo entre corchetes indica el trabajo m\u00e1s reciente que se est\u00e1 ejecutando. El signo menos indica el siguiente trabajo m\u00e1s reciente. Pasar procesos en segundo plano a primer plano \u00b6 Para pasar procesos en segundo plano a primer plano, se utiliza el comando fg, seguido de %n, donde n es el n\u00famero de proceso que queremos pasar a primer plano. Por ejemplo, fg %1 pondr\u00eda en primer plano la tarea n\u00famero 1. En la siguiente imagen se ejecuta sleep 80 en segundo plano, y despu\u00e9s pasa a primer plano con el comando fg. Pasar procesos en primer plano a segundo plano \u00b6 El comando bg permite pasar procesos desde primer plano a segundo plano. Para pasar un proceso que se encuentra en primer plano a segundo plano, debemos suspenderlo primero utilizando la combinaci\u00f3n de teclas Ctrl+Z. Cuando se pulsa esa combinaci\u00f3n de teclas, el proceso en ejecuci\u00f3n se para y no vuelve a ejecutarse hasta que se pasa a primer o segundo plano. Con bg pasaremos el proceso a segundo plano. Cambiando la prioridad de los procesos \u00b6 Como anteriormente se ha comentado antes, cada proceso en Linux tiene un nivel de prioridad que oscila entre -20 (prioridad m\u00e1s alta) y 20 (prioridad m\u00e1s baja). Cuanto mayor sea el nivel de prioridad, m\u00e1s lentamente se ejecutar\u00e1 el proceso. Solamente el superusuario \u2018root\u2019 puede asignar valores negativos a la prioridad de un proceso. Para asignar determinada prioridad a un proceso en concreto se utiliza el comando nice . nice prioridad proceso \u00b6 Podemos cambiar la prioridad de un proceso con el comando renice . Este comando admite los siguientes par\u00e1metros/modificadores: -g . Establece el nivel de prioridad de los procesos ejecutados por los miembros del grupo especificado. -u . Establece el nivel de prioridad de los procesos ejecutados por los miembros del usuario especificado. -p . Indica el nivel de prioridad para el proceso especificado. Finalizar procesos Para finalizar un proceso se utiliza el comando kill , que tiene la siguiente sintaxis: kill [par\u00e1metro] PID Si, por ejemplo, queremos eliminar un proceso con PID 17122, tendr\u00edamos que escribir: kill 17122.Puede que en ocasiones el proceso no finalice al emplear el comando kill sin par\u00e1metros. Para matar un proceso asegur\u00e1ndonos de que no ignorar\u00e1 la petici\u00f3n de finalizar su ejecuci\u00f3n se emplea el par\u00e1metro -9. kill -9 17122 Hay un total de 32 se\u00f1ales que se pueden enviar a los procesos. Las m\u00e1s utilizadas son las siguientes: - kill -1 (Sighup). Reinicia el proceso. - kill -9 (SigKill). Mata el proceso. - kill -15 (SigTerm). Termina el proceso. Por otra parte, el comando killall nombre_programa finaliza todos los procesos que est\u00e9n ejecutando el programa. Gesti\u00f3n de procesos con Powershell. \u00b6 Obtener procesos (Get-Process) \u00b6 Para obtener los procesos que se est\u00e1n ejecutando en el equipo local, ejecute Get-Process sin par\u00e1metros. Puede obtener determinados procesos especificando sus nombres de proceso o identificadores de proceso. El siguiente comando obtiene el proceso inactivo: Get-Process -id 0 La salida de este comando seria: Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 0 0 0 16 0 0 Idle Note Aunque es normal que los cmdlets no devuelvan datos en algunas situaciones, cuando se especifica un proceso por su id. de proceso Get-Process , genera un error si no encuentra ninguna coincidencia, porque la intenci\u00f3n habitual consiste en recuperar un proceso en ejecuci\u00f3n conocido. Si no hay ning\u00fan proceso con ese identificador, es probable que el identificador sea incorrecto o que el proceso de inter\u00e9s haya terminado: Get-Process -Id 99 La salida de este comando seria: Get-Process : No process with process ID 99 was found. At line:1 char:12 + Get-Process <<<< -Id 99 Tip Puede usar el par\u00e1metro Name del cmdlet Get-Process para especificar un subconjunto de procesos basado en el nombre del proceso. El par\u00e1metro Name puede tomar varios nombres de una lista de nombres separados por comas y admite el uso de caracteres comod\u00edn, para que pueda escribir patrones de nombre. Por ejemplo, el siguiente comando obtiene el proceso cuyos nombres comienzan por \"ex\". Get-Process -Name ex* La salida de este comando seria: Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 234 7 5572 12484 134 2.98 1684 EXCEL 555 15 34500 12384 134 105.25 728 explorer Note Dado que la clase System.Diagnostics.Process de .NET es la base de los procesos de Windows PowerShell, sigue algunas de las convenciones usadas por System.Diagnostics.Process. Una de estas convenciones es que el nombre de proceso de un archivo ejecutable nunca incluya \".exe\" al final del nombre del ejecutable. Get-Process tambi\u00e9n acepta varios valores para el par\u00e1metro Name. Get-Process -Name exp*,power* La salida de este comando seria: Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 540 15 35172 48148 141 88.44 408 explorer 605 9 30668 29800 155 7.11 3052 powershell Puede usar el par\u00e1metro ComputerName de Get-Process para obtener procesos en equipos remotos. Por ejemplo, el comando siguiente obtiene los procesos de PowerShell en el equipo local (representado por \"localhost\") y en dos equipos remotos. Get-Process -Name PowerShell -ComputerName localhost, Server01, Server02 La salida de este comando seria: Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 258 8 29772 38636 130 3700 powershell 398 24 75988 76800 572 5816 powershell 605 9 30668 29800 155 7.11 3052 powershell Los nombres de equipo no son evidentes en esta presentaci\u00f3n, pero se almacenan en la propiedad MachineName de los objetos de proceso que devuelve Get-Process . El siguiente comando usa el cmdlet Format-Table para mostrar el identificador de proceso y las propiedades ProcessName y MachineName(ComputerName) de los objetos de proceso. Get-Process -Name PowerShell -ComputerName localhost, Server01, Server01 | Format-Table -Property ID, ProcessName, MachineName La salida de este comando seria: Id ProcessName MachineName -- ----------- ----------- 3700 powershell Server01 3052 powershell Server02 5816 powershell localhost Este comando m\u00e1s complejo agrega la propiedad MachineName a la presentaci\u00f3n est\u00e1ndar de Get-Process . PowerShellCopiar Get-Process powershell -ComputerName localhost, Server01, Server02 | Format-Table -Property Handles, @{Label=\"NPM(K)\";Expression={[int]($_.NPM/1024)}}, @{Label=\"PM(K)\";Expression={[int]($_.PM/1024)}}, @{Label=\"WS(K)\";Expression={[int]($_.WS/1024)}}, @{Label=\"VM(M)\";Expression={[int]($_.VM/1MB)}}, @{Label=\"CPU(s)\";Expression={if ($_.CPU -ne $()){$_.CPU.ToString(\"N\")}}}, Id, ProcessName, MachineName -auto La salida de este comando seria: Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName MachineName ------- ------ ----- ----- ----- ------ -- ----------- ----------- 258 8 29772 38636 130 3700 powershell Server01 398 24 75988 76800 572 5816 powershell localhost 605 9 30668 29800 155 7.11 3052 powershell Server02 Detener procesos (Stop-Process) \u00b6 El cmdlet Stop-Process toma un nombre o un identificador para especificar un proceso que quiere detener. Su capacidad para detener procesos depender\u00e1 de sus permisos. Algunos procesos no se pueden detener. Por ejemplo, si intenta detener el proceso inactivo, obtendr\u00e1 un error: Stop-Process -Name Idle La salida de este comando seria: Stop-Process : Process 'Idle (0)' cannot be stopped due to the following error : Access is denied At line:1 char:13 + Stop-Process <<<< -Name Idle Tambi\u00e9n puede forzar la solicitud con el par\u00e1metro Confirm . Este par\u00e1metro es especialmente \u00fatil si se usa un car\u00e1cter comod\u00edn al especificar el nombre del proceso, ya que accidentalmente podr\u00eda coincidir con algunos procesos que no quiere detener: Stop-Process -Name t*,e* -Confirm La salida de este comando seria: Confirm Are you sure you want to perform this action? Performing operation \"Stop-Process\" on Target \"explorer (408)\". [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is \"Y\"):n Confirm Are you sure you want to perform this action? Performing operation \"Stop-Process\" on Target \"taskmgr (4072)\". [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is \"Y\"):n La manipulaci\u00f3n de procesos complejos es posible si se usan algunos cmdlets de filtrado de objetos. Dado que un objeto Process tiene una propiedad Responding que es true cuando ya no responde, puede detener todas las aplicaciones que no respondan con el comando siguiente: Get-Process | Where-Object -FilterScript {$_.Responding -eq $false} | Stop-Process Puede usar el mismo enfoque en otras situaciones. Por ejemplo, supongamos que una aplicaci\u00f3n de \u00e1rea de notificaciones secundaria se ejecuta autom\u00e1ticamente cuando los usuarios inician otra aplicaci\u00f3n. Es posible que esto no funcione correctamente en las sesiones de Terminal Services (Terminales de Servicios de Escritorio Remoto), pero lo quiera seguir manteniendo en las sesiones que se ejecutan en la consola del equipo f\u00edsico. Las sesiones conectadas en el escritorio del equipo f\u00edsico siempre tienen un identificador de la sesi\u00f3n 0, por lo que puede detener todas las instancias del proceso que est\u00e1n en otras sesiones mediante Where-Object y el proceso, SessionId : Get-Process -Name BadApp | Where-Object -FilterScript {$_.SessionId -neq 0} | Stop-Process El cmdlet Stop-Process no tiene un par\u00e1metro ComputerName. Por lo tanto, para ejecutar un comando para detener un proceso en un equipo remoto, debe usar el cmdlet Invoke-Command . Por ejemplo, para detener el proceso de PowerShell en el equipo remoto Server01, escriba: Invoke-Command -ComputerName Server01 {Stop-Process Powershell} Detener todas las dem\u00e1s sesiones de Windows PowerShell \u00b6 En ocasiones puede ser \u00fatil poder detener todas las sesiones de Windows PowerShell que se est\u00e1n ejecutando, excepto la sesi\u00f3n actual. Si una sesi\u00f3n usa demasiados recursos o es inaccesible (quiz\u00e1s se est\u00e9 ejecutando de forma remota o en otra sesi\u00f3n de escritorio), es posible que no pueda detenerla directamente. Si intenta detener todas las sesiones que se est\u00e1n ejecutando, la sesi\u00f3n actual podr\u00eda finalizar en su lugar. Cada sesi\u00f3n de Windows PowerShell tiene un PID de variable de entorno que contiene el identificador del proceso de Windows PowerShell. Puede comprobar el $PID con el identificador de cada sesi\u00f3n y finalizar solo las sesiones de Windows PowerShell que tengan un identificador diferente. El siguiente comando de canalizaci\u00f3n realiza esta acci\u00f3n y devuelve la lista de las sesiones finalizadas (debido al uso del par\u00e1metro PassThru ): Get-Process -Name powershell | Where-Object -FilterScript {$_.Id -ne $PID} | Stop-Process -PassThru La salida de este comando seria: Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 334 9 23348 29136 143 1.03 388 powershell 304 9 23152 29040 143 1.03 632 powershell 302 9 20916 26804 143 1.03 1116 powershell 335 9 25656 31412 143 1.09 3452 powershell 303 9 23156 29044 143 1.05 3608 powershell 287 9 21044 26928 143 1.02 3672 powershell Iniciar, depurar y esperar procesos \u00b6 Windows PowerShell tambi\u00e9n incluye cmdlets para iniciar (o reiniciar) y depurar un proceso, as\u00ed como para esperar a que un proceso se complete antes de ejecutar un comando. Se pueden realizar con los siguientes cmdlets. Start-Process Wait-Process Debug-Process Invoke-Command Actividades de desarrollo UD3_01 ShellScripting \u00b6 Realiza un script de Shell que encuentre todos los procesos activos e imprima por pantalla al usuario la pol\u00edtica de programaci\u00f3n. Modifica el script anterior para que de la opci\u00f3n al usuario de aumentar o disminuir la prioridad de un proceso, a elegir por el usuario ambas variables. Modifica el script anterior para que de la opci\u00f3n al usuario de matar un proceso, a elegir por el usuario. Actividades UD03_02 PowerShell \u00b6 Realiza un script en PoserShell que realice los siguientes puntos: Cuenta el n\u00famero de procesos en ejecuci\u00f3n en el sistema, y los muestre por pantalla. Ver que programas se ejecutan en el inicio de sesi\u00f3n y los muestre por pantalla. Guardar los un listado de los procesos en un csv e Imprima por plantilla el archivo. Realiza un script en PoserShell que realice los siguientes puntos: Lista los procesos que tengan un alto consumo de CPU. Detenga el proceso con mayor consumo. Mostrar los procesos cuya zona de memoria para trabajar sea mayor que 100 MB y a continuaci\u00f3n los detenga.","title":"Gesti\u00f3n de procesos en los Sistemas Opertivos."},{"location":"03_Procesos/033B_GestionProcesosGlobal.html#gestion-de-procesos-en-los-sistemas-opertivos","text":"","title":"Gesti\u00f3n de procesos en los Sistemas Opertivos."},{"location":"03_Procesos/033B_GestionProcesosGlobal.html#gestion-de-procesos-de-linux","text":"Un proceso en Linux es, en resumen, un programa en ejecuci\u00f3n. Un proceso puede crear a su vez otros procesos. Al proceso que genera otro proceso se le llama proceso padre. Al proceso generado por otro proceso se le llama proceso hijo. Los procesos pueden ser padres e hijos y adem\u00e1s, varios procesos pueden ser hijos del mismo padre a la vez. Veamos un ejemplo. Note El terminal o consola es un proceso , ya que se trata de un programa que ejecutamos. Si en el terminal escribimos, por ejemplo, el comando \u201cls -l\u201d, se estar\u00eda generando un nuevo proceso que ser\u00eda proceso hijo del terminal. En este caso el shell ser\u00eda el proceso padre y el comando \u201cls -l\u201d ser\u00eda el proceso hijo. Resumen de comandos de manejo de procesos Ejemplo de Multiprogramaci\u00f3n","title":"Gesti\u00f3n de procesos de Linux."},{"location":"03_Procesos/033B_GestionProcesosGlobal.html#trabajando-con-procesos","text":"","title":"Trabajando con procesos."},{"location":"03_Procesos/033B_GestionProcesosGlobal.html#gestion-de-procesos-con-powershell","text":"","title":"Gesti\u00f3n de procesos con Powershell."},{"location":"03_Procesos/033B_GestionProcesosGlobal.html#actividades-de-desarrollo-ud3_01-shellscripting","text":"Realiza un script de Shell que encuentre todos los procesos activos e imprima por pantalla al usuario la pol\u00edtica de programaci\u00f3n. Modifica el script anterior para que de la opci\u00f3n al usuario de aumentar o disminuir la prioridad de un proceso, a elegir por el usuario ambas variables. Modifica el script anterior para que de la opci\u00f3n al usuario de matar un proceso, a elegir por el usuario.","title":"Actividades de desarrollo UD3_01 ShellScripting"},{"location":"03_Procesos/033B_GestionProcesosGlobal.html#actividades-ud03_02-powershell","text":"Realiza un script en PoserShell que realice los siguientes puntos: Cuenta el n\u00famero de procesos en ejecuci\u00f3n en el sistema, y los muestre por pantalla. Ver que programas se ejecutan en el inicio de sesi\u00f3n y los muestre por pantalla. Guardar los un listado de los procesos en un csv e Imprima por plantilla el archivo. Realiza un script en PoserShell que realice los siguientes puntos: Lista los procesos que tengan un alto consumo de CPU. Detenga el proceso con mayor consumo. Mostrar los procesos cuya zona de memoria para trabajar sea mayor que 100 MB y a continuaci\u00f3n los detenga.","title":"Actividades UD03_02 PowerShell"},{"location":"03_Procesos/033C_Sobras.html","text":"En Debian el nivel de inicio predeterminado es el nivel 2 (id=2). Debian utiliza los siguientes niveles de ejecuci\u00f3n: 0 (apagar el sistema) 1 (modo monousuario) 2 al 5 (modos multiusuario) 6 (reiniciar el sistema) Note El archivo de configuraci\u00f3n de m\u00e1s alto nivel para Init es /etc/inittab .Durante el arranque del sistema, se verifica si existe un nivel de ejecuci\u00f3n predeterminado en el archivo /etc/inittab , si no, se debe introducir por medio de la consola del sistema. Despu\u00e9s se procede a ejecutar todos los scripts relativos al nivel de ejecuci\u00f3n especificado. Despu\u00e9s de que se han dado lugar todos los procesos especificados, Init se aletarga, y espera a que uno de estos tres eventos sucedan: - que procesos comenzados finalicen o mueran; - un fallo de la se\u00f1al de potencia (energ\u00eda); - o una petici\u00f3n a trav\u00e9s de /sbin/telinit para cambiar el nivel de ejecuci\u00f3n. ARRANQUE WINDOWS Los datos de configuraci\u00f3n de arranque ( BCD ) sustituyen a la anterior (boot.ini). En el almac\u00e9n BCD el gestor de arranque se presenta como objeto de programa ( GUID ) en lugar de elementos de texto. Con la herramienta Bcdedit.exe podemos utilizar los comandos b\u00e1sicos para controlar todos los aspectos del proceso de arranque, aunque cada objeto se presenta con un GUID , algunos objetos tienen nombres de alias para uso com\u00fan, como bootmgr (referido al gestor de arranque) y DEFAULT (gestor de arranque por defecto). Podemos modificar la configuraci\u00f3n de inicio con WMI (Windows Management Instrumentati\u00f3n). Podemos utilizar MSconfig.exe para proporcionar una interfaz gr\u00e1fica para visualizar y modificar un subconjunto de los ajustes de configuraci\u00f3n de inicio. Actividades: Modifica el fichero /etc/inittab para que... De forma predeterminada se establezca el nivel de ejecuci\u00f3n 5. Al pulsar la combinaci\u00f3n de teclas ctrl+alt+supr el sistema realice las siguientes operaciones: se apague si el nivel de ejecuci\u00f3n es el 2. se reinicie si el nivel de ejecuci\u00f3n es el 3. escriba \u201cJe-je-je, no sirve de nada esa combinaci\u00f3n de teclas\u201d si el nivel de ejecuci\u00f3n es el 4. no haga nada si el nivel de ejecuci\u00f3n es el 5. Pista: Fases Arranque Linux Realiza un breve informe con los pasos m\u00e1s importantes de el Ejemplo de modificaci\u00f3n de bcdedit -> Enlace:Ejemplos de parametros usados en el editor BCDEdit.exe","title":"033C Sobras"},{"location":"03_Procesos/033_GestionProcesosShell.html","text":"Gesti\u00f3n de procesos en Shell de Linux \u00b6 Introducci\u00f3n \u00b6 Como se ha comentado en sesiones anteriores un proceso en Linux es un programa en ejecuci\u00f3n, el cual puede crear a su vez otros procesos y se caracteriza por: El proceso que genera otro proceso se le llama proceso padre . El proceso generado por otro proceso se le llama proceso hijo . Los procesos pueden ser padres e hijos y adem\u00e1s, varios procesos pueden ser hijos del mismo padre a la vez. Ejemplo El terminal o consola es un proceso , ya que se trata de un programa que ejecutamos. Si en el terminal escribimos, por ejemplo, el comando \u201cls -l\u201d, se estar\u00eda generando un nuevo proceso que ser\u00eda proceso hijo del terminal. En este caso el shell ser\u00eda el proceso padre y el comando \u201cls -l\u201d ser\u00eda el proceso hijo . A continuaci\u00f3n se muestra una tabla resumen de comandos para la gesti\u00f3n de procesos: Tabla resumen de comandos de gesti\u00f3n de procesos en bash Trabajando con procesos \u00b6 El comando ps \u00b6 El comando ps proporciona informaci\u00f3n sobre los procesos que se est\u00e1n ejecutando en el sistema. Si escribimos en el terminal ps , obtendremos como salida un listado de los procesos lanzados con el usuario actual que a\u00fan se est\u00e1n ejecutando. Resultado comando ps Nota En la imagen anterior observamos que hay dos procesos corriendo: el bash, que es el shell o int\u00e9rprete de comandos, y el comando ps. Las columnas que se muestran cuando ejecutamos el comando ps significan: La primera columna es el PID o identificador de proceso. Cada proceso tiene un asociado identificador que es \u00fanico, es decir que no puede haber dos procesos con el mismo identificador. La segunda columna nos informa del terminal en el que se est\u00e1 ejecutando el proceso. Si aparece una interrogaci\u00f3n (?), el proceso no tiene asociada ninguna terminal. La tercera columna indica el tiempo total que ha estado ejecut\u00e1ndose el proceso. La cuarta columna es el nombre del proceso. Par\u00e1metros/modificadores ps \u00b6 -e devuelve un listado de todos los procesos que se est\u00e1n ejecutando. -f devuelve un listado extendido. En este \u00faltimo caso veremos en pantalla el PPID del proceso (identificador del proceso padre) y la hora en la que se ejecut\u00f3 el proceso (STIME). Resultado comando ps -f -ef obtendr\u00edamos un listado extendido de todos los procesos que se est\u00e1n ejecutando en el sistema. -u informa de los procesos lanzado por un determinado usuario. De tal forma que si escribimos \u201c ps -u javi \u201d, aparecer\u00e1 un listado de los procesos que est\u00e1 ejecutando el usuario javi. El comando pstree \u00b6 El comando pstree visualiza, en forma de \u00e1rbol, todos los procesos del sistema, de esta forma se puede ver las relaciones que existen entre los procesos. Resultado comando pstree El comando top \u00b6 El comando top devuelve un listado de los procesos de forma parecida a como lo hace ps, con la diferencia que la informaci\u00f3n mostrada se va actualizando peri\u00f3dicamente lo que nos permite ver la evoluci\u00f3n del estado de los procesos. En la parte superior se muestra la siguiente informaci\u00f3n adicional: El espacio en memoria ocupado por los procesos. El espacio ocupado por la memoria de intercambio o swap. El n\u00famero total de tareas o procesos que se est\u00e1n ejecutando. El n\u00famero de usuarios o el porcentaje de uso del procesador. Resultado comando top Note Mientras el comando top est\u00e1 en marcha podremos cambiar f\u00e1cilmente la prioridad de los procesos. A modo de resumen cada proceso en Linux tiene un nivel de prioridad que va de -20 (prioridad m\u00e1s alta) hasta 20 (prioridad m\u00e1s baja). Cuanto mayor sea el nivel de prioridad, m\u00e1s lentamente se ejecutar\u00e1 el proceso. \u00bfY c\u00f3mo podemos cambiar con top la prioridad de un proceso? Muy sencillo. Con el comando top en marcha pulsamos la tecla \"r\" . A continuaci\u00f3n introducimos el PID del proceso al que vamos a cambiar la prioridad, y acto seguido el nivel de prioridad que vamos a asignar. Debemos tener en cuenta una consideraci\u00f3n, solamente el superusuario \"root\" puede asignar valores negativos a la prioridad de un proceso. Procesos en primer plano y segundo plano \u00b6 Los procesos pueden ejecutarse en primer plano (Foreground) o segundo plano (Background). El proceso que est\u00e1 en primer plano es aquel con el que se interact\u00faa. Si ejecutamos, por ejemplo, el comando ls -l , se mostrar\u00e1 por pantalla el resultado, y hasta que no acabe de mostrarse el listado no podremos ejecutar ning\u00fan otro comando. Nota En este caso el terminal permanece bloqueado, sin poder introducir ning\u00fan otro comando, hasta que el proceso en primer plano termine. Un proceso en segundo plano a\u00f1adiendo el s\u00edmbolo ampersand ( & ) al final del comando. Cuando se ejecuta un proceso en segundo plano, se permite al usuario iniciar y trabajar con otros procesos. Ejemplo root@aso:/# sleep 10 & El comando sleep simplemente espera el n\u00famero de segundos que le pasemos como par\u00e1metro, pero se ejecuta en segundo plano y permite seguir trabajando con el terminal abierto. Resultado comando sleep 10 & Nota En la imagen anterior se observa que al ejecutar un proceso en segundo plano se devuelve un n\u00famero entre corchetes seguido de otro n\u00famero. El n\u00famero entre corchetes indica el n\u00famero de procesos que se tienen ejecut\u00e1ndose en segundo plano . El segundo n\u00famero es el PID o identificador del proceso. Para ver que trabajos se est\u00e1n ejecutando en segundo plano, se usa el comando jobs . Resultado comando jobs Nota El signo + seguido del n\u00famero de trabajo entre corchetes indica el trabajo m\u00e1s reciente que se est\u00e1 ejecutando. El signo - indica el siguiente trabajo m\u00e1s reciente. Pasar procesos en segundo plano a primer plano \u00b6 Para pasar procesos en segundo plano a primer plano, se utiliza el comando fg , seguido de %n , donde n es el n\u00famero de proceso que queremos pasar a primer plano. Ejemplo Por ejemplo, fg %1 pondr\u00eda en primer plano la tarea n\u00famero 1. En la siguiente imagen se ejecuta sleep 80 en segundo plano, y despu\u00e9s pasa a primer plano con el comando fg. Resultado comando fg %1 Pasar procesos en primer plano a segundo plano \u00b6 El comando bg permite pasar procesos desde primer plano a segundo plano. Para pasar un proceso que se encuentra en primer plano a segundo plano, debemos suspenderlo primero utilizando la combinaci\u00f3n de teclas Ctrl+Z. Cuando se pulsa esa combinaci\u00f3n de teclas, el proceso en ejecuci\u00f3n se para y no vuelve a ejecutarse hasta que se pasa a primer o segundo plano. Con bg %n pasaremos el proceso a segundo plano. Resultado comando fg %1 Cambiando la prioridad de los procesos \u00b6 Tal Como se ha comentado anteriormente, cada proceso en Linux tiene un nivel de prioridad que oscila entre -20 (prioridad m\u00e1s alta) y 20 (prioridad m\u00e1s baja). Consejo Cuanto mayor sea el nivel de prioridad, m\u00e1s lentamente se ejecutar\u00e1 el proceso. Solamente el superusuario \u2018root\u2019 puede asignar valores negativos a la prioridad de un proceso. Para asignar determinada prioridad a un proceso en concreto se utiliza el comando renice , el cual es explicado en el siguiente apartado. El comando renice \u00b6 Podemos cambiar la prioridad de un proceso con el comando renice . Este comando admite los siguientes par\u00e1metros/modificadores: -g . Establece el nivel de prioridad de los procesos ejecutados por los miembros del grupo especificado. -u . Establece el nivel de prioridad de los procesos ejecutados por los miembros del usuario especificado. -p . Indica el nivel de prioridad para el proceso especificado. Ejemplo Con el comando ps ax -o pid,ni,cmd podemos ver la prioridad en la columna nice , ya que el indicador -o le permite especificar columnas. A continuaci\u00f3n se puede cambiar la prioridad con el comando renice indicando la nueva prioridad y el PID. en la siguiente imagen se genera un proceso sleep 80 en background se comprueba su prioridad y se sube a -8. B\u00fasqueda del comando sleep y su prioridad Resultado comando renice Nueva priorida del proceso Sleep 80 Finalizar procesos Para finalizar un proceso se utiliza el comando kill , que tiene la siguiente sintaxis: kill [ par\u00e1metro ] PID Si, por ejemplo, queremos eliminar un proceso con PID 17122 , tendr\u00edamos que escribir: kill 17122 . Puede que en ocasiones el proceso no finalice al emplear el comando kill sin par\u00e1metros. Para matar un proceso asegur\u00e1ndonos de que no ignorar\u00e1 la petici\u00f3n de finalizar su ejecuci\u00f3n se emplea el par\u00e1metro -9. kill -9 17122 Hay un total de 32 se\u00f1ales que se pueden enviar a los procesos. Las m\u00e1s utilizadas son las siguientes: - kill -1 ( Sighup ) . Reinicia el proceso. - kill -9 ( SigKill ) . Mata el proceso. - kill -15 ( SigTerm ) . Termina el proceso. NOTA Por otra parte, el comando killall nombre_programa finaliza todos los procesos que est\u00e9n ejecutando el programa. Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script de Shell que encuentre todos los procesos activos e imprima por pantalla al usuario la pol\u00edtica de programaci\u00f3n (es decir, Algoritmo de planificaci\u00f3n utilizado). Modifica el script anterior para que de la opci\u00f3n al usuario de aumentar o disminuir la prioridad de un proceso, a elegir por el usuario ambas variables. Modifica el script anterior para que de la opci\u00f3n al usuario de matar un proceso, a elegir por el usuario.","title":"3.3- Gesti\u00f3n de procesos en Shell de Linux."},{"location":"03_Procesos/033_GestionProcesosShell.html#gestion-de-procesos-en-shell-de-linux","text":"","title":"Gesti\u00f3n de procesos en Shell de Linux"},{"location":"03_Procesos/033_GestionProcesosShell.html#introduccion","text":"Como se ha comentado en sesiones anteriores un proceso en Linux es un programa en ejecuci\u00f3n, el cual puede crear a su vez otros procesos y se caracteriza por: El proceso que genera otro proceso se le llama proceso padre . El proceso generado por otro proceso se le llama proceso hijo . Los procesos pueden ser padres e hijos y adem\u00e1s, varios procesos pueden ser hijos del mismo padre a la vez. Ejemplo El terminal o consola es un proceso , ya que se trata de un programa que ejecutamos. Si en el terminal escribimos, por ejemplo, el comando \u201cls -l\u201d, se estar\u00eda generando un nuevo proceso que ser\u00eda proceso hijo del terminal. En este caso el shell ser\u00eda el proceso padre y el comando \u201cls -l\u201d ser\u00eda el proceso hijo . A continuaci\u00f3n se muestra una tabla resumen de comandos para la gesti\u00f3n de procesos: Tabla resumen de comandos de gesti\u00f3n de procesos en bash","title":"Introducci\u00f3n"},{"location":"03_Procesos/033_GestionProcesosShell.html#trabajando-con-procesos","text":"","title":"Trabajando con procesos"},{"location":"03_Procesos/033_GestionProcesosShell.html#el-comando-ps","text":"El comando ps proporciona informaci\u00f3n sobre los procesos que se est\u00e1n ejecutando en el sistema. Si escribimos en el terminal ps , obtendremos como salida un listado de los procesos lanzados con el usuario actual que a\u00fan se est\u00e1n ejecutando. Resultado comando ps Nota En la imagen anterior observamos que hay dos procesos corriendo: el bash, que es el shell o int\u00e9rprete de comandos, y el comando ps. Las columnas que se muestran cuando ejecutamos el comando ps significan: La primera columna es el PID o identificador de proceso. Cada proceso tiene un asociado identificador que es \u00fanico, es decir que no puede haber dos procesos con el mismo identificador. La segunda columna nos informa del terminal en el que se est\u00e1 ejecutando el proceso. Si aparece una interrogaci\u00f3n (?), el proceso no tiene asociada ninguna terminal. La tercera columna indica el tiempo total que ha estado ejecut\u00e1ndose el proceso. La cuarta columna es el nombre del proceso.","title":"El comando ps"},{"location":"03_Procesos/033_GestionProcesosShell.html#el-comando-pstree","text":"El comando pstree visualiza, en forma de \u00e1rbol, todos los procesos del sistema, de esta forma se puede ver las relaciones que existen entre los procesos. Resultado comando pstree","title":"El comando pstree"},{"location":"03_Procesos/033_GestionProcesosShell.html#el-comando-top","text":"El comando top devuelve un listado de los procesos de forma parecida a como lo hace ps, con la diferencia que la informaci\u00f3n mostrada se va actualizando peri\u00f3dicamente lo que nos permite ver la evoluci\u00f3n del estado de los procesos. En la parte superior se muestra la siguiente informaci\u00f3n adicional: El espacio en memoria ocupado por los procesos. El espacio ocupado por la memoria de intercambio o swap. El n\u00famero total de tareas o procesos que se est\u00e1n ejecutando. El n\u00famero de usuarios o el porcentaje de uso del procesador. Resultado comando top Note Mientras el comando top est\u00e1 en marcha podremos cambiar f\u00e1cilmente la prioridad de los procesos. A modo de resumen cada proceso en Linux tiene un nivel de prioridad que va de -20 (prioridad m\u00e1s alta) hasta 20 (prioridad m\u00e1s baja). Cuanto mayor sea el nivel de prioridad, m\u00e1s lentamente se ejecutar\u00e1 el proceso. \u00bfY c\u00f3mo podemos cambiar con top la prioridad de un proceso? Muy sencillo. Con el comando top en marcha pulsamos la tecla \"r\" . A continuaci\u00f3n introducimos el PID del proceso al que vamos a cambiar la prioridad, y acto seguido el nivel de prioridad que vamos a asignar. Debemos tener en cuenta una consideraci\u00f3n, solamente el superusuario \"root\" puede asignar valores negativos a la prioridad de un proceso.","title":"El comando top"},{"location":"03_Procesos/033_GestionProcesosShell.html#procesos-en-primer-plano-y-segundo-plano","text":"Los procesos pueden ejecutarse en primer plano (Foreground) o segundo plano (Background). El proceso que est\u00e1 en primer plano es aquel con el que se interact\u00faa. Si ejecutamos, por ejemplo, el comando ls -l , se mostrar\u00e1 por pantalla el resultado, y hasta que no acabe de mostrarse el listado no podremos ejecutar ning\u00fan otro comando. Nota En este caso el terminal permanece bloqueado, sin poder introducir ning\u00fan otro comando, hasta que el proceso en primer plano termine. Un proceso en segundo plano a\u00f1adiendo el s\u00edmbolo ampersand ( & ) al final del comando. Cuando se ejecuta un proceso en segundo plano, se permite al usuario iniciar y trabajar con otros procesos. Ejemplo root@aso:/# sleep 10 & El comando sleep simplemente espera el n\u00famero de segundos que le pasemos como par\u00e1metro, pero se ejecuta en segundo plano y permite seguir trabajando con el terminal abierto. Resultado comando sleep 10 & Nota En la imagen anterior se observa que al ejecutar un proceso en segundo plano se devuelve un n\u00famero entre corchetes seguido de otro n\u00famero. El n\u00famero entre corchetes indica el n\u00famero de procesos que se tienen ejecut\u00e1ndose en segundo plano . El segundo n\u00famero es el PID o identificador del proceso. Para ver que trabajos se est\u00e1n ejecutando en segundo plano, se usa el comando jobs . Resultado comando jobs Nota El signo + seguido del n\u00famero de trabajo entre corchetes indica el trabajo m\u00e1s reciente que se est\u00e1 ejecutando. El signo - indica el siguiente trabajo m\u00e1s reciente.","title":"Procesos en primer plano y segundo plano"},{"location":"03_Procesos/033_GestionProcesosShell.html#pasar-procesos-en-segundo-plano-a-primer-plano","text":"Para pasar procesos en segundo plano a primer plano, se utiliza el comando fg , seguido de %n , donde n es el n\u00famero de proceso que queremos pasar a primer plano. Ejemplo Por ejemplo, fg %1 pondr\u00eda en primer plano la tarea n\u00famero 1. En la siguiente imagen se ejecuta sleep 80 en segundo plano, y despu\u00e9s pasa a primer plano con el comando fg. Resultado comando fg %1","title":"Pasar procesos en segundo plano a primer plano"},{"location":"03_Procesos/033_GestionProcesosShell.html#pasar-procesos-en-primer-plano-a-segundo-plano","text":"El comando bg permite pasar procesos desde primer plano a segundo plano. Para pasar un proceso que se encuentra en primer plano a segundo plano, debemos suspenderlo primero utilizando la combinaci\u00f3n de teclas Ctrl+Z. Cuando se pulsa esa combinaci\u00f3n de teclas, el proceso en ejecuci\u00f3n se para y no vuelve a ejecutarse hasta que se pasa a primer o segundo plano. Con bg %n pasaremos el proceso a segundo plano. Resultado comando fg %1","title":"Pasar procesos en primer plano a segundo plano"},{"location":"03_Procesos/033_GestionProcesosShell.html#cambiando-la-prioridad-de-los-procesos","text":"Tal Como se ha comentado anteriormente, cada proceso en Linux tiene un nivel de prioridad que oscila entre -20 (prioridad m\u00e1s alta) y 20 (prioridad m\u00e1s baja). Consejo Cuanto mayor sea el nivel de prioridad, m\u00e1s lentamente se ejecutar\u00e1 el proceso. Solamente el superusuario \u2018root\u2019 puede asignar valores negativos a la prioridad de un proceso. Para asignar determinada prioridad a un proceso en concreto se utiliza el comando renice , el cual es explicado en el siguiente apartado.","title":"Cambiando la prioridad de los procesos"},{"location":"03_Procesos/033_GestionProcesosShell.html#el-comando-renice","text":"Podemos cambiar la prioridad de un proceso con el comando renice . Este comando admite los siguientes par\u00e1metros/modificadores: -g . Establece el nivel de prioridad de los procesos ejecutados por los miembros del grupo especificado. -u . Establece el nivel de prioridad de los procesos ejecutados por los miembros del usuario especificado. -p . Indica el nivel de prioridad para el proceso especificado. Ejemplo Con el comando ps ax -o pid,ni,cmd podemos ver la prioridad en la columna nice , ya que el indicador -o le permite especificar columnas. A continuaci\u00f3n se puede cambiar la prioridad con el comando renice indicando la nueva prioridad y el PID. en la siguiente imagen se genera un proceso sleep 80 en background se comprueba su prioridad y se sube a -8. B\u00fasqueda del comando sleep y su prioridad Resultado comando renice Nueva priorida del proceso Sleep 80 Finalizar procesos Para finalizar un proceso se utiliza el comando kill , que tiene la siguiente sintaxis: kill [ par\u00e1metro ] PID Si, por ejemplo, queremos eliminar un proceso con PID 17122 , tendr\u00edamos que escribir: kill 17122 . Puede que en ocasiones el proceso no finalice al emplear el comando kill sin par\u00e1metros. Para matar un proceso asegur\u00e1ndonos de que no ignorar\u00e1 la petici\u00f3n de finalizar su ejecuci\u00f3n se emplea el par\u00e1metro -9. kill -9 17122 Hay un total de 32 se\u00f1ales que se pueden enviar a los procesos. Las m\u00e1s utilizadas son las siguientes: - kill -1 ( Sighup ) . Reinicia el proceso. - kill -9 ( SigKill ) . Mata el proceso. - kill -15 ( SigTerm ) . Termina el proceso. NOTA Por otra parte, el comando killall nombre_programa finaliza todos los procesos que est\u00e9n ejecutando el programa.","title":"El comando renice"},{"location":"03_Procesos/033_GestionProcesosShell.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script de Shell que encuentre todos los procesos activos e imprima por pantalla al usuario la pol\u00edtica de programaci\u00f3n (es decir, Algoritmo de planificaci\u00f3n utilizado). Modifica el script anterior para que de la opci\u00f3n al usuario de aumentar o disminuir la prioridad de un proceso, a elegir por el usuario ambas variables. Modifica el script anterior para que de la opci\u00f3n al usuario de matar un proceso, a elegir por el usuario.","title":"Actividades"},{"location":"03_Procesos/034_GestionProcesosPWSH.html","text":"Gesti\u00f3n de procesos con Powershell \u00b6 La teor\u00eda para gestionar procesos ya se ha impartido en las secciones anteriores por lo que esta secci\u00f3n se centra en las herramientas y comandos para gestionar los procesos en PowerShell. Nota Para encontrar los comandos relacionados con procesos en Power-Shell podemos utilizar: get-command *process* PS / Users / aso > get-command * process * CommandType Name Version Source ----------- ---- ------- ------ Alias Start-ASRSwitchProcessServerJob 5 . 2 . 0 Az . RecoveryServices Cmdlet Debug-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Enter-PSHostProcess 7 . 2 . 2 . 500 Microsoft . PowerShell . Core Cmdlet Exit-PSHostProcess 7 . 2 . 2 . 500 Microsoft . PowerShell . Core Cmdlet Get-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Get-PSHostProcessInfo 7 . 2 . 2 . 500 Microsoft . PowerShell . Core Cmdlet Start-AzRecoveryServicesAsrSwitchProcessServerJob 5 . 2 . 0 Az . RecoveryServices Cmdlet Start-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Stop-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Wait-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Nota Para obtener informaci\u00f3n de cada comando: Get-Help PS / Users / aso > get-help Get-Process NAME Get-Process SYNTAX Get-Process [[ -Name ] < string []>] [ -Module ] [ -FileVersionInfo ] [< CommonParameters >] Get-Process [[ -Name ] < string []>] -IncludeUserName [< CommonParameters >] Get-Process -Id < int []> [ -Module ] [ -FileVersionInfo ] [< CommonParameters >] Get-Process -Id < int []> -IncludeUserName [< CommonParameters >] Get-Process -InputObject < Process []> [ -Module ] [ -FileVersionInfo ] [< CommonParameters >] Get-Process -InputObject < Process []> -IncludeUserName [< CommonParameters >] ALIASES gps REMARKS Get-Help cannot find the Help files for this cmdlet on this computer . It is displaying only partial help . -- To download and install Help files for the module that includes this cmdlet , use Update-Help . -- To view the Help topic for this cmdlet online , type : \"Get-Help Get-Process -Online\" or go to https :// go . microsoft . com / fwlink / ? LinkID = 2096814 . Obtener procesos \u00b6 Para obtener los procesos que se est\u00e1n ejecutando en el equipo local, se ejecuta Get-Process sin par\u00e1metros. PS / Users / aso > Get-Process NPM ( K ) PM ( M ) WS ( M ) CPU ( s ) Id SI ProcessName ------ ----- ----- ------ -- -- ----------- 0 0 , 00 24 , 09 31 , 56 406 1 accountsd 0 0 , 00 8 , 14 0 , 48 488 1 adprivacyd 0 0 , 00 8 , 18 0 , 41 475 1 AirPlayUIAgent 0 0 , 00 11 , 19 2 , 09 425 1 akd 0 0 , 00 4 , 88 0 , 17 453 1 AMPDeviceDiscov 0 0 , 00 7 , 43 0 , 50 590 1 AMPLibraryAgent 0 0 , 00 9 , 42 1 , 02 480 1 amsaccountsd 0 0 , 00 10 , 34 2 , 69 410 1 amsengagementd 0 0 , 00 1 , 68 0 , 03 500 1 APFSUserAgent 0 0 , 00 28 , 80 28 , 01 600 1 AppleSpell 0 0 , 00 9 , 23 0 , 44 398 1 AppSSOAgent 0 0 , 00 11 , 14 5 , 90 538 1 appstoreagent 0 0 , 00 8 , 06 0 , 73 472 1 askpermissiond 0 0 , 00 6 , 64 0 , 42 566 1 AssetCacheLocat 0 0 , 00 22 , 21 12 , 86 483 1 assistantd 0 0 , 00 22 , 71 9 , 10 718 1 assistant_servi 0 0 , 00 3 , 09 0 , 28 605 1 AudioComponentR 0 0 , 00 24 , 00 0 , 47 1273 1 avatarsd 0 0 , 00 5 , 79 0 , 18 386 1 backgroundtaskm 0 0 , 00 8 , 36 1 , 92 418 1 bird Nota En la salida del comando anterior hay mucha informaci\u00f3n desordenada a analizar. Puede ayudar a ver la informaci\u00f3n si se organizan los procesos de mayor a menor consumo de CPU, y solo los 10 primeros . PS / Users / aso > Get-Process | Sort-Object CPU -Descending | Select-Object -First 10 NPM ( K ) PM ( M ) WS ( M ) CPU ( s ) Id SI ProcessName ------ ----- ----- ------ -- -- ----------- 0 0 , 00 52 , 24 643 , 87 561 1 suggestd 0 0 , 00 23 , 55 267 , 14 457 1 CleanMyMac X He 0 0 , 00 26 , 21 262 , 25 912 912 CalendarWidgetE 0 0 , 00 32 , 32 210 , 93 407 1 CalendarAgent 0 0 , 00 32 , 07 181 , 48 914 914 WorldClockWidge 0 0 , 00 95 , 39 140 , 45 378 1 Finder 0 0 , 00 586 , 70 135 , 40 5266 1 Code Helper 0 0 , 00 221 , 30 127 , 45 5031 1 Code Helper ( Re 0 0 , 00 17 , 03 94 , 25 390 390 QuickLookUIServ 0 0 , 00 114 , 68 93 , 64 5049 1 Safari En el supuesto caso que se quieran encontrar determinados procesos se pueden obtener especificando sus nombres de proceso o identificadores de proceso. Ejemplo El siguiente comando obtiene el proceso inactivo: Get-Process -id 0 Nota El proceso inactivo del sistema contiene uno o m\u00e1s kernel threads que ejecuta cuando ning\u00fan otro thread puede ser planificado en la CPU, es decir, es el porcentaje que el procesador no est\u00e1 trabajando . PS / Users / aso > Get-Process -id 0 Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 0 0 0 16 0 0 Idle Nota Es normal que los cmdlets no devuelvan datos en algunas situaciones, como por ejemplo cuando se especifica un proceso por su id de proceso Get-Process y si no encuentra ninguna coincidencia generar\u00e1 un error , porque la intenci\u00f3n habitual consiste en recuperar un proceso en ejecuci\u00f3n conocido. Si no hay ning\u00fan proceso con ese identificador, es probable que el identificador sea incorrecto o que el proceso de inter\u00e9s haya terminado. PS / Users / aso > Get-Process -Id 99 Get-Process : No process with process ID 99 was found . At line : 1 char : 12 + Get-Process <<<< -Id 99 Consejo Para evitar estos errores puede usar el par\u00e1metro Name del cmdlet Get-Process para especificar un subconjunto de procesos basado en el nombre del proceso. El par\u00e1metro Name puede tomar varios nombres de una lista de nombres separados por comas y admite el uso de caracteres comod\u00edn, para que pueda escribir patrones de nombre. Example El siguiente comando obtiene el proceso cuyos nombres comienzan por \"ex\". PS / Users / aso > Get-Process -Name ex * Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 234 7 5572 12484 134 2 . 98 1684 EXCEL 555 15 34500 12384 134 105 . 25 728 explorer Get-Process tambi\u00e9n acepta varios valores para el par\u00e1metro Name. PS / Users / aso > Get-Process -Name exp *, power * Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 540 15 35172 48148 141 88 . 44 408 explorer 605 9 30668 29800 155 7 . 11 3052 powershell Para obtener m\u00e1s informaci\u00f3n de un proceso se puede utilizar el comando: PS / Users / aso > Get-Process -Name pwsh | Format-List * Name : pwsh Id : 5289 PriorityClass : Normal FileVersion : HandleCount : 0 WorkingSet : 85704704 PagedMemorySize : 0 PrivateMemorySize : 0 VirtualMemorySize : - 1759395840 TotalProcessorTime : 00 : 00 : 21 . 8087752 SI : 5289 Handles : 0 VM : 6830538752 WS : 85704704 PM : 0 NPM : 0 Path : / usr / local / microsoft / powershell / 7 / pwsh CommandLine : Parent : System . Diagnostics . Process ( Code Helper ( Re ) Company : CPU : 21 , 8248627 ProductVersion : Description : Product : __NounName : Process SafeHandle : Microsoft . Win32 . SafeHandles . SafeProcessHandle Handle : 1336 BasePriority : 0 Obtener informaci\u00f3n determinada de un proceso \u00b6 Para obtener informaciones en particular de un proceso podemos poner entre par\u00e9ntesis el comando de obtener el proceso y a continuaci\u00f3n un punto seguido de la informaci\u00f3n que se quiera obtener. Por ejemplo: Una informaci\u00f3n importante de un proceso puede ser el path donde esta guardado el proceso, y se puede obtener con: PS / Users / aso > ( Get-Process -Name pwsh ). path / usr / local / microsoft / powershell / 7 / pwsh Para obtener el tama\u00f1o del proceso con: PS / Users / aso > ( Get-Process -Name pwsh ). ws 68603904 Procesos en remoto \u00b6 Puede usar el par\u00e1metro ComputerName de Get-Process para obtener procesos en equipos remotos. Por ejemplo, el comando siguiente obtiene los procesos de PowerShell en el equipo local (representado por \"localhost\") y en dos equipos remotos. Get-Process -Name PowerShell -ComputerName localhost , Server01 , Server02 La salida de este comando seria: Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 258 8 29772 38636 130 3700 powershell 398 24 75988 76800 572 5816 powershell 605 9 30668 29800 155 7 . 11 3052 powershell Nota Los nombres de equipo no son evidentes en este resultado, pero se almacenan en la propiedad MachineName de los objetos de proceso que devuelve Get-Process . El siguiente comando usa el cmdlet Format-Table para mostrar el identificador de proceso y las propiedades ProcessName y MachineName(ComputerName) de los objetos de proceso. Get-Process -Name PowerShell -ComputerName localhost , Server01 , Server01 | Format-Table -Property ID , ProcessName , MachineName La salida de este comando seria: Id ProcessName MachineName -- ----------- ----------- 3700 powershell Server01 3052 powershell Server02 5816 powershell localhost Detener procesos \u00b6 El cmdlet Stop-Process toma un nombre o un identificador para especificar un proceso que quiere detener. Su capacidad para detener procesos depender\u00e1 de sus permisos. Algunos procesos no se pueden detener. Por ejemplo, si intenta detener el proceso inactivo, obtendr\u00e1 un error: Stop-Process -Name Idle La salida de este comando seria: Stop-Process : Process 'Idle (0)' cannot be stopped due to the following error : Access is denied At line : 1 char : 13 + Stop-Process <<<< -Name Idle Consejo Tambi\u00e9n puede forzar la solicitud con el par\u00e1metro Confirm . Este par\u00e1metro es especialmente \u00fatil si se usa un car\u00e1cter comod\u00edn al especificar el nombre del proceso, ya que accidentalmente podr\u00eda coincidir con algunos procesos que no se quiere detener: Stop-Process -Name t *, e * -Confirm La salida de este comando seria: Confirm Are you sure you want to perform this action ? Performing operation \"Stop-Process\" on Target \"explorer (408)\" . [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help ( default is \"Y\" ): n Confirm Are you sure you want to perform this action ? Performing operation \"Stop-Process\" on Target \"taskmgr (4072)\" . [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help ( default is \"Y\" ): n Detenci\u00f3n de procesos que no responden \u00b6 Consejo La manipulaci\u00f3n de procesos complejos es posible si se usan algunos cmdlets de filtrado de objetos. Dado que un objeto Process tiene una propiedad Responding que es false cuando ya no responde, puede detener todas las aplicaciones que no respondan con el comando siguiente: Get-Process | Where-Object -FilterScript { $_ . Responding -eq $false } | Stop-Process Detener procesos en remoto \u00b6 El cmdlet Stop-Process no tiene un par\u00e1metro ComputerName. Por lo tanto, para ejecutar un comando para detener un proceso en un equipo remoto, debe usar el cmdlet Invoke-Command . Por ejemplo, para detener el proceso de PowerShell en el equipo remoto Server01, escriba: Invoke-Command -ComputerName Server01 { Stop-Process Powershell } Detener todas las dem\u00e1s sesiones de Windows PowerShell \u00b6 En ocasiones puede ser \u00fatil poder detener todas las sesiones de Windows PowerShell que se est\u00e1n ejecutando, excepto la sesi\u00f3n actual. Si una sesi\u00f3n usa demasiados recursos o es inaccesible (quiz\u00e1s se est\u00e9 ejecutando de forma remota o en otra sesi\u00f3n de escritorio), es posible que no pueda detenerla directamente. Si intenta detener todas las sesiones que se est\u00e1n ejecutando, la sesi\u00f3n actual podr\u00eda finalizar en su lugar. Cada sesi\u00f3n de Windows PowerShell tiene un PID de variable de entorno que contiene el identificador del proceso de Windows PowerShell. Puede comprobar el $PID con el identificador de la sesi\u00f3n actual y finalizar solo las sesiones de Windows PowerShell que tengan un identificador diferente. El siguiente comando de canalizaci\u00f3n realiza esta acci\u00f3n y devuelve la lista de las sesiones finalizadas (debido al uso del par\u00e1metro PassThru ): Get-Process -Name powershell | Where-Object -FilterScript { $_ . Id -ne $PID } | Stop-Process -PassThru La salida de este comando seria: Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 334 9 23348 29136 143 1 . 03 388 powershell 304 9 23152 29040 143 1 . 03 632 powershell 302 9 20916 26804 143 1 . 03 1116 powershell 335 9 25656 31412 143 1 . 09 3452 powershell 303 9 23156 29044 143 1 . 05 3608 powershell 287 9 21044 26928 143 1 . 02 3672 powershell Iniciar procesos \u00b6 Se pueden iniciar procesos conociendo el path de su ejecutable. Por Ejemplo: PS / Users / aso > Start-Process -FilePath C :\\ windows \\ notepad . exe Consejo Para abrir aplicaciones se utilizar\u00eda un comando parecido pero hay que realizar a trav\u00e9s de un protocolo. Ejemplo, si se quisiera abrir el Edge de Windows: PS / Users / aso > Start-Process Microsoft-edge :// Actividades \u00b6 NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script en PowerShell que realice los siguientes puntos: Cuenta el n\u00famero de procesos en ejecuci\u00f3n en el sistema, y los muestre por pantalla. Ver que programas se ejecutan en el inicio de sesi\u00f3n y los muestre por pantalla. Guardar los un listado de los procesos en un csv e Imprima por pantalla el archivo. Realiza un script en PowerShell que realice los siguientes puntos: Lista los procesos que tengan un alto consumo de CPU. Detenga el proceso con mayor consumo. Mostrar los procesos cuya zona de memoria para trabajar sea mayor que 100 MB y a continuaci\u00f3n los detenga.","title":"3.4- Gesti\u00f3n de procesos en PowerShell."},{"location":"03_Procesos/034_GestionProcesosPWSH.html#gestion-de-procesos-con-powershell","text":"La teor\u00eda para gestionar procesos ya se ha impartido en las secciones anteriores por lo que esta secci\u00f3n se centra en las herramientas y comandos para gestionar los procesos en PowerShell. Nota Para encontrar los comandos relacionados con procesos en Power-Shell podemos utilizar: get-command *process* PS / Users / aso > get-command * process * CommandType Name Version Source ----------- ---- ------- ------ Alias Start-ASRSwitchProcessServerJob 5 . 2 . 0 Az . RecoveryServices Cmdlet Debug-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Enter-PSHostProcess 7 . 2 . 2 . 500 Microsoft . PowerShell . Core Cmdlet Exit-PSHostProcess 7 . 2 . 2 . 500 Microsoft . PowerShell . Core Cmdlet Get-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Get-PSHostProcessInfo 7 . 2 . 2 . 500 Microsoft . PowerShell . Core Cmdlet Start-AzRecoveryServicesAsrSwitchProcessServerJob 5 . 2 . 0 Az . RecoveryServices Cmdlet Start-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Stop-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Cmdlet Wait-Process 7 . 0 . 0 . 0 Microsoft . PowerShell . Management Nota Para obtener informaci\u00f3n de cada comando: Get-Help PS / Users / aso > get-help Get-Process NAME Get-Process SYNTAX Get-Process [[ -Name ] < string []>] [ -Module ] [ -FileVersionInfo ] [< CommonParameters >] Get-Process [[ -Name ] < string []>] -IncludeUserName [< CommonParameters >] Get-Process -Id < int []> [ -Module ] [ -FileVersionInfo ] [< CommonParameters >] Get-Process -Id < int []> -IncludeUserName [< CommonParameters >] Get-Process -InputObject < Process []> [ -Module ] [ -FileVersionInfo ] [< CommonParameters >] Get-Process -InputObject < Process []> -IncludeUserName [< CommonParameters >] ALIASES gps REMARKS Get-Help cannot find the Help files for this cmdlet on this computer . It is displaying only partial help . -- To download and install Help files for the module that includes this cmdlet , use Update-Help . -- To view the Help topic for this cmdlet online , type : \"Get-Help Get-Process -Online\" or go to https :// go . microsoft . com / fwlink / ? LinkID = 2096814 .","title":"Gesti\u00f3n de procesos con Powershell"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#obtener-procesos","text":"Para obtener los procesos que se est\u00e1n ejecutando en el equipo local, se ejecuta Get-Process sin par\u00e1metros. PS / Users / aso > Get-Process NPM ( K ) PM ( M ) WS ( M ) CPU ( s ) Id SI ProcessName ------ ----- ----- ------ -- -- ----------- 0 0 , 00 24 , 09 31 , 56 406 1 accountsd 0 0 , 00 8 , 14 0 , 48 488 1 adprivacyd 0 0 , 00 8 , 18 0 , 41 475 1 AirPlayUIAgent 0 0 , 00 11 , 19 2 , 09 425 1 akd 0 0 , 00 4 , 88 0 , 17 453 1 AMPDeviceDiscov 0 0 , 00 7 , 43 0 , 50 590 1 AMPLibraryAgent 0 0 , 00 9 , 42 1 , 02 480 1 amsaccountsd 0 0 , 00 10 , 34 2 , 69 410 1 amsengagementd 0 0 , 00 1 , 68 0 , 03 500 1 APFSUserAgent 0 0 , 00 28 , 80 28 , 01 600 1 AppleSpell 0 0 , 00 9 , 23 0 , 44 398 1 AppSSOAgent 0 0 , 00 11 , 14 5 , 90 538 1 appstoreagent 0 0 , 00 8 , 06 0 , 73 472 1 askpermissiond 0 0 , 00 6 , 64 0 , 42 566 1 AssetCacheLocat 0 0 , 00 22 , 21 12 , 86 483 1 assistantd 0 0 , 00 22 , 71 9 , 10 718 1 assistant_servi 0 0 , 00 3 , 09 0 , 28 605 1 AudioComponentR 0 0 , 00 24 , 00 0 , 47 1273 1 avatarsd 0 0 , 00 5 , 79 0 , 18 386 1 backgroundtaskm 0 0 , 00 8 , 36 1 , 92 418 1 bird Nota En la salida del comando anterior hay mucha informaci\u00f3n desordenada a analizar. Puede ayudar a ver la informaci\u00f3n si se organizan los procesos de mayor a menor consumo de CPU, y solo los 10 primeros . PS / Users / aso > Get-Process | Sort-Object CPU -Descending | Select-Object -First 10 NPM ( K ) PM ( M ) WS ( M ) CPU ( s ) Id SI ProcessName ------ ----- ----- ------ -- -- ----------- 0 0 , 00 52 , 24 643 , 87 561 1 suggestd 0 0 , 00 23 , 55 267 , 14 457 1 CleanMyMac X He 0 0 , 00 26 , 21 262 , 25 912 912 CalendarWidgetE 0 0 , 00 32 , 32 210 , 93 407 1 CalendarAgent 0 0 , 00 32 , 07 181 , 48 914 914 WorldClockWidge 0 0 , 00 95 , 39 140 , 45 378 1 Finder 0 0 , 00 586 , 70 135 , 40 5266 1 Code Helper 0 0 , 00 221 , 30 127 , 45 5031 1 Code Helper ( Re 0 0 , 00 17 , 03 94 , 25 390 390 QuickLookUIServ 0 0 , 00 114 , 68 93 , 64 5049 1 Safari En el supuesto caso que se quieran encontrar determinados procesos se pueden obtener especificando sus nombres de proceso o identificadores de proceso. Ejemplo El siguiente comando obtiene el proceso inactivo: Get-Process -id 0 Nota El proceso inactivo del sistema contiene uno o m\u00e1s kernel threads que ejecuta cuando ning\u00fan otro thread puede ser planificado en la CPU, es decir, es el porcentaje que el procesador no est\u00e1 trabajando . PS / Users / aso > Get-Process -id 0 Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 0 0 0 16 0 0 Idle Nota Es normal que los cmdlets no devuelvan datos en algunas situaciones, como por ejemplo cuando se especifica un proceso por su id de proceso Get-Process y si no encuentra ninguna coincidencia generar\u00e1 un error , porque la intenci\u00f3n habitual consiste en recuperar un proceso en ejecuci\u00f3n conocido. Si no hay ning\u00fan proceso con ese identificador, es probable que el identificador sea incorrecto o que el proceso de inter\u00e9s haya terminado. PS / Users / aso > Get-Process -Id 99 Get-Process : No process with process ID 99 was found . At line : 1 char : 12 + Get-Process <<<< -Id 99 Consejo Para evitar estos errores puede usar el par\u00e1metro Name del cmdlet Get-Process para especificar un subconjunto de procesos basado en el nombre del proceso. El par\u00e1metro Name puede tomar varios nombres de una lista de nombres separados por comas y admite el uso de caracteres comod\u00edn, para que pueda escribir patrones de nombre. Example El siguiente comando obtiene el proceso cuyos nombres comienzan por \"ex\". PS / Users / aso > Get-Process -Name ex * Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 234 7 5572 12484 134 2 . 98 1684 EXCEL 555 15 34500 12384 134 105 . 25 728 explorer Get-Process tambi\u00e9n acepta varios valores para el par\u00e1metro Name. PS / Users / aso > Get-Process -Name exp *, power * Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 540 15 35172 48148 141 88 . 44 408 explorer 605 9 30668 29800 155 7 . 11 3052 powershell Para obtener m\u00e1s informaci\u00f3n de un proceso se puede utilizar el comando: PS / Users / aso > Get-Process -Name pwsh | Format-List * Name : pwsh Id : 5289 PriorityClass : Normal FileVersion : HandleCount : 0 WorkingSet : 85704704 PagedMemorySize : 0 PrivateMemorySize : 0 VirtualMemorySize : - 1759395840 TotalProcessorTime : 00 : 00 : 21 . 8087752 SI : 5289 Handles : 0 VM : 6830538752 WS : 85704704 PM : 0 NPM : 0 Path : / usr / local / microsoft / powershell / 7 / pwsh CommandLine : Parent : System . Diagnostics . Process ( Code Helper ( Re ) Company : CPU : 21 , 8248627 ProductVersion : Description : Product : __NounName : Process SafeHandle : Microsoft . Win32 . SafeHandles . SafeProcessHandle Handle : 1336 BasePriority : 0","title":"Obtener procesos"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#obtener-informacion-determinada-de-un-proceso","text":"Para obtener informaciones en particular de un proceso podemos poner entre par\u00e9ntesis el comando de obtener el proceso y a continuaci\u00f3n un punto seguido de la informaci\u00f3n que se quiera obtener. Por ejemplo: Una informaci\u00f3n importante de un proceso puede ser el path donde esta guardado el proceso, y se puede obtener con: PS / Users / aso > ( Get-Process -Name pwsh ). path / usr / local / microsoft / powershell / 7 / pwsh Para obtener el tama\u00f1o del proceso con: PS / Users / aso > ( Get-Process -Name pwsh ). ws 68603904","title":"Obtener informaci\u00f3n determinada de un proceso"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#procesos-en-remoto","text":"Puede usar el par\u00e1metro ComputerName de Get-Process para obtener procesos en equipos remotos. Por ejemplo, el comando siguiente obtiene los procesos de PowerShell en el equipo local (representado por \"localhost\") y en dos equipos remotos. Get-Process -Name PowerShell -ComputerName localhost , Server01 , Server02 La salida de este comando seria: Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 258 8 29772 38636 130 3700 powershell 398 24 75988 76800 572 5816 powershell 605 9 30668 29800 155 7 . 11 3052 powershell Nota Los nombres de equipo no son evidentes en este resultado, pero se almacenan en la propiedad MachineName de los objetos de proceso que devuelve Get-Process . El siguiente comando usa el cmdlet Format-Table para mostrar el identificador de proceso y las propiedades ProcessName y MachineName(ComputerName) de los objetos de proceso. Get-Process -Name PowerShell -ComputerName localhost , Server01 , Server01 | Format-Table -Property ID , ProcessName , MachineName La salida de este comando seria: Id ProcessName MachineName -- ----------- ----------- 3700 powershell Server01 3052 powershell Server02 5816 powershell localhost","title":"Procesos en remoto"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#detener-procesos","text":"El cmdlet Stop-Process toma un nombre o un identificador para especificar un proceso que quiere detener. Su capacidad para detener procesos depender\u00e1 de sus permisos. Algunos procesos no se pueden detener. Por ejemplo, si intenta detener el proceso inactivo, obtendr\u00e1 un error: Stop-Process -Name Idle La salida de este comando seria: Stop-Process : Process 'Idle (0)' cannot be stopped due to the following error : Access is denied At line : 1 char : 13 + Stop-Process <<<< -Name Idle Consejo Tambi\u00e9n puede forzar la solicitud con el par\u00e1metro Confirm . Este par\u00e1metro es especialmente \u00fatil si se usa un car\u00e1cter comod\u00edn al especificar el nombre del proceso, ya que accidentalmente podr\u00eda coincidir con algunos procesos que no se quiere detener: Stop-Process -Name t *, e * -Confirm La salida de este comando seria: Confirm Are you sure you want to perform this action ? Performing operation \"Stop-Process\" on Target \"explorer (408)\" . [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help ( default is \"Y\" ): n Confirm Are you sure you want to perform this action ? Performing operation \"Stop-Process\" on Target \"taskmgr (4072)\" . [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help ( default is \"Y\" ): n","title":"Detener procesos"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#detencion-de-procesos-que-no-responden","text":"Consejo La manipulaci\u00f3n de procesos complejos es posible si se usan algunos cmdlets de filtrado de objetos. Dado que un objeto Process tiene una propiedad Responding que es false cuando ya no responde, puede detener todas las aplicaciones que no respondan con el comando siguiente: Get-Process | Where-Object -FilterScript { $_ . Responding -eq $false } | Stop-Process","title":"Detenci\u00f3n de procesos que no responden"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#detener-procesos-en-remoto","text":"El cmdlet Stop-Process no tiene un par\u00e1metro ComputerName. Por lo tanto, para ejecutar un comando para detener un proceso en un equipo remoto, debe usar el cmdlet Invoke-Command . Por ejemplo, para detener el proceso de PowerShell en el equipo remoto Server01, escriba: Invoke-Command -ComputerName Server01 { Stop-Process Powershell }","title":"Detener procesos en remoto"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#detener-todas-las-demas-sesiones-de-windows-powershell","text":"En ocasiones puede ser \u00fatil poder detener todas las sesiones de Windows PowerShell que se est\u00e1n ejecutando, excepto la sesi\u00f3n actual. Si una sesi\u00f3n usa demasiados recursos o es inaccesible (quiz\u00e1s se est\u00e9 ejecutando de forma remota o en otra sesi\u00f3n de escritorio), es posible que no pueda detenerla directamente. Si intenta detener todas las sesiones que se est\u00e1n ejecutando, la sesi\u00f3n actual podr\u00eda finalizar en su lugar. Cada sesi\u00f3n de Windows PowerShell tiene un PID de variable de entorno que contiene el identificador del proceso de Windows PowerShell. Puede comprobar el $PID con el identificador de la sesi\u00f3n actual y finalizar solo las sesiones de Windows PowerShell que tengan un identificador diferente. El siguiente comando de canalizaci\u00f3n realiza esta acci\u00f3n y devuelve la lista de las sesiones finalizadas (debido al uso del par\u00e1metro PassThru ): Get-Process -Name powershell | Where-Object -FilterScript { $_ . Id -ne $PID } | Stop-Process -PassThru La salida de este comando seria: Handles NPM ( K ) PM ( K ) WS ( K ) VM ( M ) CPU ( s ) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 334 9 23348 29136 143 1 . 03 388 powershell 304 9 23152 29040 143 1 . 03 632 powershell 302 9 20916 26804 143 1 . 03 1116 powershell 335 9 25656 31412 143 1 . 09 3452 powershell 303 9 23156 29044 143 1 . 05 3608 powershell 287 9 21044 26928 143 1 . 02 3672 powershell","title":"Detener todas las dem\u00e1s sesiones de Windows PowerShell"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#iniciar-procesos","text":"Se pueden iniciar procesos conociendo el path de su ejecutable. Por Ejemplo: PS / Users / aso > Start-Process -FilePath C :\\ windows \\ notepad . exe Consejo Para abrir aplicaciones se utilizar\u00eda un comando parecido pero hay que realizar a trav\u00e9s de un protocolo. Ejemplo, si se quisiera abrir el Edge de Windows: PS / Users / aso > Start-Process Microsoft-edge ://","title":"Iniciar procesos"},{"location":"03_Procesos/034_GestionProcesosPWSH.html#actividades","text":"NOTA Escribe el c\u00f3digo de los scripts en PowerShell que se detallan en cada ejercicio. Deber\u00e1s crear un fichero de texto para cada ejercicio con el siguiente nombre: ejXXX.sh, donde las X representan el n\u00famero de ejercicio. Una vez terminada la pr\u00e1ctica, comprime todos estos ficheros en uno y s\u00fabelos al Moodle. Realiza un script en PowerShell que realice los siguientes puntos: Cuenta el n\u00famero de procesos en ejecuci\u00f3n en el sistema, y los muestre por pantalla. Ver que programas se ejecutan en el inicio de sesi\u00f3n y los muestre por pantalla. Guardar los un listado de los procesos en un csv e Imprima por pantalla el archivo. Realiza un script en PowerShell que realice los siguientes puntos: Lista los procesos que tengan un alto consumo de CPU. Detenga el proceso con mayor consumo. Mostrar los procesos cuya zona de memoria para trabajar sea mayor que 100 MB y a continuaci\u00f3n los detenga.","title":"Actividades"},{"location":"03_Procesos/035_ArranqueServicios.html","text":"Arranque del sistema. Servicios. Systemd \u00b6 En inform\u00e1tica, el arranque o secuencia de arranque (en ingl\u00e9s: bootstrapping, boot o booting ) se define: Definici\u00f3n Arranque del sistema Es el proceso que inicia el gestor de arranque; programa ejecutado por el Software BIOS cuando se enciende una computadora. Se encarga de la inicializaci\u00f3n del sistema operativo y de los dispositivos . A nivel conceptual los pasos de arranque de un sistema inform\u00e1tico se muestran en la siguiente figura: Pasos Arranque Arranque en Linux \u00b6 En Linux, el flujo de control durante el arranque se desarrolla en 4 etapas: Al principio, toma el control la BIOS. En una segunda etapa, tomar\u00e1 el control el cargador de arranque. En una tercera etapa, el control pasa al propio kernel Linux. Y en la cuarta y \u00faltima etapa tendremos en memoria los programas de usuario conviviendo junto con el propio sistema operativo, quienes tomar\u00e1n el control del sistema. Pasos Arranque Linux 1\u00aa etapa: La BIOS \u00b6 Al encender el equipo, toma el control la BIOS que realiza una serie de operaciones b\u00e1sicas de hardware, programa POST . Una vez que el hardware es reconocido y queda listo para usar, la BIOS carga en memoria el c\u00f3digo executable del cargador de arranque y le pasa el control. 2\u00aa Etapa: Fase del cargador de arranque GRUB o LILO \u00b6 Un cargador de arranque ( bootloader en ingl\u00e9s) es un programa dise\u00f1ado exclusivamente para cargar un sistema operativo en memoria. La etapa del cargador de arranque es diferente de una plataforma a otra. Note Como en la mayor\u00eda de arquitecturas este programa se encuentra en el MBR o GPT , el cual es de 512 bytes, este espacio no es suficiente para cargar en su totalidad un sistema operativo. Por eso, el cargador de arranque consta de varias etapas. Las primeras operaciones las realiza la BIOS . Esquema MBR Esquema GPT De forma general esta etapa tiene dos fases: Se localiza el sector de arranque (GPT o MBR) y Se carga el cargador de este sector (normalmente una parte de LILO o GRUB ).el cargador de arranque carga un mensaje que pregunta que sistema operativo (o tipo de sesi\u00f3n) el usuario desea inicializar. Nota El gestor incluye datos como la partici\u00f3n de arranque y la localizaci\u00f3n del kernel para cada uno, as\u00ed como las opciones personalizadas en su caso. GRUB \u00b6 GRUB contiene una serie de funciones que lo convierten en el m\u00e9todo favorito respecto al resto de gestores de arranque disponibles para la arquitectura x86; entre las que destacan GRUB proporciona un verdadero entorno basado en comandos , pre-sistema operativo. El GRUB puede leer particiones ext2/3/4 . Esta funcionalidad le permite al GRUB acceder a su archivo de configuraci\u00f3n, /boot/grub/grub.conf Posibilidad de utilizar una etapa 1.5 si fuera necesario; A veces esto sucede cuando la partici\u00f3n /boot/ se encuentra por encima de los 1024 cilindros de disco duro o cuando utiliza el modo LBA. Muestra el men\u00fa de inicio que permite al usuario elegir un sistema operativo , tambi\u00e9n examinar y modificar los par\u00e1metros de inicio. Contiene tres interfaces: un men\u00fa de selecci\u00f3n, un editor de configuraci\u00f3n, y una consola de l\u00ednea de comandos. Un ejemplo de configuraci\u00f3n en ubuntu se podr\u00eda hacer desde: /boot/grub/grub.cfg \u2190 Configuraci\u00f3n general /etc/default/grub \u2190 Configuraci\u00f3n men\u00fa sudo update-grub \u2190 Actualizar cambios Ejemplo de GRUB Ejemplo de GRUB LILO \u00b6 LILO es m\u00e1s antiguo a GRUB, es casi id\u00e9ntico a GRUB en su proceso excepto que no contiene una interfaz de l\u00ednea de comandos . Por lo tanto todos los cambios en su configuraci\u00f3n deben ser escritos en el MBR y luego reiniciar el sistema. Warning Un error en la configuraci\u00f3n puede dejar el disco inservible para el proceso de arranque hasta tal grado, que sea necesario usar otro dispositivo (disquete, etc) que contenga un programa capaz de arreglar el error. Diferencias entre LILO y GRUB \u00b6 LILO no entiende los sistemas de archivos, por lo que utiliza desplazamientos de disco sin procesar y el BIOS para cargar los datos. Se carga el c\u00f3digo del men\u00fa y, a continuaci\u00f3n, en funci\u00f3n de la respuesta, carga, o el sector MBR del disco de 512 bytes como en Microsoft Windows, o la imagen del n\u00facleo Linux. GRUB por el contrario comprende los sistemas de archivos comunes ext2 , ext3 y ext4. Debido a que GRUB almacena sus datos en un archivo de configuraci\u00f3n en vez de en el MBR y a que contiene un interfaz de l\u00ednea de comandos, a menudo es m\u00e1s f\u00e1cil rectificar o modificar GRUB si est\u00e1 mal configurado o corrupto. 3\u00aa etapa: Fase del kernel \u00b6 El kernel de Linux se encarga de todos los procesos del sistema operativo , como la gesti\u00f3n de memoria, planificador de tareas, I/O, comunicaci\u00f3n entre procesos, y el control general del sistema. Este se carga en dos fases: Fase de carga : En la primera etapa el kernel se carga y se descomprime en memoria, como un archivo imagen comprimido. El objetivo es cargar algunas funciones fundamentales como la gesti\u00f3n de memoria. Fase de ejecuci\u00f3n : el kernel busca un proceso de inicio para ejecutar , que (separadamente) fija un espacio de usuario y los procesos necesarios para un entorno del mismo. A continuaci\u00f3n al nucleo se le permite pasar a inactivo, sujeto a las llamadas de otros procesos. Nota El kernel generalmente se almacena en un archivo comprimido. Este archivo comprimido se carga y se descomprime en memoria. Por otra parte, tambi\u00e9n se cargan los drivers necesarios mediante el initrd. El initrd crea un sistema de archivos temporal usado en la fase de ejecuci\u00f3n del kernel. 4\u00aa etapa: El proceso de inicio \u00b6 El trabajo de Init es conseguir que todo funcione como debe ser \" una vez que el kernel est\u00e1 totalmente en funcionamiento. En esencia, establece y opera todo el espacio de usuario. Importante Esto incluye la comprobaci\u00f3n y montaje de sistemas de archivos, la puesta en marcha de los servicios de usuario necesarios y, en \u00faltima instancia, cambiar al entorno de usuario cuando el inicio del sistema se ha completado. En un sistema Linux est\u00e1ndar, Init se ejecuta con un par\u00e1metro, conocido como nivel de ejecuci\u00f3n, que tiene un valor entre 1 y 6, y que determina qu\u00e9 subsistemas pueden ser operacionales. Cada nivel de ejecuci\u00f3n tiene sus propios scripts que codifican los diferentes procesos involucrados en la creaci\u00f3n o salida del nivel de ejecuci\u00f3n determinado, y son estas secuencias de comandos los necesarios en el proceso de arranque. Arranque de Windows y Windows Server \u00b6 Windows \u00b6 La secuencia de arranque de Windows utiliza el sistema de almacenamiento y configuraci\u00f3n de arranque denominado BCD store ( Boot Configuration Data ). Este registro se encuentra situado en el directorio \\boot\\BCD de la partici\u00f3n donde se instala el sistema de forma oculta y en binario. Consiste en un repositorio de datos y par\u00e1metros necesarios para gestionar el arranque del sistema. El fichero Bootmgr.exe es el encargado del administrador y cargador de arranque (boot loader). La secuencia de arranque sigue los siguientes pasos: La BIOS carga el MBR (master boot record, registro de arranque principal es el primer sector de un dispositivo de almacenamiento de datos), en memoria el cual analiza la tabla de particiones y carga en memoria el sector de arranque de la partici\u00f3n marcada como activa en la que se encuentra el S.O Windows . El sector de arranque localiza el bootmgr y se ejecuta, busca el directorio \\boot que contiene los programas que inician el sistema. Dentro del directorio se ejecuta el BCD apareciendo un men\u00fa en que se selecciona el sistema que se desea arrancar comenzando la carga del n\u00facleo de sistema. Windows Server \u00b6 En Windows Server se encuentan unas caracter\u00edsticas avanzadas entre las que destacan: Usa un nuevo almac\u00e9n de datos para los datos de configuraci\u00f3n de arranque, Boot.ini sustituye al anterior cargador de Windows ( Ntldr.exe ). Incluye tambi\u00e9n un administrador de arranque de Windows y un cargador de arranque de Windows nuevos. A partir del Windows Server 2008, encontramos 3 aplicaciones de arranque: Bootmgr.exe o Bootmgr.efi (Arranque). Esta aplicaci\u00f3n es independiente del sistema operativo y hace uso del firmware para cargar el cargador de arranque de Windows, ya sea desde una partici\u00f3n de disco concreta o a trav\u00e9s de una conexi\u00f3n de red (si se trata de un arranque con acceso a red). Winload.exe o Winload.efi (Arranque). Esta aplicaci\u00f3n forma parte del sistema operativo y carga una versi\u00f3n espec\u00edfica de Windows. Usa el firmware para cargar el kernel del sistema operativo, as\u00ed como para iniciar los controladores de dispositivo cr\u00edticos desde un disco duro local. Winresume.exe o Winresume.efi (Reanudaci\u00f3n). El Cargador de reanudaci\u00f3n de Windows encuentra una imagen de hibernaci\u00f3n y, a continuaci\u00f3n, usa el firmware para leer el archivo de hibernaci\u00f3n en la memoria RAM y reanudar el sistema operativo en estado de hibernaci\u00f3n. Caracter\u00edsticas Bootmgr Podemos realizar el siguiente resumen del proceso de arranque: Se inicia la BIOS Se carga el MBR del disco Carga el sector de arranque Carga el Windows Boot Manager Lee desde el BCD, (Boot Configuration Data) Busca archivos de hibernaci\u00f3n Inicia el programa Winload.exe, (carga el kernel del Sistema operativo) Inicia el programa ntoskrnl.exe, (imagen del kernel de Windows) Inicia el programa smss.exe, (administrador de secciones) Inicia el programa winlogon (valida la identificaci\u00f3n del usuario en el sistema) Finaliza iniciando los servicios y la interface de login. Modificaci\u00f3n Arranque. \u00b6 Se puede editar el arranque en Windows Server ejecutando el comando msconfig y en la pesta\u00f1a Arranque modificar las opciones del mismo. El administrador y cargador del sistema de arranque se edita con el comando bcdedit . Ejemplo Ejemplo de modificaci\u00f3n de bcdedit -> Enlace:Ejemplos de par\u00e1metros usados en el editor BCDEdit.exe Ejemplo Powershell T\u00e1mbien mediante Powershell -> Enlace:Modify Windows BCD using Powershell Daemon \u00b6 Daemon , servicio o programa residente es es un tipo especial de programa que se ejecuta en segundo plano, en vez de ser controlado directamente por el usuario. Estos programas se encuentran cargados en memoria de forma permanente durante la ejecuci\u00f3n del sistema operativo. Son los encargados de ofrecer un servicio al resto de programas o incluso otros demonios. Suelen iniciarse con el sistema operativo y se apagan con \u00e9l. Los daemon suelen tener las siguientes caracter\u00edsticas: No disponen de una \"interfaz\" directa con el usuario, ya sea gr\u00e1fica o textual. No hacen uso de las entradas y salidas est\u00e1ndar para comunicar errores o registrar su funcionamiento , sino que usan archivos del sistema en zonas especiales. Registro funcionamiento servicios /var/log/ en los UNIX m\u00e1s modernos o utilizan otros daemon especializados en dicho registro como el syslogd . Ejemplo Por ejemplo, una m\u00e1quina que alberga un servidor web utilizar\u00e1 un daemon httpd (HTTP Daemon) para ofrecer el servicio y que los visitantes a dicha web puedan acceder. Historia Seg\u00fan una investigaci\u00f3n realizada por Richard Steinberg , la palabra daemon fue utilizada en 1963 por primera vez, en el \u00e1rea de la inform\u00e1tica, para denominar a un proceso que realizaba backups en unas cintas . Este proceso se utiliz\u00f3 en el proyecto MAC del MIT y en una computadora IBM 7094 . Nota Los programas daemon reciben este nombre en los sistemas UNIX. En otros sistemas existen procesos similares como los TSRs de MS-DOS o los servicios de Windows . Ejemplo Daemons Systemd \u00b6 SystemD es un gestor de sistema desarrollado a partir de 2009 en principio para la distribuci\u00f3n Red Hat, pero que ha acabado siendo adoptado por la mayor\u00eda de las distribuciones modernas de linux, excepto *slackware y gentoo. A pesar que SystemD utiliza caracter\u00edsticas exclusivas de linux (por lo tanto no es implementable para otros unices) se ha convertido en el est\u00e1ndar de facto para el arranque de los sistemas linux. SystemD est\u00e1 constituido por un conjunto de demonios o daemons de administraci\u00f3n de sistema, bibliotecas y herramientas dise\u00f1ados como una plataforma de administraci\u00f3n y configuraci\u00f3n central para interactuar con el n\u00facleo del Sistema operativo GNU/Linux. Caracter\u00edsticas: Descrito por sus autores como un \" bloque de construcci\u00f3n b\u00e1sico \" para un sistema operativo. Se puede utilizar como un sistema de inicio de Linux (a\u00f1adiendo el proceso init a su conjunto de procesos). El nombre systemd se adhiere a la convenci\u00f3n Unix de distinguir los demonios f\u00e1cilmente por tener la letra d como la \u00faltima letra del nombre de archivo. Uno de los principales objetivos de systemd es unificar configuraciones b\u00e1sicas de Linux y los comportamientos de servicios en todas las distribuciones. Inicio de systemd en Fedora 17 Historia Systemd se desarroll\u00f3 para reemplazar el sistema de inicio ( init ) heredado de los sistemas operativos estilo UNIX System V y Berkeley Software Distribution (BSD) . La idea de dise\u00f1o est\u00e1 pensada en proveer un framework que exprese las dependencias del servicio con la API de Linux, permite hacer m\u00e1s trabajo paralelamente al inicio del sistema y reducir la sobrecarga del shell. Hacia 2015 , la mayor\u00eda de las principales distribuciones de Linux han adoptado systemd como su sistema de inicio predeterminado. Nota En el proceso de arranque en Linux , es el primer proceso que se ejecuta en el espacio de usuario , por lo tanto, tambi\u00e9n es el proceso padre de todos los procesos hijos en el espacio de usuario. Arquitectura de Systemd el comando systemctl , que es la herramienta de administraci\u00f3n central para controlar el sistema init. Nota Aunque no es competencia de este m\u00f3dulo el estudio de c\u00f3mo administrar servicios, comprobar estados, cambiar estados del sistema y trabajar con los archivos de configuraci\u00f3n, se recomiendan los siguientes enlaces . Enlace oficial de Red Hat de Systemd. Systemd Red Hat Nota : posiblemente sea necesaria cuenta gratuita. En el siguiente enlace se puede observar un resumen de los comandos principales para la Administraci\u00f3n de servicios. ENLACE : Administraci\u00f3n de Servicios Actividades \u00b6 En esta pr\u00e1ctica se van a instalar dos sistemas operativos en una misma m\u00e1quina virtual (y disco duro). Debemos crear un sistema de arranque que nos permita elegir el sistema operativo con el que deseamos arrancar nuestro equipo. Para ello, sigue los pasos que se describen a continuaci\u00f3n. Crea una m\u00e1quina virtual denominada \u201c Dual \u201d. Particiona el disco para contener un sistema operativo cliente de Microsoft, uno basado en GNU/Linux y dos particiones de datos, con los nombres DOCUMENTOS y EXPEDIENTES que podr\u00e1n ser accedidas sea cual sea el sistema operativo que se arranque. Crea un esquema con las particiones, su tama\u00f1o y el sistema de archivos que se usar\u00e1 en cada caso. El particionado se realizar\u00e1 con el sistema MBR. Instala los sistemas operativos en el siguiente orden: Microsoft Windows 10 y Ubuntu Desktop. Al finalizar la instalaci\u00f3n, debe quedar un men\u00fa de inicio con varios sistemas operativos. men\u00fa GRUB . Una vez instalados los sistemas operativos en el mismo disco duro, modifica el GRUB para que el sistema operativo a iniciar por defecto sea el de Microsoft y que espere 15 segundos antes de iniciarlo. Realiza esta tarea en CLI. Modifica el GRUB de para que se inicie el sistema operativo de Ubuntu por defecto pero que el tiempo empleado sea de 5 segundos antes de iniciarlo. Investiga y Contesta las siguiente cuestiones: (Puedes apoyarte en la m\u00e1quina virtual para resolverlas). \u00bfQu\u00e9 debemos hacer para que, aunque ese instalado el servidor gr\u00e1fico, la m\u00e1quina arranque sin \u00e9l. Justifique convenientemente la respuesta. Comprobar si el servidor SSH ha arrancado correctamente. Supongamos que descubrimos que, tras arrancar el sistema, SSH no ha arrancado como esper\u00e1bamos que hiciera. \u00bfQu\u00e9 podemos mirar para diagnosticar qu\u00e9 ha fallado? Considere dos posibilidades: ol.criterio { list-style-type: none; } a) Que el servicio no ha arrancado porque fall\u00f3 su arranque. b) Que ni siquiera se intent\u00f3 el arranque. Describa qu\u00e9 ocurre si se hace lo siguiente: apt-get update && apt-get install -y isc-dhcp-server systemctl disable isc-dhcp-server Compruebe si ha fallado el arranque de alg\u00fan servicio durante el proceso de arranque del sistema.","title":"3.5- Arranque del sistema. Servicios. Systemd."},{"location":"03_Procesos/035_ArranqueServicios.html#arranque-del-sistema-servicios-systemd","text":"En inform\u00e1tica, el arranque o secuencia de arranque (en ingl\u00e9s: bootstrapping, boot o booting ) se define: Definici\u00f3n Arranque del sistema Es el proceso que inicia el gestor de arranque; programa ejecutado por el Software BIOS cuando se enciende una computadora. Se encarga de la inicializaci\u00f3n del sistema operativo y de los dispositivos . A nivel conceptual los pasos de arranque de un sistema inform\u00e1tico se muestran en la siguiente figura: Pasos Arranque","title":"Arranque del sistema. Servicios. Systemd"},{"location":"03_Procesos/035_ArranqueServicios.html#arranque-en-linux","text":"En Linux, el flujo de control durante el arranque se desarrolla en 4 etapas: Al principio, toma el control la BIOS. En una segunda etapa, tomar\u00e1 el control el cargador de arranque. En una tercera etapa, el control pasa al propio kernel Linux. Y en la cuarta y \u00faltima etapa tendremos en memoria los programas de usuario conviviendo junto con el propio sistema operativo, quienes tomar\u00e1n el control del sistema. Pasos Arranque Linux","title":"Arranque en Linux"},{"location":"03_Procesos/035_ArranqueServicios.html#1a-etapa-la-bios","text":"Al encender el equipo, toma el control la BIOS que realiza una serie de operaciones b\u00e1sicas de hardware, programa POST . Una vez que el hardware es reconocido y queda listo para usar, la BIOS carga en memoria el c\u00f3digo executable del cargador de arranque y le pasa el control.","title":"1\u00aa etapa: La BIOS"},{"location":"03_Procesos/035_ArranqueServicios.html#2a-etapa-fase-del-cargador-de-arranque-grub-o-lilo","text":"Un cargador de arranque ( bootloader en ingl\u00e9s) es un programa dise\u00f1ado exclusivamente para cargar un sistema operativo en memoria. La etapa del cargador de arranque es diferente de una plataforma a otra. Note Como en la mayor\u00eda de arquitecturas este programa se encuentra en el MBR o GPT , el cual es de 512 bytes, este espacio no es suficiente para cargar en su totalidad un sistema operativo. Por eso, el cargador de arranque consta de varias etapas. Las primeras operaciones las realiza la BIOS . Esquema MBR Esquema GPT De forma general esta etapa tiene dos fases: Se localiza el sector de arranque (GPT o MBR) y Se carga el cargador de este sector (normalmente una parte de LILO o GRUB ).el cargador de arranque carga un mensaje que pregunta que sistema operativo (o tipo de sesi\u00f3n) el usuario desea inicializar. Nota El gestor incluye datos como la partici\u00f3n de arranque y la localizaci\u00f3n del kernel para cada uno, as\u00ed como las opciones personalizadas en su caso.","title":"2\u00aa Etapa: Fase del cargador de arranque GRUB o LILO"},{"location":"03_Procesos/035_ArranqueServicios.html#3a-etapa-fase-del-kernel","text":"El kernel de Linux se encarga de todos los procesos del sistema operativo , como la gesti\u00f3n de memoria, planificador de tareas, I/O, comunicaci\u00f3n entre procesos, y el control general del sistema. Este se carga en dos fases: Fase de carga : En la primera etapa el kernel se carga y se descomprime en memoria, como un archivo imagen comprimido. El objetivo es cargar algunas funciones fundamentales como la gesti\u00f3n de memoria. Fase de ejecuci\u00f3n : el kernel busca un proceso de inicio para ejecutar , que (separadamente) fija un espacio de usuario y los procesos necesarios para un entorno del mismo. A continuaci\u00f3n al nucleo se le permite pasar a inactivo, sujeto a las llamadas de otros procesos. Nota El kernel generalmente se almacena en un archivo comprimido. Este archivo comprimido se carga y se descomprime en memoria. Por otra parte, tambi\u00e9n se cargan los drivers necesarios mediante el initrd. El initrd crea un sistema de archivos temporal usado en la fase de ejecuci\u00f3n del kernel.","title":"3\u00aa etapa: Fase del kernel"},{"location":"03_Procesos/035_ArranqueServicios.html#arranque-de-windows-y-windows-server","text":"","title":"Arranque de Windows y Windows Server"},{"location":"03_Procesos/035_ArranqueServicios.html#windows","text":"La secuencia de arranque de Windows utiliza el sistema de almacenamiento y configuraci\u00f3n de arranque denominado BCD store ( Boot Configuration Data ). Este registro se encuentra situado en el directorio \\boot\\BCD de la partici\u00f3n donde se instala el sistema de forma oculta y en binario. Consiste en un repositorio de datos y par\u00e1metros necesarios para gestionar el arranque del sistema. El fichero Bootmgr.exe es el encargado del administrador y cargador de arranque (boot loader). La secuencia de arranque sigue los siguientes pasos: La BIOS carga el MBR (master boot record, registro de arranque principal es el primer sector de un dispositivo de almacenamiento de datos), en memoria el cual analiza la tabla de particiones y carga en memoria el sector de arranque de la partici\u00f3n marcada como activa en la que se encuentra el S.O Windows . El sector de arranque localiza el bootmgr y se ejecuta, busca el directorio \\boot que contiene los programas que inician el sistema. Dentro del directorio se ejecuta el BCD apareciendo un men\u00fa en que se selecciona el sistema que se desea arrancar comenzando la carga del n\u00facleo de sistema.","title":"Windows"},{"location":"03_Procesos/035_ArranqueServicios.html#windows-server","text":"En Windows Server se encuentan unas caracter\u00edsticas avanzadas entre las que destacan: Usa un nuevo almac\u00e9n de datos para los datos de configuraci\u00f3n de arranque, Boot.ini sustituye al anterior cargador de Windows ( Ntldr.exe ). Incluye tambi\u00e9n un administrador de arranque de Windows y un cargador de arranque de Windows nuevos. A partir del Windows Server 2008, encontramos 3 aplicaciones de arranque: Bootmgr.exe o Bootmgr.efi (Arranque). Esta aplicaci\u00f3n es independiente del sistema operativo y hace uso del firmware para cargar el cargador de arranque de Windows, ya sea desde una partici\u00f3n de disco concreta o a trav\u00e9s de una conexi\u00f3n de red (si se trata de un arranque con acceso a red). Winload.exe o Winload.efi (Arranque). Esta aplicaci\u00f3n forma parte del sistema operativo y carga una versi\u00f3n espec\u00edfica de Windows. Usa el firmware para cargar el kernel del sistema operativo, as\u00ed como para iniciar los controladores de dispositivo cr\u00edticos desde un disco duro local. Winresume.exe o Winresume.efi (Reanudaci\u00f3n). El Cargador de reanudaci\u00f3n de Windows encuentra una imagen de hibernaci\u00f3n y, a continuaci\u00f3n, usa el firmware para leer el archivo de hibernaci\u00f3n en la memoria RAM y reanudar el sistema operativo en estado de hibernaci\u00f3n. Caracter\u00edsticas Bootmgr Podemos realizar el siguiente resumen del proceso de arranque: Se inicia la BIOS Se carga el MBR del disco Carga el sector de arranque Carga el Windows Boot Manager Lee desde el BCD, (Boot Configuration Data) Busca archivos de hibernaci\u00f3n Inicia el programa Winload.exe, (carga el kernel del Sistema operativo) Inicia el programa ntoskrnl.exe, (imagen del kernel de Windows) Inicia el programa smss.exe, (administrador de secciones) Inicia el programa winlogon (valida la identificaci\u00f3n del usuario en el sistema) Finaliza iniciando los servicios y la interface de login.","title":"Windows Server"},{"location":"03_Procesos/035_ArranqueServicios.html#modificacion-arranque","text":"Se puede editar el arranque en Windows Server ejecutando el comando msconfig y en la pesta\u00f1a Arranque modificar las opciones del mismo. El administrador y cargador del sistema de arranque se edita con el comando bcdedit . Ejemplo Ejemplo de modificaci\u00f3n de bcdedit -> Enlace:Ejemplos de par\u00e1metros usados en el editor BCDEdit.exe Ejemplo Powershell T\u00e1mbien mediante Powershell -> Enlace:Modify Windows BCD using Powershell","title":"Modificaci\u00f3n Arranque."},{"location":"03_Procesos/035_ArranqueServicios.html#daemon","text":"Daemon , servicio o programa residente es es un tipo especial de programa que se ejecuta en segundo plano, en vez de ser controlado directamente por el usuario. Estos programas se encuentran cargados en memoria de forma permanente durante la ejecuci\u00f3n del sistema operativo. Son los encargados de ofrecer un servicio al resto de programas o incluso otros demonios. Suelen iniciarse con el sistema operativo y se apagan con \u00e9l. Los daemon suelen tener las siguientes caracter\u00edsticas: No disponen de una \"interfaz\" directa con el usuario, ya sea gr\u00e1fica o textual. No hacen uso de las entradas y salidas est\u00e1ndar para comunicar errores o registrar su funcionamiento , sino que usan archivos del sistema en zonas especiales. Registro funcionamiento servicios /var/log/ en los UNIX m\u00e1s modernos o utilizan otros daemon especializados en dicho registro como el syslogd . Ejemplo Por ejemplo, una m\u00e1quina que alberga un servidor web utilizar\u00e1 un daemon httpd (HTTP Daemon) para ofrecer el servicio y que los visitantes a dicha web puedan acceder. Historia Seg\u00fan una investigaci\u00f3n realizada por Richard Steinberg , la palabra daemon fue utilizada en 1963 por primera vez, en el \u00e1rea de la inform\u00e1tica, para denominar a un proceso que realizaba backups en unas cintas . Este proceso se utiliz\u00f3 en el proyecto MAC del MIT y en una computadora IBM 7094 . Nota Los programas daemon reciben este nombre en los sistemas UNIX. En otros sistemas existen procesos similares como los TSRs de MS-DOS o los servicios de Windows . Ejemplo Daemons","title":"Daemon"},{"location":"03_Procesos/035_ArranqueServicios.html#systemd","text":"SystemD es un gestor de sistema desarrollado a partir de 2009 en principio para la distribuci\u00f3n Red Hat, pero que ha acabado siendo adoptado por la mayor\u00eda de las distribuciones modernas de linux, excepto *slackware y gentoo. A pesar que SystemD utiliza caracter\u00edsticas exclusivas de linux (por lo tanto no es implementable para otros unices) se ha convertido en el est\u00e1ndar de facto para el arranque de los sistemas linux. SystemD est\u00e1 constituido por un conjunto de demonios o daemons de administraci\u00f3n de sistema, bibliotecas y herramientas dise\u00f1ados como una plataforma de administraci\u00f3n y configuraci\u00f3n central para interactuar con el n\u00facleo del Sistema operativo GNU/Linux. Caracter\u00edsticas: Descrito por sus autores como un \" bloque de construcci\u00f3n b\u00e1sico \" para un sistema operativo. Se puede utilizar como un sistema de inicio de Linux (a\u00f1adiendo el proceso init a su conjunto de procesos). El nombre systemd se adhiere a la convenci\u00f3n Unix de distinguir los demonios f\u00e1cilmente por tener la letra d como la \u00faltima letra del nombre de archivo. Uno de los principales objetivos de systemd es unificar configuraciones b\u00e1sicas de Linux y los comportamientos de servicios en todas las distribuciones. Inicio de systemd en Fedora 17 Historia Systemd se desarroll\u00f3 para reemplazar el sistema de inicio ( init ) heredado de los sistemas operativos estilo UNIX System V y Berkeley Software Distribution (BSD) . La idea de dise\u00f1o est\u00e1 pensada en proveer un framework que exprese las dependencias del servicio con la API de Linux, permite hacer m\u00e1s trabajo paralelamente al inicio del sistema y reducir la sobrecarga del shell. Hacia 2015 , la mayor\u00eda de las principales distribuciones de Linux han adoptado systemd como su sistema de inicio predeterminado. Nota En el proceso de arranque en Linux , es el primer proceso que se ejecuta en el espacio de usuario , por lo tanto, tambi\u00e9n es el proceso padre de todos los procesos hijos en el espacio de usuario. Arquitectura de Systemd el comando systemctl , que es la herramienta de administraci\u00f3n central para controlar el sistema init. Nota Aunque no es competencia de este m\u00f3dulo el estudio de c\u00f3mo administrar servicios, comprobar estados, cambiar estados del sistema y trabajar con los archivos de configuraci\u00f3n, se recomiendan los siguientes enlaces . Enlace oficial de Red Hat de Systemd. Systemd Red Hat Nota : posiblemente sea necesaria cuenta gratuita. En el siguiente enlace se puede observar un resumen de los comandos principales para la Administraci\u00f3n de servicios. ENLACE : Administraci\u00f3n de Servicios","title":"Systemd"},{"location":"03_Procesos/035_ArranqueServicios.html#actividades","text":"En esta pr\u00e1ctica se van a instalar dos sistemas operativos en una misma m\u00e1quina virtual (y disco duro). Debemos crear un sistema de arranque que nos permita elegir el sistema operativo con el que deseamos arrancar nuestro equipo. Para ello, sigue los pasos que se describen a continuaci\u00f3n. Crea una m\u00e1quina virtual denominada \u201c Dual \u201d. Particiona el disco para contener un sistema operativo cliente de Microsoft, uno basado en GNU/Linux y dos particiones de datos, con los nombres DOCUMENTOS y EXPEDIENTES que podr\u00e1n ser accedidas sea cual sea el sistema operativo que se arranque. Crea un esquema con las particiones, su tama\u00f1o y el sistema de archivos que se usar\u00e1 en cada caso. El particionado se realizar\u00e1 con el sistema MBR. Instala los sistemas operativos en el siguiente orden: Microsoft Windows 10 y Ubuntu Desktop. Al finalizar la instalaci\u00f3n, debe quedar un men\u00fa de inicio con varios sistemas operativos. men\u00fa GRUB . Una vez instalados los sistemas operativos en el mismo disco duro, modifica el GRUB para que el sistema operativo a iniciar por defecto sea el de Microsoft y que espere 15 segundos antes de iniciarlo. Realiza esta tarea en CLI. Modifica el GRUB de para que se inicie el sistema operativo de Ubuntu por defecto pero que el tiempo empleado sea de 5 segundos antes de iniciarlo. Investiga y Contesta las siguiente cuestiones: (Puedes apoyarte en la m\u00e1quina virtual para resolverlas). \u00bfQu\u00e9 debemos hacer para que, aunque ese instalado el servidor gr\u00e1fico, la m\u00e1quina arranque sin \u00e9l. Justifique convenientemente la respuesta. Comprobar si el servidor SSH ha arrancado correctamente. Supongamos que descubrimos que, tras arrancar el sistema, SSH no ha arrancado como esper\u00e1bamos que hiciera. \u00bfQu\u00e9 podemos mirar para diagnosticar qu\u00e9 ha fallado? Considere dos posibilidades: ol.criterio { list-style-type: none; } a) Que el servicio no ha arrancado porque fall\u00f3 su arranque. b) Que ni siquiera se intent\u00f3 el arranque. Describa qu\u00e9 ocurre si se hace lo siguiente: apt-get update && apt-get install -y isc-dhcp-server systemctl disable isc-dhcp-server Compruebe si ha fallado el arranque de alg\u00fan servicio durante el proceso de arranque del sistema.","title":"Actividades"},{"location":"03_Procesos/036_AdministracionServicios.html","text":"Administraci\u00f3n de Servicios. \u00b6 Iniciar y detener servicios \u00b6 Para iniciar un servicio systemd , ejecutar instrucciones en el archivo de la unidad del servicio, utilice el comando start . Si est\u00e1 ejecutando como usuario non-root, tendr\u00e1 que usar sudo , ya que esto afectar\u00e1 al estado del sistema operativo. sudo systemctl start application.service Como hemos mencionado antes, systemd sabe buscar los archivos *.service para los comandos de administraci\u00f3n de servicio, de forma que el comando podr\u00eda escribirse f\u00e1cilmente as\u00ed: sudo systemctl start application Aunque puede usar el formato anterior para la administraci\u00f3n general, para mayor claridad, usaremos el sufijo .service para el resto de los comandos, con el objetivo de ser expl\u00edcitos sobre el destino en el que estamos operando. Para detener un servicio que se est\u00e9 ejecutando actualmente, puede usar el comando stop : sudo systemctl stop application.service Reiniciar y volver a cargar \u00b6 Para reiniciar un servicio en ejecuci\u00f3n, puede usar el comando restart : sudo systemctl restart application.service Si la aplicaci\u00f3n en cuesti\u00f3n puede volver a cargar sus archivos de configuraci\u00f3n (sin reiniciar), puede emitir el comando reload para iniciar ese proceso: sudo systemctl reload application.service Si no est\u00e1 seguro de si el servicio tiene la funcionalidad de volver a cargar su configuraci\u00f3n, puede emitir el comando reload-or-restart . Esto volver\u00e1 a cargar la configuraci\u00f3n en vigor, si est\u00e1 disponible. De lo contrario, reiniciar\u00e1 el servicio de forma que se recoja la nueva configuraci\u00f3n: sudo systemctl reload-or-restart application.service C\u00f3mo habilitar y deshabilitar servicios \u00b6 Los comandos anteriores son \u00fatiles para iniciar o detener servicios durante la sesi\u00f3n actual. Para indicar a systemd que inicie servicios autom\u00e1ticamente en el arranque, debe habilitarlos. Para iniciar un servicio en el arranque, utilice el comando enable : sudo systemctl enable application.service Esto crear\u00e1 un enlace simb\u00f3lico desde la copia del sistema del archivo de servicio (normalmente en /lib/systemd/system o /etc/systemd/system ) en la ubicaci\u00f3n del disco donde systemd busca los archivos de inicio autom\u00e1tico (normalmente /etc/systemd/system/some_target.target.wants . Repasaremos qu\u00e9 es un destino m\u00e1s adelante en esta gu\u00eda). Para impedir que el servicio se inicie autom\u00e1ticamente, puede escribir: sudo systemctl disable application.service Esto eliminar\u00e1 el enlace simb\u00f3lico que indicaba que el servicio deb\u00eda iniciarse autom\u00e1ticamente. Tenga en cuenta que habilitar el servicio no lo inicia en la sesi\u00f3n actual. Si desea iniciar el servicio y habilitarlo en el arranque, tendr\u00e1 que emitir los comandos start y enable . C\u00f3mo comprobar el estado de los servicios \u00b6 Para comprobar el estado de un servicio en su sistema, puede usar el comando status : systemctl status application.service Esto le proporcionar\u00e1 el estado del servicio, la jerarqu\u00eda de cgroup y las primeras l\u00edneas de registro. Por ejemplo, cuando se comprueba el estado de un servidor Nginx, puede ver un resultado como este: Output\u25cf nginx.service - A high performance web server and a reverse proxy server Loaded: loaded ( /usr/lib/systemd/system/nginx.service ; enabled ; vendor preset: disabled ) Active: active ( running ) since Tue 2015 -01-27 19 :41:23 EST ; 22h ago Main PID: 495 ( nginx ) CGroup: /system.slice/nginx.service \u251c\u2500495 nginx: master process /usr/bin/nginx -g pid /run/nginx.pid ; error_log stderr ; \u2514\u2500496 nginx: worker process Jan 27 19 :41:23 desktop systemd [ 1 ] : Starting A high performance web server and a reverse proxy server... Jan 27 19 :41:23 desktop systemd [ 1 ] : Started A high performance web server and a reverse proxy server. Esto le proporciona una buena visi\u00f3n general del estado actual de la aplicaci\u00f3n, y le notifica de cualquier problema y cualquier acci\u00f3n que pueda ser necesaria. Tambi\u00e9n hay m\u00e9todos para comprobar los estados espec\u00edficos. Por ejemplo, para comprobar si una unidad est\u00e1 activa actualmente (ejecut\u00e1ndose) puede usar el comando is-active : systemctl is-active application.service Esto devolver\u00e1 el estado actual de la unidad, que es normalmente activo o inactivo . El c\u00f3digo de salida ser\u00e1 \"0\" si est\u00e1 activo, lo que hace que el resultado sea m\u00e1s sencillo de analizar en las secuencias de comando shell. Para ver si la unidad est\u00e1 habilitada, puede usar el comando is-enabled : systemctl is-enabled application.service Esto indicar\u00e1 si el servicio est\u00e1 habilitado o deshabilitado y establecer\u00e1 el c\u00f3digo de salida a \"0\" o \"1\", dependiendo de la respuesta a la pregunta del comando. Una tercera comprobaci\u00f3n es si la unidad est\u00e1 en estado fallido. Esto indica que hubo un problema al iniciar la unidad en cuesti\u00f3n: systemctl is-failed application.service Esto devolver\u00e1 active si se est\u00e1 ejecutando adecuadamente o failed si se ha producido un error. Si la unidad se detuvo intencionadamente, puede devolver unknown o inactive . Un estado de salida de \"0\" indica que se produjo un error y un estado de salida de \"1\" indica cualquier otro estado. Descripci\u00f3n general del estado del sistema \u00b6 Los comandos hasta ahora han sido \u00fatiles para administrar servicios individuales, pero no son muy \u00fatiles para explorar el estado actual del sistema. Hay varios comandos systemctl que proporcionan esta informaci\u00f3n. C\u00f3mo enumerar las unidades actuales \u00b6 Para ver una lista de todas las unidades activas que systemd conoce, podemos usar el comando list-units : systemctl list-units Esto le mostrar\u00e1 una lista de todas las unidades que systemd tiene activas actualmente en el sistema. El resultado tendr\u00e1 un aspecto similar a este: OutputUNIT LOAD ACTIVE SUB DESCRIPTION atd.service loaded active running ATD daemon avahi-daemon.service loaded active running Avahi mDNS/DNS-SD Stack dbus.service loaded active running D-Bus System Message Bus dcron.service loaded active running Periodic Command Scheduler dkms.service loaded active exited Dynamic Kernel Modules System getty@tty1.service loaded active running Getty on tty1 . . . El resultado tiene las siguientes columnas: UNIT: El nombre de la unidad de systemd LOAD: Si la configuraci\u00f3n de la unidad ha sido analizada por systemd . La configuraci\u00f3n de las unidades cargadas se mantiene en la memoria. ACTIVE: Un estado resumido que indica si la unidad est\u00e1 activa. Esta es normalmente una forma bastante b\u00e1sica de saber si la unidad se ha iniciado correctamente o no. SUB: Este es un estado de nivel inferior que indica informaci\u00f3n m\u00e1s detallada sobre la unidad. Esto a menudo var\u00eda por tipo de unidad, estado y el m\u00e9todo real en el que se ejecuta la unidad. DESCRIPTION: Una descripci\u00f3n textual breve de qu\u00e9 es y hace la unidad. Ya que el comando list-units muestra solo las unidades activas por defecto, todas las entradas por encima se mostrar\u00e1n loaded en la columna LOAD y active en la columna ACTIVE. Esta pantalla es, en realidad, el comportamiento predeterminado de systemctl cuando se invoca sin comandos adicionales, de modo que ver\u00e1 lo mismo si invoca systemctl sin argumentos: systemctl Podemos indicar a systemctl que produzca informaci\u00f3n diferente a\u00f1adiendo marcadores adicionales. Por ejemplo, para ver todas las unidades que systemd ha cargado (o intentado cargar), independientemente de si est\u00e1n activas actualmente, puede usar el marcador --all , de esta forma: systemctl list-units --all Esto mostrar\u00e1 cualquier unidad que systemd haya cargado o intentado cargar, independientemente de su estado actual en el sistema. Ciertas unidades se vuelven inactivas tras ejecutarse, y algunas de las unidades que systemd intent\u00f3 cargar pueden no haberse encontrado en el disco. Puede usar otros marcadores para filtrar estos resultados. Por ejemplo, puede usar el indicador --state= para indicar los estados LOAD, ACTIVE o SUB que deseamos ver. Tendremos que mantener el marcador --all para que systemctl permita que se muestren las unidades no activas: systemctl list-units --all --state = inactive Otro filtro com\u00fan es el filtro --type= . Podemos indicar a systemctl que solo muestre unidades del tipo en el que estemos interesados. Por ejemplo, para ver \u00fanicamente las unidades de servicio activas, podemos usar: systemctl list-units --type = service Listar todos los archivos de la unidad \u00b6 El comando list-units solo muestra las unidades que systemd ha intentado analizar y cargar en la memoria. Ya que systemd solo leer\u00e1 unidades que cree que necesita, esto no incluir\u00e1 necesariamente todas las unidades disponibles en el sistema. Para ver todos los archivos de unidad disponibles en las rutas systemd , incluidos aquellos que systemd no haya intentado cargar, puede usar el comando list-unit-files : systemctl list-unit-files Las unidades son representaciones de los recursos que systemd conoce. Ya que systemd no ha le\u00eddo necesariamente todas las definiciones de la unidades en esta vista, solo presente informaci\u00f3n sobre los propios archivos. El resultado tiene dos columnas, el archivo de la unidad y el estado. OutputUNIT FILE STATE proc-sys-fs-binfmt_misc.automount static dev-hugepages.mount static dev-mqueue.mount static proc-fs-nfsd.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount static var-lib-nfs-rpc_pipefs.mount static org.cups.cupsd.path enabled . . . El estado normalmente estar\u00e1 habilitado , deshabilitado , est\u00e1tico o enmascarado . En este contexto, \"est\u00e1tico\" significa que el archivo de unidad no contiene una secci\u00f3n install , que se utiliza para habilitar una unidad. Como tal, estas unidades no pueden habilitarse. Normalmente, esto significa que la unidad realiza una \u00fanica acci\u00f3n o se utiliza solo como dependencia de otra unidad y no deber\u00eda ejecutarse por s\u00ed misma. En breve explicaremos lo que significa enmascarado . Gesti\u00f3n de la unidad \u00b6 Hasta ahora, hemos estado trabajando con servicios y mostrando informaci\u00f3n sobre la unidad y los archivos de la unidad que systemd conoce. Sin embargo, encontraremos m\u00e1s informaci\u00f3n espec\u00edfica sobre las unidades usando algunos comandos adicionales. Mostrar un archivo de unidad \u00b6 Para mostrar el archivo de unidad que systemd ha cargado en su sistema, puede usar el comando cat (esto se a\u00f1adi\u00f3 en la versi\u00f3n 209 de systemd ). Por ejemplo, para ver el archivo de unidad del daemon de programaci\u00f3n atd , podr\u00edamos escribir: systemctl cat atd.service Output[Unit] Description=ATD daemon [Service] Type=forking ExecStart=/usr/bin/atd [Install] WantedBy=multi-user.target El resultado es el archivo de unidad tal como lo conoce el proceso systemd que se est\u00e1 ejecutando actualmente. Esto puede ser importante si ha modificado archivos de unidad recientemente o si est\u00e1 omitiendo ciertas opciones en un fragmento del archivo de unidad (hablaremos de esto m\u00e1s tarde). Mostrar dependencias \u00b6 Para ver el \u00e1rbol de dependencias de una unidad, puede usar el comando list-dependencies : systemctl list-dependencies sshd.service Esto mostrar\u00e1 una jerarqu\u00eda asignando las dependencias que deben tratarse para iniciar la unidad en cuesti\u00f3n. Las dependencias, en este contexto, incluyen las unidades que son necesarias o deseadas por unidades de nivel superior. Outputsshd.service \u251c\u2500system.slice \u2514\u2500basic.target \u251c\u2500microcode.service \u251c\u2500rhel-autorelabel-mark.service \u251c\u2500rhel-autorelabel.service \u251c\u2500rhel-configure.service \u251c\u2500rhel-dmesg.service \u251c\u2500rhel-loadmodules.service \u251c\u2500paths.target \u251c\u2500slices.target . . . Las dependencias recursivas solo se muestran para las unidades .target , que indican los estados del sistema. Para listar de forma recursiva todas las dependencias, incluya el indicador --all . Para mostrar las dependencias inversas (unidades que dependen de la unidad especificada) puede a\u00f1adir el indicador --reverse al comando. Otros indicadores que son \u00fatiles son los indicadores --before y --after , que pueden usarse para mostrar las unidades que dependen de la unidad especificada que comienza antes y despu\u00e9s de ellas mismas respectivamente. Comprobar las propiedades de la unidad \u00b6 Para ver las propiedades de nivel bajo de una unidad, puede usar el comando show . Esto mostrar\u00e1 una lista de propiedades que se establecen para la unidad especificada usando un formato key=value : systemctl show sshd.service OutputId=sshd.service Names=sshd.service Requires=basic.target Wants=system.slice WantedBy=multi-user.target Conflicts=shutdown.target Before=shutdown.target multi-user.target After=syslog.target network.target auditd.service systemd-journald.socket basic.target system.slice Description=OpenSSH server daemon . . . Si desea mostrar una \u00fanica propiedad, pude pasar el indicador -p con el nombre de la propiedad. Por ejemplo, para ver los conflictos que la unidad sshd.service tiene, puede escribir: systemctl show sshd.service -p Conflicts OutputConflicts = shutdown.target Enmascarar y desenmascarar unidades \u00b6 Vimos en la secci\u00f3n de administraci\u00f3n del servicio c\u00f3mo detener o deshabilitar un servicio, pero systemd tambi\u00e9n tiene la capacidad de marcar una unidad como completamente no iniciable, autom\u00e1tica o manualmente, vincul\u00e1ndola a /dev/null . Esto se denomina enmascarar la unidad, y es posible con el comando mask : sudo systemctl mask nginx.service Esto impedir\u00e1 que el servicio Nginx se inicie, autom\u00e1tica o manualmente, siempre que est\u00e9 enmascarado. Si comprueba los list-unit-files , ver\u00e1 que el servicio ahora se lista como enmascarado: systemctl list-unit-files Output. . . kmod-static-nodes.service static ldconfig.service static mandb.service static messagebus.service static nginx.service masked quotaon.service static rc-local.service static rdisc.service disabled rescue.service static . . . Si intenta iniciar el servicio, ver\u00e1 un mensaje como este: sudo systemctl start nginx.service OutputFailed to start nginx.service: Unit nginx.service is masked. Para desenmascarar una unidad, y hacer que est\u00e9 disponible de nuevo para su uso, utilice el comando unmask : sudo systemctl unmask nginx.service Esto devolver\u00e1 la unidad a su estado anterior, permitiendo que se inicie o habilite. Editar archivos de la unidad \u00b6 Aunque el formato espec\u00edfico de los archivos de unidad est\u00e1 fuera del alcance de este tutorial, si necesita realizar ajustes, systemctl proporciona mecanismos integrados para editar y modificar archivos de unidad. Esta funcionalidad fue a\u00f1adida en la versi\u00f3n 218 de systemd . El comando edit , por defecto, abrir\u00e1 un fragmento de c\u00f3digo del archivo de la unidad para la unidad en cuesti\u00f3n: sudo systemctl edit nginx.service Este ser\u00e1 un archivo en blanco que puede usarse para omitir o a\u00f1adir directivas a la definici\u00f3n de la unidad. Se crear\u00e1 un directorio en el directorio /etc/systemd/system que contiene el nombre de la unidad con .d anexada. Por ejemplo, para el nginx.service , se crear\u00e1 un directorio llamado nginx.service.d . En este directorio, se crear\u00e1 un fragmento de c\u00f3d igo llamado o verride.conf. Cuando se carga la unidad, systemd , en la memoria, fusionar\u00e1 el fragmento de c\u00f3digo de anulaci\u00f3n con el archivo de unidad completo. Las directivas del snippet prevalecer\u00e1n sobre las encontradas en el archivo original de la unidad. Si desea editar el archivo completo de la unidad en vez de crear un fragmento de c\u00f3digo, puede pasar el indicador --full : sudo systemctl edit --full nginx.service Esto cargar\u00e1 el archivo de unidad actual en el editor, donde se podr\u00e1 modificar. Cuando sale el editor, el archivo cambiado se escribir\u00e1 a /etc/systemd/system , que tendr\u00e1 prioridad sobre la definici\u00f3n de la unidad del sistema (normalmente se encuentra en alg\u00fan lugar de /lib/systemd/system ). Para eliminar cualquier adici\u00f3n que haya realizado, elimine el directorio de configuraci\u00f3n .d de la unidad o el archivo de servicio modificado de /etc/systemd/system . Por ejemplo, para eliminar un fragmento de c\u00f3digo, podr\u00edamos escribir lo siguiente: sudo rm -r /etc/systemd/system/nginx.service.d Para eliminar un archivo de unidad completo modificado, escribir\u00edamos: sudo rm /etc/systemd/system/nginx.service Tras eliminar el archivo o directorio, deber\u00eda volver a cargar el proceso systemd de forma que deje de intentar hacer referencia a estos archivos y vuelve a usar las copias del sistema. Puede hacerlo escribiendo lo siguiente: sudo systemctl daemon-reload Ajustar el estado del sistema (Runlevel) con los destinos \u00b6 Los destinos son archivos de unidad especiales que describen el estado de un sistema o un punto de sincronizaci\u00f3n. Igual que otras unidades, los archivos que definen los destinos pueden identificarse por su sufijo, que en este caso es .target . Los destinos no hacen mucho por s\u00ed mismos, pero se utilizan para agrupar otras unidades. Esto puede usarse para llevar al sistema a ciertos estados, de forma muy similar que otros sistemas init utilizan runlevels. Se utilizan como referencia para cuando ciertas funciones est\u00e9n disponibles, lo que le permite especificar el estado deseado en vez de las unidades individuales necesarias para producir ese estado. Por ejemplo, hay un swap.target que se usa para indicar que swap est\u00e1 listo para usarse. Las unidades que son parte de este proceso pueden sincronizarse con este destino indicando en su configuraci\u00f3n que son WantedBy= o RequiredBy= el swap.target . Las unidades que requieren que swap est\u00e9 disponible pueden especificar esta condici\u00f3n usando las especificaciones Wants= , Requires= y After= para indicar la naturaleza de su relaci\u00f3n. Obtener y establecer el destino predeterminado \u00b6 El proceso systemd tiene un destino predeterminado que utiliza cuando se inicia el sistema. Satisfacer la cascada de dependencias de ese destino individual llevar\u00e1 al sistema al estado deseado. Para encontrar el destino predeterminado de su sistema, escriba: systemctl get-default Outputmulti-user.target Si desea establecer un destino predeterminado diferente, puede usar set-default . Por ejemplo, si tiene un escritorio gr\u00e1fico instalado y desea que el sistema se inicie a esto por defecto, puede cambiar el destino predeterminado: sudo systemctl set-default graphical.target C\u00f3mo enumerar los destinos disponibles \u00b6 Puede obtener una lista de los destinos disponibles en su sistema escribiendo: systemctl list-unit-files --type = target A diferencia de runlevels, puede haber m\u00faltiples destinos activos a la vez. Un destino activo indica que systemd ha intentado iniciar todas las unidades relacionadas con el destino y no ha intentado desglosarlas de nuevo. Para ver todos los destinos activos, escriba: systemctl list-units --type = target Aislar destinos \u00b6 Es posible iniciar todas las unidades asociadas con un destino y detener todas las que no son parte del \u00e1rbol de dependencias. El comando que necesitamos para hacer esto se denomina, apropiadamente, isolate . Esto es similar a cambiar el runlevel en otros sistemas init. Por ejemplo, si est\u00e1 operando en un entorno gr\u00e1fico con graphical.target activo, puede apagar el sistema gr\u00e1fico y poner el sistema en un estado de l\u00ednea de comando multi usuario asilando el multi-user.target . Ya que graphical.target depende de multi-user.target pero no al rev\u00e9s, todas las unidades gr\u00e1ficas se detendr\u00e1n. Quiz\u00e1 desee echar un vistazo a las dependencias del destino que est\u00e1 aislando antes de realizar este procedimiento para asegurarse de que no est\u00e1 deteniendo servicios cruciales: systemctl list-dependencies multi-user.target Cuando est\u00e9 satisfecho con las unidades que se mantendr\u00e1n activas, puede aislar el destino escribiendo lo siguiente: sudo systemctl isolate multi-user.target C\u00f3mo usar atajos para eventos importantes \u00b6 Existen destinos definidos para eventos importantes como apagar o reiniciar. Sin embargo, systemctl tambi\u00e9n tiene algunos atajos que a\u00f1aden ciertas funciones adicionales. Por ejemplo, para poner el sistema en el modo rescate (usuario \u00fanico), puede usar simplemente el comando rescue en vez de isolate rescue.target , sudo systemctl rescue Esto proporcionar\u00e1 la funcionalidad adicional de alertar a todos los usuarios con sesi\u00f3n iniciada sobre el evento. Para detener el sistema, puede usar el comando halt : sudo systemctl halt Para iniciar un apagado completo, puede usar el comando poweroff : sudo systemctl poweroff Puede iniciar un reinicio con el comando reboot : sudo systemctl reboot Nota Todos estos comandos alertan a los usuarios con sesi\u00f3n iniciada de que se va a producir el evento, algo que ejecutar o aislar el destino \u00fanicamente no har\u00e1. Observe que la mayor\u00eda de los equipos vincular\u00e1n los comandos m\u00e1s cortos y convencionales para estas operaciones de forma que funcionen adecuadamente con systemd .","title":"Administraci\u00f3n de Servicios."},{"location":"03_Procesos/036_AdministracionServicios.html#administracion-de-servicios","text":"","title":"Administraci\u00f3n de Servicios."},{"location":"03_Procesos/036_AdministracionServicios.html#iniciar-y-detener-servicios","text":"Para iniciar un servicio systemd , ejecutar instrucciones en el archivo de la unidad del servicio, utilice el comando start . Si est\u00e1 ejecutando como usuario non-root, tendr\u00e1 que usar sudo , ya que esto afectar\u00e1 al estado del sistema operativo. sudo systemctl start application.service Como hemos mencionado antes, systemd sabe buscar los archivos *.service para los comandos de administraci\u00f3n de servicio, de forma que el comando podr\u00eda escribirse f\u00e1cilmente as\u00ed: sudo systemctl start application Aunque puede usar el formato anterior para la administraci\u00f3n general, para mayor claridad, usaremos el sufijo .service para el resto de los comandos, con el objetivo de ser expl\u00edcitos sobre el destino en el que estamos operando. Para detener un servicio que se est\u00e9 ejecutando actualmente, puede usar el comando stop : sudo systemctl stop application.service","title":"Iniciar y detener servicios"},{"location":"03_Procesos/036_AdministracionServicios.html#reiniciar-y-volver-a-cargar","text":"Para reiniciar un servicio en ejecuci\u00f3n, puede usar el comando restart : sudo systemctl restart application.service Si la aplicaci\u00f3n en cuesti\u00f3n puede volver a cargar sus archivos de configuraci\u00f3n (sin reiniciar), puede emitir el comando reload para iniciar ese proceso: sudo systemctl reload application.service Si no est\u00e1 seguro de si el servicio tiene la funcionalidad de volver a cargar su configuraci\u00f3n, puede emitir el comando reload-or-restart . Esto volver\u00e1 a cargar la configuraci\u00f3n en vigor, si est\u00e1 disponible. De lo contrario, reiniciar\u00e1 el servicio de forma que se recoja la nueva configuraci\u00f3n: sudo systemctl reload-or-restart application.service","title":"Reiniciar y volver a cargar"},{"location":"03_Procesos/036_AdministracionServicios.html#como-habilitar-y-deshabilitar-servicios","text":"Los comandos anteriores son \u00fatiles para iniciar o detener servicios durante la sesi\u00f3n actual. Para indicar a systemd que inicie servicios autom\u00e1ticamente en el arranque, debe habilitarlos. Para iniciar un servicio en el arranque, utilice el comando enable : sudo systemctl enable application.service Esto crear\u00e1 un enlace simb\u00f3lico desde la copia del sistema del archivo de servicio (normalmente en /lib/systemd/system o /etc/systemd/system ) en la ubicaci\u00f3n del disco donde systemd busca los archivos de inicio autom\u00e1tico (normalmente /etc/systemd/system/some_target.target.wants . Repasaremos qu\u00e9 es un destino m\u00e1s adelante en esta gu\u00eda). Para impedir que el servicio se inicie autom\u00e1ticamente, puede escribir: sudo systemctl disable application.service Esto eliminar\u00e1 el enlace simb\u00f3lico que indicaba que el servicio deb\u00eda iniciarse autom\u00e1ticamente. Tenga en cuenta que habilitar el servicio no lo inicia en la sesi\u00f3n actual. Si desea iniciar el servicio y habilitarlo en el arranque, tendr\u00e1 que emitir los comandos start y enable .","title":"C\u00f3mo habilitar y deshabilitar servicios"},{"location":"03_Procesos/036_AdministracionServicios.html#como-comprobar-el-estado-de-los-servicios","text":"Para comprobar el estado de un servicio en su sistema, puede usar el comando status : systemctl status application.service Esto le proporcionar\u00e1 el estado del servicio, la jerarqu\u00eda de cgroup y las primeras l\u00edneas de registro. Por ejemplo, cuando se comprueba el estado de un servidor Nginx, puede ver un resultado como este: Output\u25cf nginx.service - A high performance web server and a reverse proxy server Loaded: loaded ( /usr/lib/systemd/system/nginx.service ; enabled ; vendor preset: disabled ) Active: active ( running ) since Tue 2015 -01-27 19 :41:23 EST ; 22h ago Main PID: 495 ( nginx ) CGroup: /system.slice/nginx.service \u251c\u2500495 nginx: master process /usr/bin/nginx -g pid /run/nginx.pid ; error_log stderr ; \u2514\u2500496 nginx: worker process Jan 27 19 :41:23 desktop systemd [ 1 ] : Starting A high performance web server and a reverse proxy server... Jan 27 19 :41:23 desktop systemd [ 1 ] : Started A high performance web server and a reverse proxy server. Esto le proporciona una buena visi\u00f3n general del estado actual de la aplicaci\u00f3n, y le notifica de cualquier problema y cualquier acci\u00f3n que pueda ser necesaria. Tambi\u00e9n hay m\u00e9todos para comprobar los estados espec\u00edficos. Por ejemplo, para comprobar si una unidad est\u00e1 activa actualmente (ejecut\u00e1ndose) puede usar el comando is-active : systemctl is-active application.service Esto devolver\u00e1 el estado actual de la unidad, que es normalmente activo o inactivo . El c\u00f3digo de salida ser\u00e1 \"0\" si est\u00e1 activo, lo que hace que el resultado sea m\u00e1s sencillo de analizar en las secuencias de comando shell. Para ver si la unidad est\u00e1 habilitada, puede usar el comando is-enabled : systemctl is-enabled application.service Esto indicar\u00e1 si el servicio est\u00e1 habilitado o deshabilitado y establecer\u00e1 el c\u00f3digo de salida a \"0\" o \"1\", dependiendo de la respuesta a la pregunta del comando. Una tercera comprobaci\u00f3n es si la unidad est\u00e1 en estado fallido. Esto indica que hubo un problema al iniciar la unidad en cuesti\u00f3n: systemctl is-failed application.service Esto devolver\u00e1 active si se est\u00e1 ejecutando adecuadamente o failed si se ha producido un error. Si la unidad se detuvo intencionadamente, puede devolver unknown o inactive . Un estado de salida de \"0\" indica que se produjo un error y un estado de salida de \"1\" indica cualquier otro estado.","title":"C\u00f3mo comprobar el estado de los servicios"},{"location":"03_Procesos/036_AdministracionServicios.html#descripcion-general-del-estado-del-sistema","text":"Los comandos hasta ahora han sido \u00fatiles para administrar servicios individuales, pero no son muy \u00fatiles para explorar el estado actual del sistema. Hay varios comandos systemctl que proporcionan esta informaci\u00f3n.","title":"Descripci\u00f3n general del estado del sistema"},{"location":"03_Procesos/036_AdministracionServicios.html#como-enumerar-las-unidades-actuales","text":"Para ver una lista de todas las unidades activas que systemd conoce, podemos usar el comando list-units : systemctl list-units Esto le mostrar\u00e1 una lista de todas las unidades que systemd tiene activas actualmente en el sistema. El resultado tendr\u00e1 un aspecto similar a este: OutputUNIT LOAD ACTIVE SUB DESCRIPTION atd.service loaded active running ATD daemon avahi-daemon.service loaded active running Avahi mDNS/DNS-SD Stack dbus.service loaded active running D-Bus System Message Bus dcron.service loaded active running Periodic Command Scheduler dkms.service loaded active exited Dynamic Kernel Modules System getty@tty1.service loaded active running Getty on tty1 . . . El resultado tiene las siguientes columnas: UNIT: El nombre de la unidad de systemd LOAD: Si la configuraci\u00f3n de la unidad ha sido analizada por systemd . La configuraci\u00f3n de las unidades cargadas se mantiene en la memoria. ACTIVE: Un estado resumido que indica si la unidad est\u00e1 activa. Esta es normalmente una forma bastante b\u00e1sica de saber si la unidad se ha iniciado correctamente o no. SUB: Este es un estado de nivel inferior que indica informaci\u00f3n m\u00e1s detallada sobre la unidad. Esto a menudo var\u00eda por tipo de unidad, estado y el m\u00e9todo real en el que se ejecuta la unidad. DESCRIPTION: Una descripci\u00f3n textual breve de qu\u00e9 es y hace la unidad. Ya que el comando list-units muestra solo las unidades activas por defecto, todas las entradas por encima se mostrar\u00e1n loaded en la columna LOAD y active en la columna ACTIVE. Esta pantalla es, en realidad, el comportamiento predeterminado de systemctl cuando se invoca sin comandos adicionales, de modo que ver\u00e1 lo mismo si invoca systemctl sin argumentos: systemctl Podemos indicar a systemctl que produzca informaci\u00f3n diferente a\u00f1adiendo marcadores adicionales. Por ejemplo, para ver todas las unidades que systemd ha cargado (o intentado cargar), independientemente de si est\u00e1n activas actualmente, puede usar el marcador --all , de esta forma: systemctl list-units --all Esto mostrar\u00e1 cualquier unidad que systemd haya cargado o intentado cargar, independientemente de su estado actual en el sistema. Ciertas unidades se vuelven inactivas tras ejecutarse, y algunas de las unidades que systemd intent\u00f3 cargar pueden no haberse encontrado en el disco. Puede usar otros marcadores para filtrar estos resultados. Por ejemplo, puede usar el indicador --state= para indicar los estados LOAD, ACTIVE o SUB que deseamos ver. Tendremos que mantener el marcador --all para que systemctl permita que se muestren las unidades no activas: systemctl list-units --all --state = inactive Otro filtro com\u00fan es el filtro --type= . Podemos indicar a systemctl que solo muestre unidades del tipo en el que estemos interesados. Por ejemplo, para ver \u00fanicamente las unidades de servicio activas, podemos usar: systemctl list-units --type = service","title":"C\u00f3mo enumerar las unidades actuales"},{"location":"03_Procesos/036_AdministracionServicios.html#listar-todos-los-archivos-de-la-unidad","text":"El comando list-units solo muestra las unidades que systemd ha intentado analizar y cargar en la memoria. Ya que systemd solo leer\u00e1 unidades que cree que necesita, esto no incluir\u00e1 necesariamente todas las unidades disponibles en el sistema. Para ver todos los archivos de unidad disponibles en las rutas systemd , incluidos aquellos que systemd no haya intentado cargar, puede usar el comando list-unit-files : systemctl list-unit-files Las unidades son representaciones de los recursos que systemd conoce. Ya que systemd no ha le\u00eddo necesariamente todas las definiciones de la unidades en esta vista, solo presente informaci\u00f3n sobre los propios archivos. El resultado tiene dos columnas, el archivo de la unidad y el estado. OutputUNIT FILE STATE proc-sys-fs-binfmt_misc.automount static dev-hugepages.mount static dev-mqueue.mount static proc-fs-nfsd.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount static var-lib-nfs-rpc_pipefs.mount static org.cups.cupsd.path enabled . . . El estado normalmente estar\u00e1 habilitado , deshabilitado , est\u00e1tico o enmascarado . En este contexto, \"est\u00e1tico\" significa que el archivo de unidad no contiene una secci\u00f3n install , que se utiliza para habilitar una unidad. Como tal, estas unidades no pueden habilitarse. Normalmente, esto significa que la unidad realiza una \u00fanica acci\u00f3n o se utiliza solo como dependencia de otra unidad y no deber\u00eda ejecutarse por s\u00ed misma. En breve explicaremos lo que significa enmascarado .","title":"Listar todos los archivos de la unidad"},{"location":"03_Procesos/036_AdministracionServicios.html#gestion-de-la-unidad","text":"Hasta ahora, hemos estado trabajando con servicios y mostrando informaci\u00f3n sobre la unidad y los archivos de la unidad que systemd conoce. Sin embargo, encontraremos m\u00e1s informaci\u00f3n espec\u00edfica sobre las unidades usando algunos comandos adicionales.","title":"Gesti\u00f3n de la unidad"},{"location":"03_Procesos/036_AdministracionServicios.html#mostrar-un-archivo-de-unidad","text":"Para mostrar el archivo de unidad que systemd ha cargado en su sistema, puede usar el comando cat (esto se a\u00f1adi\u00f3 en la versi\u00f3n 209 de systemd ). Por ejemplo, para ver el archivo de unidad del daemon de programaci\u00f3n atd , podr\u00edamos escribir: systemctl cat atd.service Output[Unit] Description=ATD daemon [Service] Type=forking ExecStart=/usr/bin/atd [Install] WantedBy=multi-user.target El resultado es el archivo de unidad tal como lo conoce el proceso systemd que se est\u00e1 ejecutando actualmente. Esto puede ser importante si ha modificado archivos de unidad recientemente o si est\u00e1 omitiendo ciertas opciones en un fragmento del archivo de unidad (hablaremos de esto m\u00e1s tarde).","title":"Mostrar un archivo de unidad"},{"location":"03_Procesos/036_AdministracionServicios.html#mostrar-dependencias","text":"Para ver el \u00e1rbol de dependencias de una unidad, puede usar el comando list-dependencies : systemctl list-dependencies sshd.service Esto mostrar\u00e1 una jerarqu\u00eda asignando las dependencias que deben tratarse para iniciar la unidad en cuesti\u00f3n. Las dependencias, en este contexto, incluyen las unidades que son necesarias o deseadas por unidades de nivel superior. Outputsshd.service \u251c\u2500system.slice \u2514\u2500basic.target \u251c\u2500microcode.service \u251c\u2500rhel-autorelabel-mark.service \u251c\u2500rhel-autorelabel.service \u251c\u2500rhel-configure.service \u251c\u2500rhel-dmesg.service \u251c\u2500rhel-loadmodules.service \u251c\u2500paths.target \u251c\u2500slices.target . . . Las dependencias recursivas solo se muestran para las unidades .target , que indican los estados del sistema. Para listar de forma recursiva todas las dependencias, incluya el indicador --all . Para mostrar las dependencias inversas (unidades que dependen de la unidad especificada) puede a\u00f1adir el indicador --reverse al comando. Otros indicadores que son \u00fatiles son los indicadores --before y --after , que pueden usarse para mostrar las unidades que dependen de la unidad especificada que comienza antes y despu\u00e9s de ellas mismas respectivamente.","title":"Mostrar dependencias"},{"location":"03_Procesos/036_AdministracionServicios.html#comprobar-las-propiedades-de-la-unidad","text":"Para ver las propiedades de nivel bajo de una unidad, puede usar el comando show . Esto mostrar\u00e1 una lista de propiedades que se establecen para la unidad especificada usando un formato key=value : systemctl show sshd.service OutputId=sshd.service Names=sshd.service Requires=basic.target Wants=system.slice WantedBy=multi-user.target Conflicts=shutdown.target Before=shutdown.target multi-user.target After=syslog.target network.target auditd.service systemd-journald.socket basic.target system.slice Description=OpenSSH server daemon . . . Si desea mostrar una \u00fanica propiedad, pude pasar el indicador -p con el nombre de la propiedad. Por ejemplo, para ver los conflictos que la unidad sshd.service tiene, puede escribir: systemctl show sshd.service -p Conflicts OutputConflicts = shutdown.target","title":"Comprobar las propiedades de la unidad"},{"location":"03_Procesos/036_AdministracionServicios.html#enmascarar-y-desenmascarar-unidades","text":"Vimos en la secci\u00f3n de administraci\u00f3n del servicio c\u00f3mo detener o deshabilitar un servicio, pero systemd tambi\u00e9n tiene la capacidad de marcar una unidad como completamente no iniciable, autom\u00e1tica o manualmente, vincul\u00e1ndola a /dev/null . Esto se denomina enmascarar la unidad, y es posible con el comando mask : sudo systemctl mask nginx.service Esto impedir\u00e1 que el servicio Nginx se inicie, autom\u00e1tica o manualmente, siempre que est\u00e9 enmascarado. Si comprueba los list-unit-files , ver\u00e1 que el servicio ahora se lista como enmascarado: systemctl list-unit-files Output. . . kmod-static-nodes.service static ldconfig.service static mandb.service static messagebus.service static nginx.service masked quotaon.service static rc-local.service static rdisc.service disabled rescue.service static . . . Si intenta iniciar el servicio, ver\u00e1 un mensaje como este: sudo systemctl start nginx.service OutputFailed to start nginx.service: Unit nginx.service is masked. Para desenmascarar una unidad, y hacer que est\u00e9 disponible de nuevo para su uso, utilice el comando unmask : sudo systemctl unmask nginx.service Esto devolver\u00e1 la unidad a su estado anterior, permitiendo que se inicie o habilite.","title":"Enmascarar y desenmascarar unidades"},{"location":"03_Procesos/036_AdministracionServicios.html#editar-archivos-de-la-unidad","text":"Aunque el formato espec\u00edfico de los archivos de unidad est\u00e1 fuera del alcance de este tutorial, si necesita realizar ajustes, systemctl proporciona mecanismos integrados para editar y modificar archivos de unidad. Esta funcionalidad fue a\u00f1adida en la versi\u00f3n 218 de systemd . El comando edit , por defecto, abrir\u00e1 un fragmento de c\u00f3digo del archivo de la unidad para la unidad en cuesti\u00f3n: sudo systemctl edit nginx.service Este ser\u00e1 un archivo en blanco que puede usarse para omitir o a\u00f1adir directivas a la definici\u00f3n de la unidad. Se crear\u00e1 un directorio en el directorio /etc/systemd/system que contiene el nombre de la unidad con .d anexada. Por ejemplo, para el nginx.service , se crear\u00e1 un directorio llamado nginx.service.d . En este directorio, se crear\u00e1 un fragmento de c\u00f3d igo llamado o verride.conf. Cuando se carga la unidad, systemd , en la memoria, fusionar\u00e1 el fragmento de c\u00f3digo de anulaci\u00f3n con el archivo de unidad completo. Las directivas del snippet prevalecer\u00e1n sobre las encontradas en el archivo original de la unidad. Si desea editar el archivo completo de la unidad en vez de crear un fragmento de c\u00f3digo, puede pasar el indicador --full : sudo systemctl edit --full nginx.service Esto cargar\u00e1 el archivo de unidad actual en el editor, donde se podr\u00e1 modificar. Cuando sale el editor, el archivo cambiado se escribir\u00e1 a /etc/systemd/system , que tendr\u00e1 prioridad sobre la definici\u00f3n de la unidad del sistema (normalmente se encuentra en alg\u00fan lugar de /lib/systemd/system ). Para eliminar cualquier adici\u00f3n que haya realizado, elimine el directorio de configuraci\u00f3n .d de la unidad o el archivo de servicio modificado de /etc/systemd/system . Por ejemplo, para eliminar un fragmento de c\u00f3digo, podr\u00edamos escribir lo siguiente: sudo rm -r /etc/systemd/system/nginx.service.d Para eliminar un archivo de unidad completo modificado, escribir\u00edamos: sudo rm /etc/systemd/system/nginx.service Tras eliminar el archivo o directorio, deber\u00eda volver a cargar el proceso systemd de forma que deje de intentar hacer referencia a estos archivos y vuelve a usar las copias del sistema. Puede hacerlo escribiendo lo siguiente: sudo systemctl daemon-reload","title":"Editar archivos de la unidad"},{"location":"03_Procesos/036_AdministracionServicios.html#ajustar-el-estado-del-sistema-runlevel-con-los-destinos","text":"Los destinos son archivos de unidad especiales que describen el estado de un sistema o un punto de sincronizaci\u00f3n. Igual que otras unidades, los archivos que definen los destinos pueden identificarse por su sufijo, que en este caso es .target . Los destinos no hacen mucho por s\u00ed mismos, pero se utilizan para agrupar otras unidades. Esto puede usarse para llevar al sistema a ciertos estados, de forma muy similar que otros sistemas init utilizan runlevels. Se utilizan como referencia para cuando ciertas funciones est\u00e9n disponibles, lo que le permite especificar el estado deseado en vez de las unidades individuales necesarias para producir ese estado. Por ejemplo, hay un swap.target que se usa para indicar que swap est\u00e1 listo para usarse. Las unidades que son parte de este proceso pueden sincronizarse con este destino indicando en su configuraci\u00f3n que son WantedBy= o RequiredBy= el swap.target . Las unidades que requieren que swap est\u00e9 disponible pueden especificar esta condici\u00f3n usando las especificaciones Wants= , Requires= y After= para indicar la naturaleza de su relaci\u00f3n.","title":"Ajustar el estado del sistema (Runlevel) con los destinos"},{"location":"03_Procesos/036_AdministracionServicios.html#obtener-y-establecer-el-destino-predeterminado","text":"El proceso systemd tiene un destino predeterminado que utiliza cuando se inicia el sistema. Satisfacer la cascada de dependencias de ese destino individual llevar\u00e1 al sistema al estado deseado. Para encontrar el destino predeterminado de su sistema, escriba: systemctl get-default Outputmulti-user.target Si desea establecer un destino predeterminado diferente, puede usar set-default . Por ejemplo, si tiene un escritorio gr\u00e1fico instalado y desea que el sistema se inicie a esto por defecto, puede cambiar el destino predeterminado: sudo systemctl set-default graphical.target","title":"Obtener y establecer el destino predeterminado"},{"location":"03_Procesos/036_AdministracionServicios.html#como-enumerar-los-destinos-disponibles","text":"Puede obtener una lista de los destinos disponibles en su sistema escribiendo: systemctl list-unit-files --type = target A diferencia de runlevels, puede haber m\u00faltiples destinos activos a la vez. Un destino activo indica que systemd ha intentado iniciar todas las unidades relacionadas con el destino y no ha intentado desglosarlas de nuevo. Para ver todos los destinos activos, escriba: systemctl list-units --type = target","title":"C\u00f3mo enumerar los destinos disponibles"},{"location":"03_Procesos/036_AdministracionServicios.html#aislar-destinos","text":"Es posible iniciar todas las unidades asociadas con un destino y detener todas las que no son parte del \u00e1rbol de dependencias. El comando que necesitamos para hacer esto se denomina, apropiadamente, isolate . Esto es similar a cambiar el runlevel en otros sistemas init. Por ejemplo, si est\u00e1 operando en un entorno gr\u00e1fico con graphical.target activo, puede apagar el sistema gr\u00e1fico y poner el sistema en un estado de l\u00ednea de comando multi usuario asilando el multi-user.target . Ya que graphical.target depende de multi-user.target pero no al rev\u00e9s, todas las unidades gr\u00e1ficas se detendr\u00e1n. Quiz\u00e1 desee echar un vistazo a las dependencias del destino que est\u00e1 aislando antes de realizar este procedimiento para asegurarse de que no est\u00e1 deteniendo servicios cruciales: systemctl list-dependencies multi-user.target Cuando est\u00e9 satisfecho con las unidades que se mantendr\u00e1n activas, puede aislar el destino escribiendo lo siguiente: sudo systemctl isolate multi-user.target","title":"Aislar destinos"},{"location":"03_Procesos/036_AdministracionServicios.html#como-usar-atajos-para-eventos-importantes","text":"Existen destinos definidos para eventos importantes como apagar o reiniciar. Sin embargo, systemctl tambi\u00e9n tiene algunos atajos que a\u00f1aden ciertas funciones adicionales. Por ejemplo, para poner el sistema en el modo rescate (usuario \u00fanico), puede usar simplemente el comando rescue en vez de isolate rescue.target , sudo systemctl rescue Esto proporcionar\u00e1 la funcionalidad adicional de alertar a todos los usuarios con sesi\u00f3n iniciada sobre el evento. Para detener el sistema, puede usar el comando halt : sudo systemctl halt Para iniciar un apagado completo, puede usar el comando poweroff : sudo systemctl poweroff Puede iniciar un reinicio con el comando reboot : sudo systemctl reboot Nota Todos estos comandos alertan a los usuarios con sesi\u00f3n iniciada de que se va a producir el evento, algo que ejecutar o aislar el destino \u00fanicamente no har\u00e1. Observe que la mayor\u00eda de los equipos vincular\u00e1n los comandos m\u00e1s cortos y convencionales para estas operaciones de forma que funcionen adecuadamente con systemd .","title":"C\u00f3mo usar atajos para eventos importantes"},{"location":"03_Procesos/ProgramacionAula.html","text":"Programaci\u00f3n de Aula \u00b6 Resultados de Aprendizaje \u00b6 Esta unidad cubre el Resultado de aprendizaje 2 (RA2) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se ha diferenciado entre proceso, hilo y trabajo. b. Se han planificado la ejecuci\u00f3n de procesos mediante los algoritmos m\u00e1s importantes. c. Se han utilizado interrupciones y excepciones para describir los eventos internos del procesador. d. Se han realizado tareas de creaci\u00f3n, manipulaci\u00f3n y terminaci\u00f3n de procesos. e. Se ha utilizado el sistema de archivos como medio l\u00f3gico para el registro e identificaci\u00f3n de los procesos del sistema. f. Se han utilizado herramientas gr\u00e1ficas y comandos para el control y seguimiento de los procesos del sistema. g. Se ha comprobado la secuencia de arranque del sistema, los procesos implicados y la relaci\u00f3n entre ellos. h. Se han tomado medidas de seguridad ante la aparici\u00f3n de procesos no identificados. i. Se han documentado los procesos habituales del sistema, su funci\u00f3n y relaci\u00f3n entre ellos. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Planificaci\u00f3n Temporal \u00b6 Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 06/10/22 Introducci\u00f3n Procesos, Planificador. Introducci\u00f3n Procesos y planificador. 2 11/10/22 Hilos, Sincronizaci\u00f3n e interrupciones entre procesos. Hilos, Sincronizaci\u00f3n e interrupciones entre procesos. 3 13/10/22 Gesti\u00f3n de procesos con Shell. Gesti\u00f3n de procesos en Shell. 4 18/10/22 Gesti\u00f3n de procesos PowerShell. Gesti\u00f3n de procesos en PowerShell. 5 20/10/22 Arranque del sistema. Servicios. Systemd Arranque del sistema. Servicios. Systemd.","title":"Programaci\u00f3n de Aula"},{"location":"03_Procesos/ProgramacionAula.html#programacion-de-aula","text":"","title":"Programaci\u00f3n de Aula"},{"location":"03_Procesos/ProgramacionAula.html#resultados-de-aprendizaje","text":"Esta unidad cubre el Resultado de aprendizaje 2 (RA2) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Administra procesos del sistema describi\u00e9ndolos y aplicando criterios de seguridad y eficiencia. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se ha diferenciado entre proceso, hilo y trabajo. b. Se han planificado la ejecuci\u00f3n de procesos mediante los algoritmos m\u00e1s importantes. c. Se han utilizado interrupciones y excepciones para describir los eventos internos del procesador. d. Se han realizado tareas de creaci\u00f3n, manipulaci\u00f3n y terminaci\u00f3n de procesos. e. Se ha utilizado el sistema de archivos como medio l\u00f3gico para el registro e identificaci\u00f3n de los procesos del sistema. f. Se han utilizado herramientas gr\u00e1ficas y comandos para el control y seguimiento de los procesos del sistema. g. Se ha comprobado la secuencia de arranque del sistema, los procesos implicados y la relaci\u00f3n entre ellos. h. Se han tomado medidas de seguridad ante la aparici\u00f3n de procesos no identificados. i. Se han documentado los procesos habituales del sistema, su funci\u00f3n y relaci\u00f3n entre ellos. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; }","title":"Resultados de Aprendizaje"},{"location":"03_Procesos/ProgramacionAula.html#planificacion-temporal","text":"Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 06/10/22 Introducci\u00f3n Procesos, Planificador. Introducci\u00f3n Procesos y planificador. 2 11/10/22 Hilos, Sincronizaci\u00f3n e interrupciones entre procesos. Hilos, Sincronizaci\u00f3n e interrupciones entre procesos. 3 13/10/22 Gesti\u00f3n de procesos con Shell. Gesti\u00f3n de procesos en Shell. 4 18/10/22 Gesti\u00f3n de procesos PowerShell. Gesti\u00f3n de procesos en PowerShell. 5 20/10/22 Arranque del sistema. Servicios. Systemd Arranque del sistema. Servicios. Systemd.","title":"Planificaci\u00f3n Temporal"},{"location":"03_Procesos/ResumenUD.html","text":"Resumen UD \u00b6 A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"03_Procesos/ResumenUD.html#resumen-ud","text":"A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades DESARROLLO (Ense\u00f1anza/Aprendizaje). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 107 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 108 a la 110 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 111 a la 114 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 115 a la 118 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. R\u00fabrica. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 119 a la 121 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. R\u00fabrica. Prueba espec\u00edfica de evaluaci\u00f3n.","title":"Resumen UD"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html","text":"Introducci\u00f3n de Servicios de directorio y LDAP \u00b6 La organizaci\u00f3n de una red de trabajo empresarial supone un reto organizativo que el administrador del sistema debe afrontar con garant\u00edas de \u00e9xito. Para ello dispone de herramientas organizativas como los servicios de directorio, tanto SAMBA como Active Directory , ambas basadas en el protocolo LDAP , las cuales ofrecen una amplia gama de herramientas que facilitan la organizaci\u00f3n de recursos de una red. Note Si no se concibe un ordenador sin sistema operativo que lo administre, tampoco debe existir una red de cierta entidad sin sistema operativo de red que la gestione. En definitiva, un sistema operativo de red (SOR en lo sucesivo) , est\u00e1 dise\u00f1ado para administrar redes y todos los elementos que la componen. Sus tareas m\u00e1s importantes son: La gesti\u00f3n centralizada de los recursos. Ofrecer servicios a los clientes. Proporcionar acceso seguro a esos recursos y monitorizar todo lo que pasa en la red. Arquitectura de Redes \u00b6 Los sistemas operativos en red pueden catalogarse en distribuidos y centralizados. Los primeros se componen de un software que controla todos los equipos inform\u00e1ticos de forma distribuido en modo \"cluster\" . Un ejemplo es el SO llamado Amoeba de A.S.Tanenbaum . Se utilizan en despliegues espec\u00edficos que no competen en este m\u00f3dulo. por lo tanto a continuaci\u00f3n se desarrollaran los centralizados. Estructura Red plana \u00b6 Antes del desarrollo de las herramientas de los servicios de red, se comenz\u00f3 a desarrollar la Estructura trabajo en grupo , la cual trataba la red en modo plano. Una red plana, entre iguales o punto a punto , es aquella en la ninguno de los equipos realiza tareas de administraci\u00f3n de la red, sino tan s\u00f3lo de s\u00ed mismo. No existe un equipo que haga las veces de administrador, por lo que en realidad, todos los clientes se convierten en administradores de los recursos que ofrecen a la red. Example Si un cliente decide compartir un recuso, \u00e9ste estar\u00e1 disponible para todos los miembros de la red sin distinci\u00f3n. Si es necesario limitar el acceso a un subconjunto de usuarios, habr\u00e1 que establecer una contrase\u00f1a y hac\u00e9rsela llegar a trav\u00e9s de un medio seguro. Advertencia Si cada uno de los usuarios empieza a compartir recursos sin control, su localizaci\u00f3n puede ser una tarea complicada, ya que los usuarios de la red deben conocer en todo momento su distribuci\u00f3n y configuraci\u00f3n. La localizaci\u00f3n puede suponer un grave problema. Microsoft introdujo en sus sistemas operativos la posibilidad de crear grupos de trabajo que divid\u00edan la red en subconjuntos. De este modo, si se sabe a qu\u00e9 grupo pertenece el equipo que comparte un recurso ser\u00e1 m\u00e1s sencillo su localizaci\u00f3n. Estas divisiones se realizaban por funciones, por ubicaci\u00f3n f\u00edsica o por cualquier otro criterio de la empresa. Introducci\u00f3n de un equipo a un grupo de trabajo Advertencia Resultaba m\u00e1s sencillo localizar recursos, pero no solucionaban el problema de acceso . Este sistema de organizaci\u00f3n de red presenta numerosos problemas de seguridad. Estructura cliente-servidor \u00b6 Se trata de un modelo de aplicaci\u00f3n centralizada en el que las tareas se dividen entre los proveedores de recursos o servicios. A estas m\u00e1quinas se las conoce como servidores y a los equipos que demandan estos servicios se les conoce como clientes . Esquema de red cliente servidor En este tipo de redes: Los clientes est\u00e1n conectados a un servidor en el que se centralizan los recursos y servicios con que se cuenta la red. El servidor es el encargado de ponerlos a disposici\u00f3n de los clientes cada vez que estos son solicitados. Por lo tanto, todas las gestiones que se realizan se concentran en el servidor, lo que facilita la localizaci\u00f3n de los recurso de una forma sencilla. Warning Sin embargo, agregar un segundo servidor puede complicar las cosas de manera significativa. El problema surge porque cada servidor individual mantiene su propia lista de usuarios y recursos. El servidor A ofrece alojamiento a aplicaciones, el servidor B al correo electr\u00f3nico y las aplicaciones de contabilidad y la base de datos se encuentran en el servidor C . Red cliente-servidor con varios servidores. Los usuarios que requieren acceso a la base de datos y utilizar las aplicaciones, necesitan una cuenta en dos de los tres servidores. Cada una de esas cuentas de usuarios debe ser creada y mantenida de manera separada. Es f\u00e1cil para los servidores perder sincron\u00eda cuando deben ser actualizados manualmente. Note Estas y otras cuestiones ser\u00e1n resueltas con el siguiente modo de organizaci\u00f3n de red. Servicios de directorio \u00b6 los servicios de directorios , son un conjunto de aplicaciones que guardan y administran toda la informaci\u00f3n sobre los elementos de una red. Cada recurso de la red se considera como un objeto , donde su informaci\u00f3n se almacena como atributos . Para la gesti\u00f3n de esta informaci\u00f3n, el servicio de directorio establece una serie de permisos de acceso y condiciones de seguridad que la salvaguardan esta informaci\u00f3n. Ofrecen una infraestructura para localizar, manejar, administrar, y organizar los componentes y recursos comunes de una red. Note Los recursos pueden ser: vol\u00famenes, carpetas, archivos, impresoras, usuarios, grupos, dispositivos, n\u00fameros de tel\u00e9fono y un largo etc\u00e9tera. Los servicios de directorios contienen diferentes objetos relacionados entre s\u00ed, y que ser\u00e1 conveniente familiarizarse con ellos: Directorio , es un repositorio \u00fanico para la informaci\u00f3n relativa a los objetos de una organizaci\u00f3n. Dominio , es una colecci\u00f3n de objetos dentro de un directorio. Objeto , cualquiera de los elementos que forman parte del directorio. Pueden ser recursos, usuarios, equipos, relaciones de confianza, servidores, unidades organizativas entre otros. En general todos estos objetos se clasifican en tres categor\u00edas: usuarios , identificados a trav\u00e9s del binomio nombre/contrase\u00f1a y que pueden organizarse en grupos. recursos , elementos que los usuarios pueden usar para el correcto desarrollo de su actividad. servicios , que son funciones a los que el usuario tienen acceso como el correo electr\u00f3nico , copias de seguridad en la nube , conexi\u00f3n Internet entre otros . Unidad organizativa , es un contendedor de objetos que permite organizarlos en subconjuntos de forma jer\u00e1rquica. Facilita la organizaci\u00f3n de los dominios. Unidades Organizativas en Active Directory Grupo , conjunto de objetos usuario. Al igual que las unidades organizativas, facilitan la organizaci\u00f3n y administraci\u00f3n de los objetos, los grupos lo hacen con objetos tipo usuario. Controlador de dominio , equipo que contiene la base de datos de objetos para un determinado dominio, incluida la informaci\u00f3n de seguridad y la responsabilidad de la autenticaci\u00f3n de objetos de su \u00e1mbito de gobierno. Cat\u00e1logo global , base de datos con la informaci\u00f3n de todos los objetos que contiene el directorio. Esta informaci\u00f3n habitualmente se divide entre los controladores de dominio siendo \u00e9stos responsables del mantenimiento de su parte de esta informaci\u00f3n. Maestro de operaciones , existen un conjunto de operaciones que deben estar centralizadas para mantener la consistencia del sistema. El equipo encargado de esas operaciones obtiene este rol espec\u00edfico. Seg\u00fan el caso puede ser un equipo independiente que controle estas operaciones o asignar estas tareas a un equipo existente. \u00c1rbol , un conjunto de dominios dependientes de una ra\u00edz com\u00fan y que tienen una estructura jer\u00e1rquica. Se caracterizan por tener un espacio de nombres com\u00fan (un servidor DNS propio). El objetivo de esta fragmentaci\u00f3n de la estructura es replicar s\u00f3lo la informaci\u00f3n necesaria y disminuir el tr\u00e1fico de red. Objetos en Active Directory. Bosque , se trata del mayor contenedor l\u00f3gico dentro del directorio, conteniendo a todos los \u00e1rboles dentro de su \u00e1mbito. Cada uno de estos contenedores posee su propio espacio de nombres y una forma de relacionarse con el resto de bosques. Ejemplo de Objetos en Active Directory. Esquema , se refiere a la estructura de los objetos que forman la base de datos. Usa la t\u00e9cnica clase/objeto para definir la estructura de un objeto. Si se crean dos objetos usuarios, ambos tendr\u00e1n los mismos atributos (estructura), pero diferentes valores de atributos. Sitio , conjunto de objetos equipo que se encuentran relacionados de una forma l\u00f3gica, geogr\u00e1fica o t\u00e9cnica particular y que necesitan un subconjunto de normas diferentes al resto. Relaciones de confianza , son un m\u00e9todo de comunicaci\u00f3n segura entre dominios, \u00e1rboles y bosques, que permiten a los usuarios autentificarse en otra parte del directorio a la que no pertenece. Note Para nombrar a todos estos objetos que componen la red, los servicios de directorio definen un espacio de nombres un\u00edvoco, e identifican a cada uno de estos objetos con un nombre \u00fanico en todo el directorio. La tecnolog\u00eda utilizada para crear este espacio de nombres es la DNS (Domain Name Server) , y su funcionamiento es similar al de Internet. Cada uno de los objetos del directorio posee un DN (Distinguished Name) que lo identifica de forma un\u00edvoca del resto de elementos del directorio. Ventajas \u00b6 los servicios de directorio, ofrecen una capa de abstracci\u00f3n para facilitar el acceso a los objetos. Se debe indicar una \u00fanica ubicaci\u00f3n en donde se dirigir\u00e1n las peticiones de informaci\u00f3n. No importa si la informaci\u00f3n solicitada se encuentra o no en ese emplazamiento. Autonom\u00eda , Es posible que toda la informaci\u00f3n no est\u00e9 contenida en un \u00fanico equipo por cuestiones de rendimiento, escalabilidad o idiosincrasia del sistemas inform\u00e1tico. En estos casos crear un subconjunto de la informaci\u00f3n contenida en los servicios de directorio parece una buena opci\u00f3n y dotarlos de las herramientas necesarias para su gesti\u00f3n aut\u00f3noma. Si se permite el s\u00edmil, es el Google del sistema inform\u00e1tico que se gestiona. Servicios de directorio destacables \u00b6 Active Directory , ideado por Microsoft e implementado desde su versi\u00f3n Microsoft Windows 2000 que usaba tecnolog\u00eda propietaria, para m\u00e1s tarde adaptar el protocolo LDAP a su servicio. OpenLDAP , recibe el nombre del protocolo hom\u00f3nimo que gestiona el intercambio de informaci\u00f3n. Es uno de los m\u00e1s usados en sistemas basados en GNU/Linux . SambaLDAP , un servicio compuesto por un conjunto de protocolos ( OpenLDAP , Kerberos y Samba ) que permite la f\u00e1cil coexistencia de entre sistemas operativos diferentes. Otros: Novell Directory Services , Red Hat Directory Server o Apache Directory Server . Note En resumen , un servicio de directorio ofrece toda la informaci\u00f3n de los recursos de la red a trav\u00e9s de una \u00fanica ubicaci\u00f3n. Para ello convierte cada recurso en un objeto y almacena su informaci\u00f3n en una base de datos jer\u00e1rquica y, opcionalmente, distribuida. La gesti\u00f3n de estos datos se realiza a trav\u00e9s de un protocolo determinado por la versi\u00f3n del servicio de directorio escogido. LDAP \u00b6 El LDAP (Lightweight Directory Access Protocol) es un protocolo a nivel de aplicaci\u00f3n que da acceso a un servicio de directorio ordenado y distribuido para la b\u00fasqueda de la informaci\u00f3n de un entrono de red. En la d\u00e9cada de los 80, la especificaci\u00f3n de directorio X.500 vi\u00f3 la luz. El protocolo que daba acceso a la informaci\u00f3n contenida en \u00e9l, fue DAP (Directory Access Protocol) y estaba basado en la pila de protocolos OSI (Open Systems Interconexion) . Gracias al auge de Internet, la pila de protocolos TCP/IP cobraron especial protagonismo y su uso fue generalizado en cualquier infraestructura de red, incluidas las LAN. Ante esta situaci\u00f3n, en 1993 se implement\u00f3 el protocolo LDAP que utilizaba la pila de protocolos TCP/IP para el acceso a la informaci\u00f3n contenido en un servicio de directorio. El funcionamiento de LDAP es relativamente simple : un cliente se inicia una sesi\u00f3n en un servidor LDAP solicitando alguna informaci\u00f3n. Esquema de funcionamiento del protocolo LDAP Conclusi\u00f3n LDAP, es un protocolo que ofrece el acceso a un servicio de directorio implementado sobre un entorno de red, con el objeto de acceder a una determinada informaci\u00f3n. Puede ejecutarse sobre TCP/IP o sobre cualquier otro servicio de transferencia orientado a la conexi\u00f3n. Podemos considerarlo como un sistema de almacenamiento de red al que se pueden realizar consultas. Antes de trabajar con LDAP, hay varios conceptos importantes que deben entenderse. El primer paso importante para dar el acceso comentado se basa en la autentificaci\u00f3n de usuarios . AUTENTICAR USUARIOS \u00b6 Existen diferentes formas de autenticar usuarios en una red linux, pero una de las m\u00e1s usadas es la combinaci\u00f3n de tres herramientas diferentes: NSS , PAM y LDAP . La idea consiste en disponer de un servidor que facilite la acci\u00f3n de autenticar usuarios , de modo, que \u00e9stos recurran al servidor cada vez que un cliente necesite identificarse. De esta forma, la cuenta de usuario no es espec\u00edfica de un equipo cliente , si no que ser\u00e1 v\u00e1lida en cualquier equipo de la red que haya sido debidamente configurado. Herramientas autenticaci\u00f3n usuarios en Unix PAM \u00b6 Pluggable Authentication Module (PAM) : o m\u00f3dulo de autenticaci\u00f3n conectable en espa\u00f1ol, es un mecanismo para integrar m\u00faltiples esquemas de autenticaci\u00f3n de bajo nivel en una interfaz de programaci\u00f3n de aplicaciones (API) de alto nivel. Es decir, Establece una interfaz entre los programas de usuario y distintos m\u00e9todos de autenticaci\u00f3n . De esta forma, el m\u00e9todo de autenticaci\u00f3n, se hace transparente para los programas . La idea se basa en la creaci\u00f3n de m\u00f3dulos de autenticaci\u00f3n . Esto hace que, sin realizar modificaciones en el sistema , podamos utilizar m\u00e9todos que vayan desde el uso t\u00edpico de un nombre de usuario y una contrase\u00f1a, hasta aceptar contrase\u00f1as de un solo uso , restringir el acceso a determinados horarios o establecer pol\u00edticas de autenticaci\u00f3n espec\u00edficas para cada usuario o grupos de usuarios. Esquema de la estructura PAM Note En la actualidad, PAM es el m\u00e9todo que utilizan la mayor\u00eda de las aplicaciones y herramientas de UNIX para autenticar usuarios. NSS \u00b6 Name Service Switch es un servicio que permite la resoluci\u00f3n de nombres de usuario y contrase\u00f1as (o grupos) mediante el acceso a diferentes or\u00edgenes de informaci\u00f3n. En condiciones normales, esta informaci\u00f3n se encuentra en los archivos locales del sistema operativo, en concreto en /etc/passwd , /etc/shadow y /etc/group pero puede proceder de otras fuentes, como DNS (Domain Name System) , NIS (Network Information Service) , LDAP (Lightweight Directory Access Protocol) o WINS (Windows Internet Name Service) . Note Este servicio esta gestionado desde el fichero: /etc/nsswitch.conf Cheat Sheet LDAP \u00b6 En el siguiente sub-apartado se realizar\u00e1 la instalaci\u00f3n y configuraci\u00f3n del servicio OpenLDAP. En primer lugar se muestran unas tablas resumen de definiciones de elementos y siglas que pueden ser \u00fatiles para dicha instalaci\u00f3n. De todas formas en el punto 4.3. Modelo de Informaci\u00f3n de LDAP se estudiar\u00e1n m\u00e1s en detalle. Elemento LDAP Definici\u00f3n entry una colecci\u00f3n de informaci\u00f3n sobre una entidad attribute conserva los datos para una entrada object\u00adClass elementos de esquema que especifican colecciones de tipos de atributos que pueden estar relacionados con un tipo particular de objeto, proceso u otra entidad dn identifica de forma \u00fanica esa entrada y su posici\u00f3n en la jerarqu\u00eda del \u00e1rbol de informaci\u00f3n del directorio (DIT) rdn la parte relativa de un nombre distintivo (DN) oid una cadena que se utiliza para identificar de forma \u00fanica varios elementos en el protocolo LDAP Atributos Definici\u00f3n cn common name name name, same as cn dn distin\u00adguished name dc domain component manager manager company company department department o organi\u00adzation ou organi\u00adzat\u00adional unit uid user id descri\u00adption descri\u00adption displa\u00adyName display name givenName first name sn surname title job title location location l location street\u00adAddress first line of address postalCode zip code c country st state homephone home phone number mobile mobile phone number teleph\u00adone\u00adNumber office phone number Actividades \u00b6 --> Realizar un informe breve en pdf con la captura del slapcat que confirme que se ha instalado y configurado el OpenLDAP. Debe aparecer el dominio: nombre.apellidos.ldap","title":"4.1- Introducci\u00f3n Servicios de directorio y LDAP"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#introduccion-de-servicios-de-directorio-y-ldap","text":"La organizaci\u00f3n de una red de trabajo empresarial supone un reto organizativo que el administrador del sistema debe afrontar con garant\u00edas de \u00e9xito. Para ello dispone de herramientas organizativas como los servicios de directorio, tanto SAMBA como Active Directory , ambas basadas en el protocolo LDAP , las cuales ofrecen una amplia gama de herramientas que facilitan la organizaci\u00f3n de recursos de una red. Note Si no se concibe un ordenador sin sistema operativo que lo administre, tampoco debe existir una red de cierta entidad sin sistema operativo de red que la gestione. En definitiva, un sistema operativo de red (SOR en lo sucesivo) , est\u00e1 dise\u00f1ado para administrar redes y todos los elementos que la componen. Sus tareas m\u00e1s importantes son: La gesti\u00f3n centralizada de los recursos. Ofrecer servicios a los clientes. Proporcionar acceso seguro a esos recursos y monitorizar todo lo que pasa en la red.","title":"Introducci\u00f3n de Servicios de directorio y LDAP"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#arquitectura-de-redes","text":"Los sistemas operativos en red pueden catalogarse en distribuidos y centralizados. Los primeros se componen de un software que controla todos los equipos inform\u00e1ticos de forma distribuido en modo \"cluster\" . Un ejemplo es el SO llamado Amoeba de A.S.Tanenbaum . Se utilizan en despliegues espec\u00edficos que no competen en este m\u00f3dulo. por lo tanto a continuaci\u00f3n se desarrollaran los centralizados.","title":"Arquitectura de Redes"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#estructura-red-plana","text":"Antes del desarrollo de las herramientas de los servicios de red, se comenz\u00f3 a desarrollar la Estructura trabajo en grupo , la cual trataba la red en modo plano. Una red plana, entre iguales o punto a punto , es aquella en la ninguno de los equipos realiza tareas de administraci\u00f3n de la red, sino tan s\u00f3lo de s\u00ed mismo. No existe un equipo que haga las veces de administrador, por lo que en realidad, todos los clientes se convierten en administradores de los recursos que ofrecen a la red. Example Si un cliente decide compartir un recuso, \u00e9ste estar\u00e1 disponible para todos los miembros de la red sin distinci\u00f3n. Si es necesario limitar el acceso a un subconjunto de usuarios, habr\u00e1 que establecer una contrase\u00f1a y hac\u00e9rsela llegar a trav\u00e9s de un medio seguro. Advertencia Si cada uno de los usuarios empieza a compartir recursos sin control, su localizaci\u00f3n puede ser una tarea complicada, ya que los usuarios de la red deben conocer en todo momento su distribuci\u00f3n y configuraci\u00f3n. La localizaci\u00f3n puede suponer un grave problema. Microsoft introdujo en sus sistemas operativos la posibilidad de crear grupos de trabajo que divid\u00edan la red en subconjuntos. De este modo, si se sabe a qu\u00e9 grupo pertenece el equipo que comparte un recurso ser\u00e1 m\u00e1s sencillo su localizaci\u00f3n. Estas divisiones se realizaban por funciones, por ubicaci\u00f3n f\u00edsica o por cualquier otro criterio de la empresa. Introducci\u00f3n de un equipo a un grupo de trabajo Advertencia Resultaba m\u00e1s sencillo localizar recursos, pero no solucionaban el problema de acceso . Este sistema de organizaci\u00f3n de red presenta numerosos problemas de seguridad.","title":"Estructura Red plana"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#estructura-cliente-servidor","text":"Se trata de un modelo de aplicaci\u00f3n centralizada en el que las tareas se dividen entre los proveedores de recursos o servicios. A estas m\u00e1quinas se las conoce como servidores y a los equipos que demandan estos servicios se les conoce como clientes . Esquema de red cliente servidor En este tipo de redes: Los clientes est\u00e1n conectados a un servidor en el que se centralizan los recursos y servicios con que se cuenta la red. El servidor es el encargado de ponerlos a disposici\u00f3n de los clientes cada vez que estos son solicitados. Por lo tanto, todas las gestiones que se realizan se concentran en el servidor, lo que facilita la localizaci\u00f3n de los recurso de una forma sencilla. Warning Sin embargo, agregar un segundo servidor puede complicar las cosas de manera significativa. El problema surge porque cada servidor individual mantiene su propia lista de usuarios y recursos. El servidor A ofrece alojamiento a aplicaciones, el servidor B al correo electr\u00f3nico y las aplicaciones de contabilidad y la base de datos se encuentran en el servidor C . Red cliente-servidor con varios servidores. Los usuarios que requieren acceso a la base de datos y utilizar las aplicaciones, necesitan una cuenta en dos de los tres servidores. Cada una de esas cuentas de usuarios debe ser creada y mantenida de manera separada. Es f\u00e1cil para los servidores perder sincron\u00eda cuando deben ser actualizados manualmente. Note Estas y otras cuestiones ser\u00e1n resueltas con el siguiente modo de organizaci\u00f3n de red.","title":"Estructura cliente-servidor"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#servicios-de-directorio","text":"los servicios de directorios , son un conjunto de aplicaciones que guardan y administran toda la informaci\u00f3n sobre los elementos de una red. Cada recurso de la red se considera como un objeto , donde su informaci\u00f3n se almacena como atributos . Para la gesti\u00f3n de esta informaci\u00f3n, el servicio de directorio establece una serie de permisos de acceso y condiciones de seguridad que la salvaguardan esta informaci\u00f3n. Ofrecen una infraestructura para localizar, manejar, administrar, y organizar los componentes y recursos comunes de una red. Note Los recursos pueden ser: vol\u00famenes, carpetas, archivos, impresoras, usuarios, grupos, dispositivos, n\u00fameros de tel\u00e9fono y un largo etc\u00e9tera. Los servicios de directorios contienen diferentes objetos relacionados entre s\u00ed, y que ser\u00e1 conveniente familiarizarse con ellos: Directorio , es un repositorio \u00fanico para la informaci\u00f3n relativa a los objetos de una organizaci\u00f3n. Dominio , es una colecci\u00f3n de objetos dentro de un directorio. Objeto , cualquiera de los elementos que forman parte del directorio. Pueden ser recursos, usuarios, equipos, relaciones de confianza, servidores, unidades organizativas entre otros. En general todos estos objetos se clasifican en tres categor\u00edas: usuarios , identificados a trav\u00e9s del binomio nombre/contrase\u00f1a y que pueden organizarse en grupos. recursos , elementos que los usuarios pueden usar para el correcto desarrollo de su actividad. servicios , que son funciones a los que el usuario tienen acceso como el correo electr\u00f3nico , copias de seguridad en la nube , conexi\u00f3n Internet entre otros . Unidad organizativa , es un contendedor de objetos que permite organizarlos en subconjuntos de forma jer\u00e1rquica. Facilita la organizaci\u00f3n de los dominios. Unidades Organizativas en Active Directory Grupo , conjunto de objetos usuario. Al igual que las unidades organizativas, facilitan la organizaci\u00f3n y administraci\u00f3n de los objetos, los grupos lo hacen con objetos tipo usuario. Controlador de dominio , equipo que contiene la base de datos de objetos para un determinado dominio, incluida la informaci\u00f3n de seguridad y la responsabilidad de la autenticaci\u00f3n de objetos de su \u00e1mbito de gobierno. Cat\u00e1logo global , base de datos con la informaci\u00f3n de todos los objetos que contiene el directorio. Esta informaci\u00f3n habitualmente se divide entre los controladores de dominio siendo \u00e9stos responsables del mantenimiento de su parte de esta informaci\u00f3n. Maestro de operaciones , existen un conjunto de operaciones que deben estar centralizadas para mantener la consistencia del sistema. El equipo encargado de esas operaciones obtiene este rol espec\u00edfico. Seg\u00fan el caso puede ser un equipo independiente que controle estas operaciones o asignar estas tareas a un equipo existente. \u00c1rbol , un conjunto de dominios dependientes de una ra\u00edz com\u00fan y que tienen una estructura jer\u00e1rquica. Se caracterizan por tener un espacio de nombres com\u00fan (un servidor DNS propio). El objetivo de esta fragmentaci\u00f3n de la estructura es replicar s\u00f3lo la informaci\u00f3n necesaria y disminuir el tr\u00e1fico de red. Objetos en Active Directory. Bosque , se trata del mayor contenedor l\u00f3gico dentro del directorio, conteniendo a todos los \u00e1rboles dentro de su \u00e1mbito. Cada uno de estos contenedores posee su propio espacio de nombres y una forma de relacionarse con el resto de bosques. Ejemplo de Objetos en Active Directory. Esquema , se refiere a la estructura de los objetos que forman la base de datos. Usa la t\u00e9cnica clase/objeto para definir la estructura de un objeto. Si se crean dos objetos usuarios, ambos tendr\u00e1n los mismos atributos (estructura), pero diferentes valores de atributos. Sitio , conjunto de objetos equipo que se encuentran relacionados de una forma l\u00f3gica, geogr\u00e1fica o t\u00e9cnica particular y que necesitan un subconjunto de normas diferentes al resto. Relaciones de confianza , son un m\u00e9todo de comunicaci\u00f3n segura entre dominios, \u00e1rboles y bosques, que permiten a los usuarios autentificarse en otra parte del directorio a la que no pertenece. Note Para nombrar a todos estos objetos que componen la red, los servicios de directorio definen un espacio de nombres un\u00edvoco, e identifican a cada uno de estos objetos con un nombre \u00fanico en todo el directorio. La tecnolog\u00eda utilizada para crear este espacio de nombres es la DNS (Domain Name Server) , y su funcionamiento es similar al de Internet. Cada uno de los objetos del directorio posee un DN (Distinguished Name) que lo identifica de forma un\u00edvoca del resto de elementos del directorio.","title":"Servicios de directorio"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#ventajas","text":"los servicios de directorio, ofrecen una capa de abstracci\u00f3n para facilitar el acceso a los objetos. Se debe indicar una \u00fanica ubicaci\u00f3n en donde se dirigir\u00e1n las peticiones de informaci\u00f3n. No importa si la informaci\u00f3n solicitada se encuentra o no en ese emplazamiento. Autonom\u00eda , Es posible que toda la informaci\u00f3n no est\u00e9 contenida en un \u00fanico equipo por cuestiones de rendimiento, escalabilidad o idiosincrasia del sistemas inform\u00e1tico. En estos casos crear un subconjunto de la informaci\u00f3n contenida en los servicios de directorio parece una buena opci\u00f3n y dotarlos de las herramientas necesarias para su gesti\u00f3n aut\u00f3noma. Si se permite el s\u00edmil, es el Google del sistema inform\u00e1tico que se gestiona.","title":"Ventajas"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#servicios-de-directorio-destacables","text":"Active Directory , ideado por Microsoft e implementado desde su versi\u00f3n Microsoft Windows 2000 que usaba tecnolog\u00eda propietaria, para m\u00e1s tarde adaptar el protocolo LDAP a su servicio. OpenLDAP , recibe el nombre del protocolo hom\u00f3nimo que gestiona el intercambio de informaci\u00f3n. Es uno de los m\u00e1s usados en sistemas basados en GNU/Linux . SambaLDAP , un servicio compuesto por un conjunto de protocolos ( OpenLDAP , Kerberos y Samba ) que permite la f\u00e1cil coexistencia de entre sistemas operativos diferentes. Otros: Novell Directory Services , Red Hat Directory Server o Apache Directory Server . Note En resumen , un servicio de directorio ofrece toda la informaci\u00f3n de los recursos de la red a trav\u00e9s de una \u00fanica ubicaci\u00f3n. Para ello convierte cada recurso en un objeto y almacena su informaci\u00f3n en una base de datos jer\u00e1rquica y, opcionalmente, distribuida. La gesti\u00f3n de estos datos se realiza a trav\u00e9s de un protocolo determinado por la versi\u00f3n del servicio de directorio escogido.","title":"Servicios de directorio destacables"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#ldap","text":"El LDAP (Lightweight Directory Access Protocol) es un protocolo a nivel de aplicaci\u00f3n que da acceso a un servicio de directorio ordenado y distribuido para la b\u00fasqueda de la informaci\u00f3n de un entrono de red. En la d\u00e9cada de los 80, la especificaci\u00f3n de directorio X.500 vi\u00f3 la luz. El protocolo que daba acceso a la informaci\u00f3n contenida en \u00e9l, fue DAP (Directory Access Protocol) y estaba basado en la pila de protocolos OSI (Open Systems Interconexion) . Gracias al auge de Internet, la pila de protocolos TCP/IP cobraron especial protagonismo y su uso fue generalizado en cualquier infraestructura de red, incluidas las LAN. Ante esta situaci\u00f3n, en 1993 se implement\u00f3 el protocolo LDAP que utilizaba la pila de protocolos TCP/IP para el acceso a la informaci\u00f3n contenido en un servicio de directorio. El funcionamiento de LDAP es relativamente simple : un cliente se inicia una sesi\u00f3n en un servidor LDAP solicitando alguna informaci\u00f3n. Esquema de funcionamiento del protocolo LDAP Conclusi\u00f3n LDAP, es un protocolo que ofrece el acceso a un servicio de directorio implementado sobre un entorno de red, con el objeto de acceder a una determinada informaci\u00f3n. Puede ejecutarse sobre TCP/IP o sobre cualquier otro servicio de transferencia orientado a la conexi\u00f3n. Podemos considerarlo como un sistema de almacenamiento de red al que se pueden realizar consultas. Antes de trabajar con LDAP, hay varios conceptos importantes que deben entenderse. El primer paso importante para dar el acceso comentado se basa en la autentificaci\u00f3n de usuarios .","title":"LDAP"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#autenticar-usuarios","text":"Existen diferentes formas de autenticar usuarios en una red linux, pero una de las m\u00e1s usadas es la combinaci\u00f3n de tres herramientas diferentes: NSS , PAM y LDAP . La idea consiste en disponer de un servidor que facilite la acci\u00f3n de autenticar usuarios , de modo, que \u00e9stos recurran al servidor cada vez que un cliente necesite identificarse. De esta forma, la cuenta de usuario no es espec\u00edfica de un equipo cliente , si no que ser\u00e1 v\u00e1lida en cualquier equipo de la red que haya sido debidamente configurado. Herramientas autenticaci\u00f3n usuarios en Unix","title":"AUTENTICAR USUARIOS"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#cheat-sheet-ldap","text":"En el siguiente sub-apartado se realizar\u00e1 la instalaci\u00f3n y configuraci\u00f3n del servicio OpenLDAP. En primer lugar se muestran unas tablas resumen de definiciones de elementos y siglas que pueden ser \u00fatiles para dicha instalaci\u00f3n. De todas formas en el punto 4.3. Modelo de Informaci\u00f3n de LDAP se estudiar\u00e1n m\u00e1s en detalle. Elemento LDAP Definici\u00f3n entry una colecci\u00f3n de informaci\u00f3n sobre una entidad attribute conserva los datos para una entrada object\u00adClass elementos de esquema que especifican colecciones de tipos de atributos que pueden estar relacionados con un tipo particular de objeto, proceso u otra entidad dn identifica de forma \u00fanica esa entrada y su posici\u00f3n en la jerarqu\u00eda del \u00e1rbol de informaci\u00f3n del directorio (DIT) rdn la parte relativa de un nombre distintivo (DN) oid una cadena que se utiliza para identificar de forma \u00fanica varios elementos en el protocolo LDAP Atributos Definici\u00f3n cn common name name name, same as cn dn distin\u00adguished name dc domain component manager manager company company department department o organi\u00adzation ou organi\u00adzat\u00adional unit uid user id descri\u00adption descri\u00adption displa\u00adyName display name givenName first name sn surname title job title location location l location street\u00adAddress first line of address postalCode zip code c country st state homephone home phone number mobile mobile phone number teleph\u00adone\u00adNumber office phone number","title":"Cheat Sheet LDAP"},{"location":"04_LDAP/041_Introduccion_SDyLDAP.html#actividades","text":"--> Realizar un informe breve en pdf con la captura del slapcat que confirme que se ha instalado y configurado el OpenLDAP. Debe aparecer el dominio: nombre.apellidos.ldap","title":"Actividades"},{"location":"04_LDAP/042_LDAP_DIT.html","text":"Modelo de Informaci\u00f3n de LDAP \u00b6 La estructura b\u00e1sica de LDAP es un \u00e1rbol de nodos llamado Directory Information Tree (DIT) donde cada objeto o nodo es una entrada. La parte superior del \u00e1rbol se llama com\u00fanmente ra\u00edz (tambi\u00e9n conocida como base o sufijo ). Cada entrada se define por un DN (Distinguished Name) y contiene un conjunto de atributos. Este DN es una cadena que indica la ruta en el \u00e1rbol de dicha entrada y ser\u00e1 \u00fanico en todo el \u00e1rbol. Un ejemplo del aspecto que ofrece un DN ser\u00eda el siguiente: Example cn=usuario1,ou=usuarios,dc=midominio,dc=es Puede verse que cada componente (la coma es el car\u00e1cter separador) se muestra como un par \u00abatributo=valor\u00bb donde el atributo es una abreviatura usada por LDAP. Cada entrada en el \u00e1rbol tiene una entrada principal (objeto) y cero o m\u00e1s entradas secundarias (objetos). Cada entrada secundaria (objeto) es un hermano de las otras entradas secundarias de su padre. Cada entrada se compone de (es una instancia de) una o m\u00e1s clases de objeto ( objectClasses ). Las objectClasses contienen cero o m\u00e1s atributos. Los atributos tienen nombres (y a veces abreviaturas o alias ) y normalmente contienen datos. A continuaci\u00f3n se muestra un diagrama para entender mejor estos conceptos: Modelo de informaci\u00f3n (datos) LDAP DIT Resumen: Cada entrada (1) se compone de una o m\u00e1s clases de objetos (2) Cada objectClass (2) tiene un nombre y es un contenedor de atributos (su definici\u00f3n identifica los atributos que puede o debe contener) Cada atributo (3) tiene un nombre, contiene datos y es miembro de una o m\u00e1s clases de objetos (2) Cuando se completa el DIT, cada entrada se identificar\u00e1 de forma \u00fanica (en relaci\u00f3n con su entrada principal) en la jerarqu\u00eda por los datos que contiene (en sus atributos que est\u00e1n contenidos en su (s) objectClasses (s)). Entrada \u00b6 Una entrada LDAP es una recopilaci\u00f3n de informaci\u00f3n sobre una entidad. Cada entrada consta de tres componentes principales: Nombre distinguido DN y RDN (Relative Distinguished Name) Colecci\u00f3n de clases de objetos (objectClasses) Atributos Cada uno de estos se describe con m\u00e1s detalle a continuaci\u00f3n. DN y RDN \u00b6 El nombre distinguido de una entrada, a menudo denominado DN , identifica de forma \u00fanica esa entrada y su posici\u00f3n en la jerarqu\u00eda del \u00e1rbol de informaci\u00f3n de directorio (DIT). El DN de una entrada LDAP es muy parecido a la ruta a un archivo en un sistema de archivos . Un DN LDAP se compone de cero o m\u00e1s elementos denominados nombres distinguidos relativos o RDN . Cada RDN se compone de uno o m\u00e1s (generalmente solo uno) pares de atributo-valor. Example \"uid = john.doe\" representa un RDN compuesto por un atributo llamado \"uid\" con un valor de \"john.doe\". Si un RDN tiene varios pares de atributo-valor, est\u00e1n separados por signos m\u00e1s, como \"givenName = John + sn = Doe\" . DSE \u00b6 El nombre distinguido especial compuesto por cero RDN (y por lo tanto tiene una representaci\u00f3n de cadena que es solo una cadena vac\u00eda ) a veces se denomina \"DN nulo\" y hace referencia a un tipo especial de entrada llamado DSE ra\u00edz que proporciona informaci\u00f3n sobre el contenido y las capacidades de el servidor de directorio. M\u00faltiples RDN \u00b6 Para DN con m\u00faltiples RDN , el orden de los RDN especifica la posici\u00f3n de la entrada asociada en el DIT. Los RDN est\u00e1n separados por comas, y cada RDN en un DN representa un nivel en la jerarqu\u00eda en orden descendente (es decir, acerc\u00e1ndose a la ra\u00edz del \u00e1rbol, que se denomina contexto de nomenclatura). Example el DN \"uid = john.doe, ou = People, dc = example, dc = com\" tiene cuatro RDN. Clases de objetos (objectClasses) \u00b6 Las clases de objeto son elementos de esquema que especifican colecciones de tipos de atributos que pueden estar relacionados con un tipo particular de objeto, proceso u otra entidad. Las clases de objetos son, esencialmente, contenedores de atributos y se describen utilizando definiciones ASN.1 . Cada objectClass tiene un nombre \u00fanico . Existe un n\u00famero confuso de clases de objetos PREDEFINIDAS , cada una de las cuales contiene un mont\u00f3n de atributos adecuados para casi todas las implementaciones LDAP comunes. Las clases de objetos tienen tres caracter\u00edsticas principales: La clase de objeto define si un miembro de atributo MUST ( obligatorio ) estar presente o MAY ( opcional ) estar presente. Cada clase de objeto tiene un tipo que pueden ser estructurales , auxiliar o RESUMEN . En esta etapa es suficiente saber que debe haber una, y solo una, clase de objeto ESTRUCTURAL en una entrada y que puede haber cero o m\u00e1s clases de objeto AUXILIAR . Una clase de objeto puede ser parte de una jerarqu\u00eda, en cuyo caso hereda todas las caracter\u00edsticas de su (s) clase (s) de objeto principal (incluidos todos los atributos que contiene). Note objectClasses son contenedores y controlan qu\u00e9 atributos se pueden agregar a cada entrada, pero por lo dem\u00e1s tienden a permanecer en segundo plano en lo que respecta al acceso e interrogaci\u00f3n (b\u00fasqueda) del DIT. Los atributos y las entradas son los elementos realmente visibles . Atributos \u00b6 Cada atributo de una entrada tendr\u00e1 un tipo y un valor con el formato atributo/valor que permite caracterizar un aspecto del objeto que define la entrada. Estos atributos tienen nombres que hacen referencia a su contenido y pueden ser de dos tipos: Atributos normales : Son los atributos que identifican al objeto Atributos operativos : Son los atributos que utiliza el servidor para administrar el directorio Entre los atributos que suelen utilizarse habitualmente, encontramos los siguientes, aunque puede haber muchos mas: dn (distinguished name): nombre distintivo de una entrada, contiene un conjunto de atributos y es de car\u00e1cter \u00fanico. dc (domain component): se refiere al componente del dominio, ya sea un componente, una etiqueta o un nombre de dominio DNS. ou (organizational unit): unidad organizativa. cn (common name): nombre com\u00fan. sn (surname): apellido. uid (userid): nombre de usuario. mail: direcci\u00f3n de e-mail. telephoneNumber: n\u00famero de tel\u00e9fono. Example DN cn=John Smith, o=airius.com, c=DE RDN cn=John Smith + DN of ancestor o=airius.com, c=DE Modelo de nomenclatura LDAP Caracter\u00edsticas de Atributos \u00b6 Cada atributo tiene un nombre \u00fanico ( y una forma abreviada o alias ) y normalmente contiene datos. Los atributos siempre est\u00e1n asociados con (son miembros de) una o m\u00e1s ObjectClasses . Los atributos tienen una serie de caracter\u00edsticas interesantes: Todos los atributos son miembros de una o m\u00e1s clases de objeto . Cada atributo define el tipo de datos (la palabra clave es SINTAXIS) que puede contener. Los tipos de datos pueden ser: Strings , Numbers (Integer) , Time , Telephone Numbers , Boolean , Binary , Distinguished Name , Bit Strings , LDAP Supported Syntaxes . Los atributos pueden formar parte de una jerarqu\u00eda , en cuyo caso el atributo hijo hereda todas las caracter\u00edsticas del atributo padre . En el caso de los atributos, se usa una jerarqu\u00eda para simplificar y acortar las definiciones de atributos (en ASN.1) donde muchos atributos comparten propiedades comunes como la longitud m\u00e1xima o si son o no sensibles a may\u00fasculas y min\u00fasculas, etc. ning\u00fan otro significado. Los atributos pueden ser opcionales (la palabra clave es MAY ) u obligatorios (la palabra clave es MUST ) como se describe en las definiciones ASN.1 para la clase de objeto de la que son miembros. Un atributo puede ser opcional en una clase de objeto y obligatorio en otra. Es la clase de objeto la que determina esta propiedad. Los atributos aparentemente son aleatorios que se recogen de todas partes de la documentaci\u00f3n; es confuso al principio, pero proviene de la caracter\u00edstica opcional de la mayor\u00eda de los atributos. Permite un enfoque de ' pick-n-mix ' para poblar una entrada. Se puede buscar el atributo que se desee, y buscar la clase de objeto de la que es miembro (puede haber m\u00e1s de uno) y confirmar que todos los dem\u00e1s atributos que no se desean utilizar en la clase de objeto sean opcionales. Se puede revisar en Atributos comunmente utilizados . Los atributos pueden tener un valor \u00daNICO o M\u00daLTIPLE (como se describe en sus definiciones ASN.1 ). VALOR \u00daNICO significa que solo un valor de datos puede estar presente para el atributo . MULTIVALOR significa que el atributo puede aparecer varias veces en una clase de entrada / objeto con diferentes valores de datos. Si el atributo describe, por ejemplo, una direcci\u00f3n de correo electr\u00f3nico, puede haber una, dos o 500 definiciones del atributo, cada una con una direcci\u00f3n de correo diferente (es m\u00faltipl ); este es uno de los varios m\u00e9todos para tratar los alias de correo electr\u00f3nico en los dise\u00f1os de directorios. En este caso el valor predeterminado de un atributo es MULTIVALOR (permitir m\u00faltiples valores). Los atributos tienen nombres y, a veces, un alias (como se describe en sus definiciones ASN.1), por ejemplo, el atributo con un nombre de cn es un miembro del objectClass llamado person (y muchos otros) y tiene un alias de commonName . Se puede utilizar commonName o cn para hacer referencia a este atributo . En cada nivel de la jerarqu\u00eda, los datos contenidos en un atributo se pueden utilizar para identificar de forma \u00fanica la entrada . Puede ser cualquier atributo de la entrada. Incluso puede ser una combinaci\u00f3n de dos o m\u00e1s atributos. Los valores de atributo seleccionados para contener los datos \u00fanicos a veces se denominan atributos de nomenclatura o el nombre distinguido relativo (RDN), ya comentados. LDIF \u00b6 La adici\u00f3n de entradas se puede realizar de diversas formas, una de las cuales es mediante el uso de archivos de intercambio de datos LDAP (LDIF) . Los LDIF son archivos de texto que describen la jerarqu\u00eda del \u00e1rbol, el \u00e1rbol de informaci\u00f3n del directorio (DIT) , y los datos que se agregar\u00e1n a cada atributo. El siguiente es un ejemplo simple de un archivo LDIF que configura un DN ra\u00edz (dc = ejemplo, dc = com) y agrega tres entradas secundarias debajo de una entrada de personas . version : 1 ## version not strictly necessary (and some implementations reject it) but generally good practice ## DEFINE DIT ROOT/BASE/SUFFIX #### ## uses RFC 2377 (domain name) format ## dcObject is an AUXILIARY objectclass and MUST ## have a STRUCTURAL objectclass (organization in this case) # this is an ENTRY sequence and is preceded by a BLANK line dn : dc=example,dc=com dc : example description : The best company in the whole world objectClass : dcObject objectClass : organization o : Example, Inc. ## FIRST Level hierarchy - people # this is an ENTRY sequence and is preceded by a BLANK line dn : ou=people, dc=example,dc=com ou : people description : All people in organisation objectClass : organizationalUnit ## SECOND Level hierarchy - people entries # this is an ENTRY sequence and is preceded by a BLANK line dn : cn=Robert Smith,ou=people,dc=example,dc=com objectclass : inetOrgPerson cn : Robert Smith cn : Robert sn : Smith uid : rsmith mail : robert@example.com mail : r.smith@example.com ou : sales ## SECOND Level hierarchy - people entries # this is an ENTRY sequence and is preceded by a BLANK line dn : cn=Bill Smith,ou=people,dc=example,dc=com objectclass : inetOrgPerson cn : Bill Smith cn : William sn : Smith uid : bsmith mail : bill@example.com mail : b.smith@example.com ou : support ## SECOND Level hierarchy - people entries # this is an ENTRY sequence and is preceded by a BLANK line dn : cn=John Smith,ou=people,dc=example,dc=com objectclass : inetOrgPerson cn : John Smith sn : smith uid : jsmith mail : jim@example.com mail : j.smith@example.com ou : accounting base.ldif dn : ou=usuarios,dc=pandora,dc=ldap objectClass : organizationalUnit objectClass : top ou : usuarios dn : ou=grupos,dc=pandora,dc=ldap objectClass : organizationalUnit objectClass : top ou : grupos content.ldif dn : cn=devops,ou=grupos,dc=pandora,dc=ldap objectClass : posixGroup cn : devops gidNumber : 10000 memberUid : devops dn : uid=mordecai,ou=usuarios,dc=pandora,dc=ldap objectClass : inetOrgPerson objectClass : posixAccount objectClass : shadowAccount cn : Mordecai sn : Geek userPassword : { SSHA } latDDmodpsLUWDqwd/adk/j2tTDgz3NX loginshell : /bin/bash uidNumber : 10000 gidNumber : 10000 homeDirectory : /home/mordecai Actividades Desarrollo UD2_01 \u00b6 Creaci\u00f3n de usuarios y grupos OpenLDAP Actividades Desarrollo UD2_02 \u00b6 Configuraci\u00f3n de equipo cliente Actividades Desarrollo UD2_03 \u00b6 En este ejercicio se deben utilizar los comandos de OpenLdap instalados en el paquete LDAPutils . A\u00f1ade un nuevo grupo y dentro de el un nuevo usuario a la estructura de directorio creada en la pr\u00e1ctica superior. Crea una contrase\u00f1a para el usuario. Modifica el uid creado de inicio. Crea un segundo usuario, dentro de usuarios Elimina el segundo usuario creado. En cada subapartado comprueba que se han introducido correctamente las modificaciones en el DIT . Actividades Desarrollo UD2_04 \u00b6 Instalaci\u00f3n y configuraci\u00f3n phpLDAPadmin","title":"Modelo de Informaci\u00f3n de LDAP"},{"location":"04_LDAP/042_LDAP_DIT.html#modelo-de-informacion-de-ldap","text":"La estructura b\u00e1sica de LDAP es un \u00e1rbol de nodos llamado Directory Information Tree (DIT) donde cada objeto o nodo es una entrada. La parte superior del \u00e1rbol se llama com\u00fanmente ra\u00edz (tambi\u00e9n conocida como base o sufijo ). Cada entrada se define por un DN (Distinguished Name) y contiene un conjunto de atributos. Este DN es una cadena que indica la ruta en el \u00e1rbol de dicha entrada y ser\u00e1 \u00fanico en todo el \u00e1rbol. Un ejemplo del aspecto que ofrece un DN ser\u00eda el siguiente: Example cn=usuario1,ou=usuarios,dc=midominio,dc=es Puede verse que cada componente (la coma es el car\u00e1cter separador) se muestra como un par \u00abatributo=valor\u00bb donde el atributo es una abreviatura usada por LDAP. Cada entrada en el \u00e1rbol tiene una entrada principal (objeto) y cero o m\u00e1s entradas secundarias (objetos). Cada entrada secundaria (objeto) es un hermano de las otras entradas secundarias de su padre. Cada entrada se compone de (es una instancia de) una o m\u00e1s clases de objeto ( objectClasses ). Las objectClasses contienen cero o m\u00e1s atributos. Los atributos tienen nombres (y a veces abreviaturas o alias ) y normalmente contienen datos. A continuaci\u00f3n se muestra un diagrama para entender mejor estos conceptos: Modelo de informaci\u00f3n (datos) LDAP DIT Resumen: Cada entrada (1) se compone de una o m\u00e1s clases de objetos (2) Cada objectClass (2) tiene un nombre y es un contenedor de atributos (su definici\u00f3n identifica los atributos que puede o debe contener) Cada atributo (3) tiene un nombre, contiene datos y es miembro de una o m\u00e1s clases de objetos (2) Cuando se completa el DIT, cada entrada se identificar\u00e1 de forma \u00fanica (en relaci\u00f3n con su entrada principal) en la jerarqu\u00eda por los datos que contiene (en sus atributos que est\u00e1n contenidos en su (s) objectClasses (s)).","title":"Modelo de Informaci\u00f3n de LDAP"},{"location":"04_LDAP/042_LDAP_DIT.html#entrada","text":"Una entrada LDAP es una recopilaci\u00f3n de informaci\u00f3n sobre una entidad. Cada entrada consta de tres componentes principales: Nombre distinguido DN y RDN (Relative Distinguished Name) Colecci\u00f3n de clases de objetos (objectClasses) Atributos Cada uno de estos se describe con m\u00e1s detalle a continuaci\u00f3n.","title":"Entrada"},{"location":"04_LDAP/042_LDAP_DIT.html#clases-de-objetos-objectclasses","text":"Las clases de objeto son elementos de esquema que especifican colecciones de tipos de atributos que pueden estar relacionados con un tipo particular de objeto, proceso u otra entidad. Las clases de objetos son, esencialmente, contenedores de atributos y se describen utilizando definiciones ASN.1 . Cada objectClass tiene un nombre \u00fanico . Existe un n\u00famero confuso de clases de objetos PREDEFINIDAS , cada una de las cuales contiene un mont\u00f3n de atributos adecuados para casi todas las implementaciones LDAP comunes. Las clases de objetos tienen tres caracter\u00edsticas principales: La clase de objeto define si un miembro de atributo MUST ( obligatorio ) estar presente o MAY ( opcional ) estar presente. Cada clase de objeto tiene un tipo que pueden ser estructurales , auxiliar o RESUMEN . En esta etapa es suficiente saber que debe haber una, y solo una, clase de objeto ESTRUCTURAL en una entrada y que puede haber cero o m\u00e1s clases de objeto AUXILIAR . Una clase de objeto puede ser parte de una jerarqu\u00eda, en cuyo caso hereda todas las caracter\u00edsticas de su (s) clase (s) de objeto principal (incluidos todos los atributos que contiene). Note objectClasses son contenedores y controlan qu\u00e9 atributos se pueden agregar a cada entrada, pero por lo dem\u00e1s tienden a permanecer en segundo plano en lo que respecta al acceso e interrogaci\u00f3n (b\u00fasqueda) del DIT. Los atributos y las entradas son los elementos realmente visibles .","title":"Clases de objetos (objectClasses)"},{"location":"04_LDAP/042_LDAP_DIT.html#atributos","text":"Cada atributo de una entrada tendr\u00e1 un tipo y un valor con el formato atributo/valor que permite caracterizar un aspecto del objeto que define la entrada. Estos atributos tienen nombres que hacen referencia a su contenido y pueden ser de dos tipos: Atributos normales : Son los atributos que identifican al objeto Atributos operativos : Son los atributos que utiliza el servidor para administrar el directorio Entre los atributos que suelen utilizarse habitualmente, encontramos los siguientes, aunque puede haber muchos mas: dn (distinguished name): nombre distintivo de una entrada, contiene un conjunto de atributos y es de car\u00e1cter \u00fanico. dc (domain component): se refiere al componente del dominio, ya sea un componente, una etiqueta o un nombre de dominio DNS. ou (organizational unit): unidad organizativa. cn (common name): nombre com\u00fan. sn (surname): apellido. uid (userid): nombre de usuario. mail: direcci\u00f3n de e-mail. telephoneNumber: n\u00famero de tel\u00e9fono. Example DN cn=John Smith, o=airius.com, c=DE RDN cn=John Smith + DN of ancestor o=airius.com, c=DE Modelo de nomenclatura LDAP","title":"Atributos"},{"location":"04_LDAP/042_LDAP_DIT.html#ldif","text":"La adici\u00f3n de entradas se puede realizar de diversas formas, una de las cuales es mediante el uso de archivos de intercambio de datos LDAP (LDIF) . Los LDIF son archivos de texto que describen la jerarqu\u00eda del \u00e1rbol, el \u00e1rbol de informaci\u00f3n del directorio (DIT) , y los datos que se agregar\u00e1n a cada atributo. El siguiente es un ejemplo simple de un archivo LDIF que configura un DN ra\u00edz (dc = ejemplo, dc = com) y agrega tres entradas secundarias debajo de una entrada de personas . version : 1 ## version not strictly necessary (and some implementations reject it) but generally good practice ## DEFINE DIT ROOT/BASE/SUFFIX #### ## uses RFC 2377 (domain name) format ## dcObject is an AUXILIARY objectclass and MUST ## have a STRUCTURAL objectclass (organization in this case) # this is an ENTRY sequence and is preceded by a BLANK line dn : dc=example,dc=com dc : example description : The best company in the whole world objectClass : dcObject objectClass : organization o : Example, Inc. ## FIRST Level hierarchy - people # this is an ENTRY sequence and is preceded by a BLANK line dn : ou=people, dc=example,dc=com ou : people description : All people in organisation objectClass : organizationalUnit ## SECOND Level hierarchy - people entries # this is an ENTRY sequence and is preceded by a BLANK line dn : cn=Robert Smith,ou=people,dc=example,dc=com objectclass : inetOrgPerson cn : Robert Smith cn : Robert sn : Smith uid : rsmith mail : robert@example.com mail : r.smith@example.com ou : sales ## SECOND Level hierarchy - people entries # this is an ENTRY sequence and is preceded by a BLANK line dn : cn=Bill Smith,ou=people,dc=example,dc=com objectclass : inetOrgPerson cn : Bill Smith cn : William sn : Smith uid : bsmith mail : bill@example.com mail : b.smith@example.com ou : support ## SECOND Level hierarchy - people entries # this is an ENTRY sequence and is preceded by a BLANK line dn : cn=John Smith,ou=people,dc=example,dc=com objectclass : inetOrgPerson cn : John Smith sn : smith uid : jsmith mail : jim@example.com mail : j.smith@example.com ou : accounting base.ldif dn : ou=usuarios,dc=pandora,dc=ldap objectClass : organizationalUnit objectClass : top ou : usuarios dn : ou=grupos,dc=pandora,dc=ldap objectClass : organizationalUnit objectClass : top ou : grupos content.ldif dn : cn=devops,ou=grupos,dc=pandora,dc=ldap objectClass : posixGroup cn : devops gidNumber : 10000 memberUid : devops dn : uid=mordecai,ou=usuarios,dc=pandora,dc=ldap objectClass : inetOrgPerson objectClass : posixAccount objectClass : shadowAccount cn : Mordecai sn : Geek userPassword : { SSHA } latDDmodpsLUWDqwd/adk/j2tTDgz3NX loginshell : /bin/bash uidNumber : 10000 gidNumber : 10000 homeDirectory : /home/mordecai","title":"LDIF"},{"location":"04_LDAP/042_LDAP_DIT.html#actividades-desarrollo-ud2_01","text":"Creaci\u00f3n de usuarios y grupos OpenLDAP","title":"Actividades Desarrollo UD2_01"},{"location":"04_LDAP/042_LDAP_DIT.html#actividades-desarrollo-ud2_02","text":"Configuraci\u00f3n de equipo cliente","title":"Actividades Desarrollo UD2_02"},{"location":"04_LDAP/042_LDAP_DIT.html#actividades-desarrollo-ud2_03","text":"En este ejercicio se deben utilizar los comandos de OpenLdap instalados en el paquete LDAPutils . A\u00f1ade un nuevo grupo y dentro de el un nuevo usuario a la estructura de directorio creada en la pr\u00e1ctica superior. Crea una contrase\u00f1a para el usuario. Modifica el uid creado de inicio. Crea un segundo usuario, dentro de usuarios Elimina el segundo usuario creado. En cada subapartado comprueba que se han introducido correctamente las modificaciones en el DIT .","title":"Actividades Desarrollo UD2_03"},{"location":"04_LDAP/042_LDAP_DIT.html#actividades-desarrollo-ud2_04","text":"Instalaci\u00f3n y configuraci\u00f3n phpLDAPadmin","title":"Actividades Desarrollo UD2_04"},{"location":"04_LDAP/043_LDAP_Esquema.html","text":"Esquema LDAP \u00b6 El esquema es una parte importante de LDAP. Similar a la definici\u00f3n del esquema de la base de datos, el esquema LDAP define la estructura y las reglas que debe seguir un directorio LDAP, como qu\u00e9 atributos tendr\u00e1 una clase de objeto, qu\u00e9 estructura tienen estos atributos, etc. El servidor LDAP proporciona una manera de identificar categor\u00edas, atributos y otra informaci\u00f3n en el directorio LDAP, para que el servidor LDAP pueda reconocerlos. Para realizarlo se utlizan esquemas , que no es m\u00e1s que una unidad de empaquetado conveniente para contener clases de objetos y atributos muy similares . La principal diferencia con las bases de datos relacionales del protocolo LDAP es que estas ya est\u00e1n predefinidas en los esquemas. por lo que nos ahorramos en insertar y definir las tablas de informaci\u00f3n. En OpenLDAP los esquemas instalados se encuentran en cn = schema, cn = config y se pueden instalar esquemas adicionales usando este procedimiento. El siguiente diagrama ilustra el uso de esquemas como unidades de empaquetado: Ejemplo de la definici\u00f3n de Esquemas en LDAP A nivel de comandos se pueden ver los esquemas predefinidos con: cd /etc/ldap/slapd.d/cn\\=config/ En el directorio cn\\=schema se pueden ver los esquemas y ademas se pueden a\u00f1adir m\u00e1s, pero no suele ser frecuente. Para buscar los esquemas se puede utilizar: grep olcObjectClasses cn\\=\\{3\\}inetorgperson.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{2\\}inetorgperson.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{2\\}nis.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{1\\}cosine.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{0\\}core.ldif|awk '{print $5}' Herramientas de gesti\u00f3n de usuarios. \u00b6 Una vez configurado el servidor LDAP, para la utilizaci\u00f3n normal debemos aprender c\u00f3mo se a\u00f1aden nuevos usuarios o se modifican los atributos de los existentes. Para los objetos iniciales del directorio, primero se debe escribir un fichero en formato LDIF que incluya todos los atributos de la entrada y a\u00f1adirla al directorio con slapadd. En la Actividades Desarrollo UD2_01 , se realizar\u00e1 un ejemplo guiado al respecto. Este m\u00e9todo es totalmente inadecuado para la utilizaci\u00f3n cuando el directorio est\u00e1 activo. Existen varias formas de actualizar las entradas del directorio o a\u00f1adir nuevas, y en primer lugar veremos la utilizaci\u00f3n de las herramientas incluidas en el paquete ldap-utils . ldap-utils \u00b6 Para realizar modificaciones de los objetos del directorio directamente desde la l\u00ednea de comandos, se pueden utilizar las herramientas del paquete ldap-utils , a continuaci\u00f3n se describen algunas de ellas. Mostrar entradas \u00b6 ldapsearch - buscar y mostrar entradas La herramienta ldapsearch resulta muy conveniente al momento de hacer consultas sobre los datos dentro de un directorio LDAP desde l\u00ednea de comandos. A continuaci\u00f3n se presentan una serie de consultas de ejemplo que pueden resultar muy \u00fatiles para obtener informaci\u00f3n valiosa de un \u00e1rbol LDAP. Obtener todos los objetos de un directorio \u00b6 Para obtener todos los objetos en un directorio (dn) a partir de cierta base con el ejemplo de la pr\u00e1ctica ( dc=pandora,dc=ldap ) y sin l\u00edmite de para la respuesta, utilizar una consulta como la siguiente: ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=admin,dc=pandora,dc=ldap\" -b \"dc=pandora,dc=ldap\" \"(objectclass=*)\" Note -z 0 : evita cortar la respuesta una vez alcanzado cierto l\u00edmite (cantidad de entradas). -H ldap://localhost:389 : indica que consulte al servidor LDAP en el puerto 389 del host local. -W : indica que solicite la contrase\u00f1a para el m\u00e9todo de autenticaci\u00f3n simple de manera interactiva. -D \"cn=admin,dc=pandora,dc=ldap\" : especifica el usuario con el cual se autentica en el servidor LDAP. -b \"dc=pandora,dc=ldap\" : especifica la base desde donde comenzar la b\u00fasqueda (en este caso se trata de la ra\u00edz del directorio). \"(objectclass=*)\" : especifica el filtro para la b\u00fasqueda (en este ejemplo todos los objetos, este a su vez es el filtro por defecto). Warning El punto importante es no olvidar especificar la base ( -b ). De lo contrario probablemente no haya resultados en la b\u00fasqueda: A este ejemplo se le puede a\u00f1adir grep para filtrar s\u00f3lo los dn: ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=admin,dc=pandora,dc=ldap\" -b \"dc=pandora,dc=ldap\" \"(objectclass=*)\" | grep \"dn:\" El resultado ser\u00eda parecido a: Obtener todas las unidades organizacionales \u00b6 Las ou ( Organizational Unit ) definen la jerarqu\u00eda dentro de un dominio. Generalmente se utilizan para definir los departamentos o \u00e1reas dentro de una organizaci\u00f3n (empresa, red, sociedad, etc.). Para obtener una lista de todas las ou presentes en un directorio, se puede utilizar el filtro \"(ou=*)\" : ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=admin,dc=pandora,dc=ldap\" -b \"dc=pandora,dc=ldap\" \"(ou=*)\" | grep \"dn:\" Resultado Listar todos los usuarios \u00b6 Esta consulta depende de la jerarqu\u00eda y la clase utilizada para almacenar usuarios dentro de un \u00e1rbol LDAP. Sin embargo, generalmente se utiliza la clase inetOrgPerson para almacenar usuarios dentro de un directorio LDAP, la cual posee el atributo uid . De esta forma, para listar todos los usuarios presentes en un directorio, simplemente recurrir al filtro \"(uid=*)\" : ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=admin,dc=pandora,dc=ldap\" -b \"dc=pandora,dc=ldap\" \"(uid=*)\" | grep \"dn:\" Resultado Determinar todas las clases en uso \u00b6 Las clases de un directorio LDAP determinan el formato con el que se representan los datos de los objetos almacenados en el \u00e1rbol. Cada objeto (entrada en un directorio LDAP) pertenece a al menos una clase. Sin embargo es com\u00fan que cada objeto pertenezca a varias clases. B\u00e1sicamente las clases definen qu\u00e9 atributos y de qu\u00e9 formato puede poseer un objeto. Para listar todas las clases actualmente en uso por todos los objetos, es necesario volcar todo el contenido del \u00e1rbol y filtrar con grep : ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=admin,dc=pandora,dc=ldap\" -b \"dc=pandora,dc=ldap\" \"(objectclass=*)\" | grep objectClass | sort | uniq Resultado Manipular entradas \u00b6 ldapmodify - modificar una entrada ldapadd - agregar una nueva entrada ldapdelete - eliminar y entrar ldapmodrdn - cambiar el nombre de una entrada ldappasswd : cambie la contrase\u00f1a de una entrada Ejemplos: \u00b6 A\u00f1adir y eliminar nuevos grupos con ldapadd & ldapdelete Se crea un archivo .ldif para a\u00f1adir un nuevo grupo y se a\u00f1ade con ldapadd : nano aso.ldif dn : ou=aso,dc=pandora,dc=ldap objectClass : organizationalUnit objectClass : top ou : aso ldapadd -x -W -D \"cn=admin,dc=pandora,dc=ldap\" -f aso.ldif Para borrarlo se utilizar\u00eda: ldapdelete -W -D \"cn=admin,dc=pandora,dc=ldap\" \"ou=aso,dc=pandora,dc=ldap\" A\u00f1adir y eliminar usuarios con ldapadd & ldapdelete Se crea un archivo .ldif para a\u00f1adir un nuevo grupo y se a\u00f1ade con ldapadd : nano javier.ldif dn : uid=javier,ou=usuarios,dc=pandora,dc=ldap objectClass : inetOrgPerson objectClass : posixAccount objectClass : shadowAccount cn : Javier sn : Hernandez userPassword : { SSHA } latDDmodpsLUWDqwd/adk/j2tTDgz3NX loginshell : /bin/bash uidNumber : 10001 gidNumber : 10001 homeDirectory : /home/javier ldapadd -x -W -D \"cn=admin,dc=pandora,dc=ldap\" -f javier.ldif Para borrarlo se utilizar\u00eda: ldapdelete -W -D \"cn=admin,dc=pandora,dc=ldap\" \"uid=javier,ou=aso,dc=pandora,dc=ldap\" modificar uidnumber de usuario existente ldapmodify Se crea un archivo .ldif especificando las modificaciones: nano cambios1.ldif dn : uid=javier,ou=aso,dc=pandora,dc=ldap changetype:modify replace:uidNumber uidNumber:10002 Para modificarlo se utilizar\u00eda: ldapmodify -x -W -D \"cn=admin,dc=pandora,dc=ldap\" -f cambios1.ldif Note Cuatro tipos de cambios son posibles add--adds a new entry modify--changes an existing entry, that is, it adds, deletes, or replaces attributes of the entry delete--deletes an existing entry modrdn--modifies the RDN of an existing entry A\u00f1adir y cambiar contrase\u00f1a a un usuario existente con ldappasswd A\u00f1adir contrase\u00f1a ldappasswd -s 1234 -W -D \"cn=admin,dc=pandora,dc=ldap\" -x \"uid=javier,ou=aso,dc=pandora,dc=ldap\" Operaciones \u00b6 ldapwhoami : muestra con qu\u00e9 entrada estoy vinculado al servidor ldapcompare : compara un campo en la entrada con alg\u00fan valor Configuraci\u00f3n de OpenLDAP \u00b6 slapd.conf \u00b6 Es el archivo principal de OpenLDAP y es aqu\u00ed donde se configuran todos sus par\u00e1metros. Note slapd.conf se encuentra dentro del directorio /etc/ldap/slapd.d Dise\u00f1o de configuraci\u00f3n \u00b6 La configuraci\u00f3n de slapd se almacena como un directorio LDAP especial con un esquema y DIT predefinidos . Hay clases de objetos espec\u00edficas que se utilizan para llevar opciones de configuraci\u00f3n global, definiciones de esquema, definiciones de base de datos y back-end, y otros elementos variados. \u00c1rbol de configuraci\u00f3n de muestra. En el servidor se podr\u00eda observar: \u00c1rbol (DIT)de configuraci\u00f3n En Ubuntu Server. El \u00e1rbol de configuraci\u00f3n de slapd-config tiene una estructura muy espec\u00edfica. La ra\u00edz del \u00e1rbol se denomina cn = config y contiene ajustes de configuraci\u00f3n global. Directivas de configuraci\u00f3n \u00b6 De las directivas m\u00e1s comunes mostradas en el arblo se destaca centro de cn = config la directiva olcLogLevel Esta directiva especifica el nivel en el que las declaraciones de depuraci\u00f3n y las estad\u00edsticas de operaci\u00f3n deben registrarse en el syslog (actualmente registrado en la funci\u00f3n syslogd (8) LOG_LOCAL4 ) . Debe haber configurado OpenLDAP --enable-debug (el predeterminado) para que esto funcione (excepto para los dos niveles de estad\u00edsticas, que siempre est\u00e1n habilitados). Configuraci\u00f3n logging \u00b6 El registro de actividad para slapd es muy \u00fatil cuando se implementa una soluci\u00f3n basada en OpenLDAP, pero debe habilitarse manualmente despu\u00e9s de la instalaci\u00f3n del software. De lo contrario, solo aparecer\u00e1n mensajes rudimentarios en los registros. El registro, como cualquier otra configuraci\u00f3n similar, se habilita a trav\u00e9s de la base de datos slapd-config . OpenLDAP viene con m\u00faltiples niveles de registro y cada uno contiene el m\u00e1s bajo (aditivo). Un buen nivel para probar son las estad\u00edsticas . La p\u00e1gina de manual de slapd-config tiene m\u00e1s que decir sobre los diferentes subsistemas. Cree el archivo logging.ldif con el siguiente contenido: dn : cn=config changetype : modify replace : olcLogLevel olcLogLevel : stats Implementar el cambio: sudo ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f logging.ldif Esto producir\u00e1 una cantidad significativa de registro y querr\u00e1 volver a un nivel menos detallado una vez que su sistema est\u00e9 en producci\u00f3n. Mientras est\u00e1 en este modo detallado, el motor syslog de su host (rsyslog) puede tener dificultades para mantenerse al d\u00eda y puede dejar caer mensajes: Warning rsyslogd-2177: imuxsock lost 228 messages from pid 2547 due to rate-limiting Puede considerarse un cambio en la configuraci\u00f3n de rsyslog . En /etc/rsyslog.conf , ponga: # Disable rate limiting # (default is 200 messages in 5 seconds; below we make the 5 become 0) $SystemLogRateLimitInterval 0 Y luego reinicie el demonio rsyslog: sudo systemctl restart syslog.service Los Registros de OpenLDAP a trav\u00e9s de syslogd LOCAL4 (Nivel warning de Syslog). Para transmitir el registro LDAP a un archivo separado de syslog, agregue una l\u00ednea como esta a syslog.conf ( /etc/rsyslog.conf ): # a. agregar a syslog.conf local4. * /var/log/ldap.log # b. crear un archivo de registro vac\u00edo toque /var/log/ldap.log # c. reiniciar syslogd killall -HUP syslogd O systemctl restart syslog.service M\u00e1s informaci\u00f3n sobre looging OpenLdap","title":"043 LDAP Esquema"},{"location":"04_LDAP/043_LDAP_Esquema.html#esquema-ldap","text":"El esquema es una parte importante de LDAP. Similar a la definici\u00f3n del esquema de la base de datos, el esquema LDAP define la estructura y las reglas que debe seguir un directorio LDAP, como qu\u00e9 atributos tendr\u00e1 una clase de objeto, qu\u00e9 estructura tienen estos atributos, etc. El servidor LDAP proporciona una manera de identificar categor\u00edas, atributos y otra informaci\u00f3n en el directorio LDAP, para que el servidor LDAP pueda reconocerlos. Para realizarlo se utlizan esquemas , que no es m\u00e1s que una unidad de empaquetado conveniente para contener clases de objetos y atributos muy similares . La principal diferencia con las bases de datos relacionales del protocolo LDAP es que estas ya est\u00e1n predefinidas en los esquemas. por lo que nos ahorramos en insertar y definir las tablas de informaci\u00f3n. En OpenLDAP los esquemas instalados se encuentran en cn = schema, cn = config y se pueden instalar esquemas adicionales usando este procedimiento. El siguiente diagrama ilustra el uso de esquemas como unidades de empaquetado: Ejemplo de la definici\u00f3n de Esquemas en LDAP A nivel de comandos se pueden ver los esquemas predefinidos con: cd /etc/ldap/slapd.d/cn\\=config/ En el directorio cn\\=schema se pueden ver los esquemas y ademas se pueden a\u00f1adir m\u00e1s, pero no suele ser frecuente. Para buscar los esquemas se puede utilizar: grep olcObjectClasses cn\\=\\{3\\}inetorgperson.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{2\\}inetorgperson.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{2\\}nis.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{1\\}cosine.ldif|awk '{print $5}' grep olcObjectClasses cn\\=\\{0\\}core.ldif|awk '{print $5}'","title":"Esquema LDAP"},{"location":"04_LDAP/043_LDAP_Esquema.html#herramientas-de-gestion-de-usuarios","text":"Una vez configurado el servidor LDAP, para la utilizaci\u00f3n normal debemos aprender c\u00f3mo se a\u00f1aden nuevos usuarios o se modifican los atributos de los existentes. Para los objetos iniciales del directorio, primero se debe escribir un fichero en formato LDIF que incluya todos los atributos de la entrada y a\u00f1adirla al directorio con slapadd. En la Actividades Desarrollo UD2_01 , se realizar\u00e1 un ejemplo guiado al respecto. Este m\u00e9todo es totalmente inadecuado para la utilizaci\u00f3n cuando el directorio est\u00e1 activo. Existen varias formas de actualizar las entradas del directorio o a\u00f1adir nuevas, y en primer lugar veremos la utilizaci\u00f3n de las herramientas incluidas en el paquete ldap-utils .","title":"Herramientas de gesti\u00f3n de usuarios."},{"location":"04_LDAP/043_LDAP_Esquema.html#ldap-utils","text":"Para realizar modificaciones de los objetos del directorio directamente desde la l\u00ednea de comandos, se pueden utilizar las herramientas del paquete ldap-utils , a continuaci\u00f3n se describen algunas de ellas.","title":"ldap-utils"},{"location":"04_LDAP/043_LDAP_Esquema.html#configuracion-de-openldap","text":"","title":"Configuraci\u00f3n de OpenLDAP"},{"location":"04_LDAP/043_LDAP_Esquema.html#slapdconf","text":"Es el archivo principal de OpenLDAP y es aqu\u00ed donde se configuran todos sus par\u00e1metros. Note slapd.conf se encuentra dentro del directorio /etc/ldap/slapd.d","title":"slapd.conf"},{"location":"04_LDAP/044_LDAPutilsSobras.html","text":"La herramienta ldapsearch , provista por el paquete, resulta muy conveniente al momento de hacer consultas sobre los datos dentro de un directorio LDAP desde l\u00ednea de comandos. Este art\u00edculo presenta una serie de consultas de ejemplo que pueden resultar muy \u00fatiles para obtener informaci\u00f3n valiosa de un \u00e1rbol LDAP. Obtener todos los objetos de un directorio \u00b6 Para obtener todos los objetos en un directorio (dn) a partir de cierta base ( dc=linuxito,dc=com ) y sin l\u00edmite de para la respuesta, utilizar una consulta como la siguiente: ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(objectclass=*) -z 0 : evita cortar la respuesta una vez alcanzado cierto l\u00edmite (cantidad de entradas). -H ldap://localhost:389 : indica que consulte al servidor LDAP en el puerto 389 del host local. -W : indica que solicite la contrase\u00f1a para el m\u00e9todo de autenticaci\u00f3n simple de manera interactiva. -D \"cn=root,dc=linuxito,dc=com\" : especifica el usuario con el cual se autentica en el servidor LDAP. -b \"dc=linuxito,dc=com\" : especifica la base desde donde comenzar la b\u00fasqueda (en este caso se trata de la ra\u00edz del directorio). \"(objectclass=*)\" : especifica el filtro para la b\u00fasqueda (en este ejemplo todos los objetos, este a su vez es el filtro por defecto). El punto importante es no olvidar especificar la base ( -b ). De lo contrario probablemente no haya resultados en la b\u00fasqueda: # search result search: 2 result: 32 No such object Ejemplo (utilizando grep para filtrar s\u00f3lo los dn): root@debian:~# ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(objectclass=*)\" | grep \"dn:\" Enter LDAP Password: dn: dc=linuxito,dc=com dn: cn=Manager,dc=linuxito,dc=com dn: ou=users,dc=linuxito,dc=com dn: uid=emiliano,ou=users,dc=linuxito,dc=com dn: uid=test,ou=users,dc=linuxito,dc=com dn: ou=fusiondirectory,dc=linuxito,dc=com dn: cn=config,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=aclroles,dc=linuxito,dc=com dn: cn=admin,ou=aclroles,dc=linuxito,dc=com dn: ou=people,dc=linuxito,dc=com dn: uid=fd-admin,ou=people,dc=linuxito,dc=com dn: cn=manager,ou=aclroles,dc=linuxito,dc=com dn: cn=editowninfos,ou=aclroles,dc=linuxito,dc=com dn: cn=editownpwd,ou=aclroles,dc=linuxito,dc=com dn: ou=recovery,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=reminder,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=locks,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=snapshots,dc=linuxito,dc=com Recordar que hay exactamente un dn ( distinguished name ) por cada entrada en el \u00e1rbol. Por supuesto al salida es muy extensa y presenta todos los atributos para cada entrada en el \u00e1rbol. Se recomienda utilizar grep para filtrar y lograr una salida m\u00e1s legible (recuperar s\u00f3lo aquella informaci\u00f3n que nos interesa). Obtener todas las unidades organizacionales \u00b6 Las ou ( Organizational Unit ) definen la jerarqu\u00eda dentro de un dominio. Generalmente se utilizan para definir los departamentos o \u00e1reas dentro de una organizaci\u00f3n (empresa, red, sociedad, etc.). Para obtener una lista de todas las ou presentes en un directorio, se puede utilizar el filtro \"(ou=*)\" : ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(ou=*)\" Ejemplo: root@debian:~# ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(ou=*)\" | grep \"dn:\" Enter LDAP Password: dn: dc=linuxito,dc=com dn: ou=users,dc=linuxito,dc=com dn: ou=fusiondirectory,dc=linuxito,dc=com dn: ou=aclroles,dc=linuxito,dc=com dn: ou=people,dc=linuxito,dc=com dn: ou=recovery,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=reminder,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=locks,ou=fusiondirectory,dc=linuxito,dc=com dn: ou=snapshots,dc=linuxito,dc=com Listar todos los usuarios \u00b6 Esta consulta depende de la jerarqu\u00eda y la clase utilizada para almacenar usuarios dentro de un \u00e1rbol LDAP. Sin embargo, generalmente se utiliza la clase inetOrgPerson para almacenar usuarios dentro de un directorio LDAP, la cual posee el atributo uid . De esta forma, para listar todos los usuarios presentes en un directorio, simplemente recurrir al filtro \"(uid=*)\" : ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(uid=*)\" Por ejemplo: root@debian:~# ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(uid=*)\" | grep -B 1 \"dn:\" Enter LDAP Password: # emiliano, users, linuxito.com dn: uid=emiliano,ou=users,dc=linuxito,dc=com -- # test, users, linuxito.com dn: uid=test,ou=users,dc=linuxito,dc=com -- # fd-admin, people, linuxito.com dn: uid=fd-admin,ou=people,dc=linuxito,dc=com Determinar todas las clases en uso \u00b6 Las clases de un directorio LDAP determinan el formato con el que se representan los datos de los objetos almacenados en el \u00e1rbol. Cada objeto (entrada en un directorio LDAP) pertenece a al menos una clase. Sin embargo es com\u00fan que cada objeto pertenezca a varias clases. B\u00e1sicamente las clases definen qu\u00e9 atributos y de qu\u00e9 formato puede poseer un objeto. Para listar todas las clases actualmente en uso por todos los objetos, es necesario volcar todo el contenido del \u00e1rbol y filtrar con grep : ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(objectclass=*)\" | grep objectClass | sort | uniq Por ejemplo: root@debian:~# ldapsearch -z 0 -H ldap://localhost:389 -W -D \"cn=root,dc=linuxito,dc=com\" -b \"dc=linuxito,dc=com\" \"(objectclass=*)\" | grep objectClass | sort | uniq Enter LDAP Password: objectClass: account objectClass: dcObject objectClass: fdAliasPluginConf objectClass: fdApplicationsPluginConf objectClass: fdAuditPluginConf objectClass: fdAutofsPluginConf objectClass: fdCommunityPluginConf objectClass: fdDashboardPluginConf objectClass: fdDhcpPluginConf objectClass: fdDnsPluginConf objectClass: fdDsaPluginConf objectClass: fdEjbcaPluginConf objectClass: fdFaiPluginConf objectClass: fdInventoryPluginConf objectClass: fdMailPluginConf objectClass: fdNagiosPluginConf objectClass: fdNetgroupPluginConf objectClass: fdNewsletterPluginConf objectClass: fdOpsiPluginConf objectClass: fdPasswordRecoveryConf objectClass: fdPersonalPluginConf objectClass: fdPpolicyPluginConf objectClass: fdRepositoryPluginConf objectClass: fdSambaPluginConf objectClass: fdSogoPluginConf objectClass: fdSudoPluginConf objectClass: fdSupannPluginConf objectClass: fdSympaPluginConf objectClass: fdSystemsPluginConf objectClass: fdUserReminderPluginConf objectClass: fdWebservicePluginConf objectClass: fusionDirectoryConf objectClass: fusionDirectoryPluginsConf objectClass: gosaAcl objectClass: gosaDepartment objectClass: gosaRole objectClass: inetOrgPerson objectClass: organization objectClass: organizationalPerson objectClass: organizationalRole objectClass: organizationalUnit objectClass: person objectClass: posixAccount objectClass: shadowAccount objectClass: top Esta consulta permitir\u00e1 identificar qu\u00e9 schemas dentro de una servidor LDAP est\u00e1n siendo utilizados y cu\u00e1les no. Referencias \u00b6 Object Naming - Microsoft TechNet Organizational Units - Microsoft TechNet LDAP DNs and RDNs LDAP Object Classes RFC 2798 - Definition of the inetOrgPerson LDAP Object Class","title":"044 LDAPutilsSobras"},{"location":"04_LDAP/Practica01_LDAP.html","text":"Instalaci\u00f3n y configuraci\u00f3n b\u00e1sica del servidor Open LDAP \u00b6 Antes de comenzar la instalaci\u00f3n de OpenLDAP, es recomendable realizar unos pasos previos, a continuaci\u00f3n se describen: En primer lugar se aconseja utilizar IP fijas en el aula, que ser\u00e1n clase c de esta forma: 192.168.5.X , donde X ser\u00e1 el n\u00famero de puesto. Ejemplo Para ello se modifica el archivo /etc/netplan/00-installer-config.yaml La figura anterior muestra un ejemplo de modificaci\u00f3n con una red para ubuntu server 22.04 con una red 192.168.8.0/24 . A continuaci\u00f3n se modifica el archivo Hots para cambiar el nombre de la m\u00e1quina en el dominio configurado. Con las siguientes premisas. Modificar el contenido del fichero /etc/hosts para indicar un FQDN ( fully qualified domain name) a nuestro servidor. FQDN es un nombre de dominio completo que incluye el nombre de la computadora y el nombre de dominio asociado a ese equipo.\u200b\u200b Por ejemplo, dada la computadora llamada \u00abaso\u00bb y el nombre de dominio \u00abaso.ldap.\u00bb El objetivo de este cambio es que cuando hagamos referencia a aso.ldap, nuestro sistema entienda que nos estamos refiriendo al servidor. Esto, adem\u00e1s, facilitar\u00e1 la labor de configuraci\u00f3n de nuestro servicio de directorio. Para modificar el dicho archivo se ejecuta el siguiente comando. sudo nano /etc/hosts Ejemplo Implantaci\u00f3n del Servicio OpenLDAP \u00b6 En este apartado se explican en forma de gu\u00eda pr\u00e1ctica los pasos de la implantaci\u00f3n del servicio OpenLDAP en un servidor Ubuntu 22.04 Consejo A priori se podr\u00eda revisar con antelaci\u00f3n los paquetes a instalar con: apt show slapd Instalaci\u00f3n : Se instalan los paquetes necesarios en el servidor. sudo apt install slapd ldap-utils Seguidamente se instala el paquete de LDAP. Autom\u00e1ticamente nos aparecer\u00e1 una ventana donde introduciremos la contrase\u00f1a (En este caso aso , pero se aconseja introducir una contrase\u00f1a m\u00e1s robusta) de administrador para el directorio LDAP. Seguidamente terminar\u00e1 el proceso de instalaci\u00f3n. Se puede comprobar que se ha instalado correctamente ejecutando el comando slapcat . Dicho comando muestra en formato LDIF el contenido de las entradas existentes en el servicio de directorio. sudo slapcat Adem\u00e1s se puede comprobar que el servicio esta corriendo con: systemctl status slapd.service Tambi\u00e9n se puede comprobar si el servicio de directorio OpenLdap esta escuchando por el puerto 389 . ss -lntp Configuraci\u00f3n : se realiza la configuraci\u00f3n de nuestro servicio de directorio usando el asistente de slapd . Para ello se ejecuta la siguiente instrucci\u00f3n: sudo dpkg-reconfigure slapd El primer paso del asistente pregunta si quiere omitir la configuraci\u00f3n del servidor OpenLDAP. Elegiremos que NO para poder configurarlo. A continuaci\u00f3n pregunta por el dominio en el que se encuentra nel servidor, esto va a formar parte del DN del directorio LDAP. Al haberlo indicado anteriormente en el fichero /etc/hosts , autom\u00e1ticamente el asistente lo recoge y lo modificamos para a\u00f1adir aso, quedar\u00eda aso.ldap . Luego pregunta por el nombre de la organizaci\u00f3n a la que va a pertenecer nuestro servidor LDAP. Se puede elegir una contrase\u00f1a f\u00e1cil para la pr\u00e1ctica como asoldap . Pulsamos OK. Adem\u00e1s nos vuelve a pedir la contrase\u00f1a de administrador del directorio LDAP. Esta que pongamos va a machacar la que indicamos en el proceso de instalaci\u00f3n y ser\u00e1 la definitiva. Como suele pasar, la deberemos introducir dos veces para evitar errores tipogr\u00e1ficos. Seguidamente pregunta si se elimina la base de datos del directorio LDAP cuando se borre el paquete slapd del sistema. Se indicar\u00e1 que NO . Y por \u00faltimo pregunta si se quiere mover los datos de alguna antigua base de datos de directorio LDAP a la nueva que se est\u00e1 configurando. En este caso, como no se tiene ninguna antigua no va afectar en nada, lo dejaremos en SI y finalizar\u00e1 la configuraci\u00f3n. Una vez finalizado el asistente, se vuelve a ejecutar el comando slapcat y se observa como se han modificado los valores de los atributos de las entradas, con los datos que se acaban de indicar. sudo slapcat","title":"Instalaci\u00f3n y configuraci\u00f3n b\u00e1sica del servidor Open LDAP"},{"location":"04_LDAP/Practica01_LDAP.html#instalacion-y-configuracion-basica-del-servidor-open-ldap","text":"Antes de comenzar la instalaci\u00f3n de OpenLDAP, es recomendable realizar unos pasos previos, a continuaci\u00f3n se describen: En primer lugar se aconseja utilizar IP fijas en el aula, que ser\u00e1n clase c de esta forma: 192.168.5.X , donde X ser\u00e1 el n\u00famero de puesto. Ejemplo Para ello se modifica el archivo /etc/netplan/00-installer-config.yaml La figura anterior muestra un ejemplo de modificaci\u00f3n con una red para ubuntu server 22.04 con una red 192.168.8.0/24 . A continuaci\u00f3n se modifica el archivo Hots para cambiar el nombre de la m\u00e1quina en el dominio configurado. Con las siguientes premisas. Modificar el contenido del fichero /etc/hosts para indicar un FQDN ( fully qualified domain name) a nuestro servidor. FQDN es un nombre de dominio completo que incluye el nombre de la computadora y el nombre de dominio asociado a ese equipo.\u200b\u200b Por ejemplo, dada la computadora llamada \u00abaso\u00bb y el nombre de dominio \u00abaso.ldap.\u00bb El objetivo de este cambio es que cuando hagamos referencia a aso.ldap, nuestro sistema entienda que nos estamos refiriendo al servidor. Esto, adem\u00e1s, facilitar\u00e1 la labor de configuraci\u00f3n de nuestro servicio de directorio. Para modificar el dicho archivo se ejecuta el siguiente comando. sudo nano /etc/hosts Ejemplo","title":"Instalaci\u00f3n y configuraci\u00f3n b\u00e1sica del servidor Open LDAP"},{"location":"04_LDAP/Practica01_LDAP.html#implantacion-del-servicio-openldap","text":"En este apartado se explican en forma de gu\u00eda pr\u00e1ctica los pasos de la implantaci\u00f3n del servicio OpenLDAP en un servidor Ubuntu 22.04 Consejo A priori se podr\u00eda revisar con antelaci\u00f3n los paquetes a instalar con: apt show slapd Instalaci\u00f3n : Se instalan los paquetes necesarios en el servidor. sudo apt install slapd ldap-utils Seguidamente se instala el paquete de LDAP. Autom\u00e1ticamente nos aparecer\u00e1 una ventana donde introduciremos la contrase\u00f1a (En este caso aso , pero se aconseja introducir una contrase\u00f1a m\u00e1s robusta) de administrador para el directorio LDAP. Seguidamente terminar\u00e1 el proceso de instalaci\u00f3n. Se puede comprobar que se ha instalado correctamente ejecutando el comando slapcat . Dicho comando muestra en formato LDIF el contenido de las entradas existentes en el servicio de directorio. sudo slapcat Adem\u00e1s se puede comprobar que el servicio esta corriendo con: systemctl status slapd.service Tambi\u00e9n se puede comprobar si el servicio de directorio OpenLdap esta escuchando por el puerto 389 . ss -lntp Configuraci\u00f3n : se realiza la configuraci\u00f3n de nuestro servicio de directorio usando el asistente de slapd . Para ello se ejecuta la siguiente instrucci\u00f3n: sudo dpkg-reconfigure slapd El primer paso del asistente pregunta si quiere omitir la configuraci\u00f3n del servidor OpenLDAP. Elegiremos que NO para poder configurarlo. A continuaci\u00f3n pregunta por el dominio en el que se encuentra nel servidor, esto va a formar parte del DN del directorio LDAP. Al haberlo indicado anteriormente en el fichero /etc/hosts , autom\u00e1ticamente el asistente lo recoge y lo modificamos para a\u00f1adir aso, quedar\u00eda aso.ldap . Luego pregunta por el nombre de la organizaci\u00f3n a la que va a pertenecer nuestro servidor LDAP. Se puede elegir una contrase\u00f1a f\u00e1cil para la pr\u00e1ctica como asoldap . Pulsamos OK. Adem\u00e1s nos vuelve a pedir la contrase\u00f1a de administrador del directorio LDAP. Esta que pongamos va a machacar la que indicamos en el proceso de instalaci\u00f3n y ser\u00e1 la definitiva. Como suele pasar, la deberemos introducir dos veces para evitar errores tipogr\u00e1ficos. Seguidamente pregunta si se elimina la base de datos del directorio LDAP cuando se borre el paquete slapd del sistema. Se indicar\u00e1 que NO . Y por \u00faltimo pregunta si se quiere mover los datos de alguna antigua base de datos de directorio LDAP a la nueva que se est\u00e1 configurando. En este caso, como no se tiene ninguna antigua no va afectar en nada, lo dejaremos en SI y finalizar\u00e1 la configuraci\u00f3n. Una vez finalizado el asistente, se vuelve a ejecutar el comando slapcat y se observa como se han modificado los valores de los atributos de las entradas, con los datos que se acaban de indicar. sudo slapcat","title":"Implantaci\u00f3n del Servicio OpenLDAP"},{"location":"04_LDAP/Practica02_LDAP.html","text":"Con nuestro servicio instalado y configurado, el siguiente paso es crear la estructura b\u00e1sica del directorio. Es decir, crearemos la estructura jer\u00e1rquica del \u00e1rbol (DIT -- Directory Information Tree). Una de las formas m\u00e1s sencillas de a\u00f1adir entradas al directorio es mediante ficheros LDIF (LDAP Data Interchange Format). B\u00e1sicamente se tratan de ficheros en texto plano con un formato particular que debemos conocer para poder construirlos correctamente. El formato b\u00e1sico de una entrada es el siguiente: # comentario dn: <nombre distintivo \u00fanico> <atributo>: <valor> <atributo>: <valor> ... Teniendo en cuenta lo anteriormente mencionado, procedemos a crear un fichero base que contenga los tipos de objetos b\u00e1sicos del directorio. nano base.ldif En \u00e9l vamos a crear dos entradas referentes a unidades organizativas: \u00abusuarios\u00bb y \u00abgrupos\u00bb. Las unidades organizativas, como su propio nombre indica, son atributos que nos van a servir para estructurar de forma id\u00f3nea nuestro \u00e1rbol del directorio LDAP. Estas dos entradas ser\u00e1n la base de nuestro \u00e1rbol ya que de ellas depender\u00e1n varias entradas m\u00e1s adelante. Una vez creado el fichero base.ldif, procedemos a cargarlo en directorio LDAP. Para ello ejecutamos la siguiente instrucci\u00f3n: sudo ldapadd -x -D cn=admin,dc=pandora,dc=ldap -W -f base.ldif Una vez cargadas las entradas, vamos a proceder a crear nuevas entradas que colgar\u00e1n de las unidades organizativas que acabamos de crear. Vamos a crear una entrada para un grupo y una entrada para un usuario. Antes que nada, como buena pr\u00e1ctica de seguridad, vamos a generar una contrase\u00f1a cifrada para asign\u00e1rselas a los usuarios en el fichero LDIF que vamos a crear. Para ello ejecutamos el siguiente comando: slappasswd Escribimos la contrase\u00f1a dos veces y nos devolver\u00e1 la misma cifrada por el algoritmo criptogr\u00e1fico SSHA. Ahora que tenemos la contrase\u00f1a cifrada creamos nuestro fichero content.ldif, donde vamos a crear dos entradas: un grupo llamado devops que colgar\u00e1 de la unidad organizativa grupos y un usuario llamado mordecai que colgar\u00e1 de la unidad organizativa usuarios y a su vez pertenecer\u00e1 al grupo devops. nano content.ldif De la misma forma que anteriormente, procedemos a cargar las entradas en el directorio LDAP ejecutando la siguiente instrucci\u00f3n: sudo ldapadd -x -D cn=admin,dc=pandora,dc=ldap -W -f content.ldif Llegados a este punto ya tenemos una estructura jer\u00e1rquica del \u00e1rbol creada de la siguiente manera: Para poder ver las diferentes entradas que forman nuestro directorio LDAP ejecutamos el comando slapcat. sudo slapcat dn: dc=pandora,dc=ldap objectClass: top objectClass: dcObject objectClass: organization o: pandora dc: pandora structuralObjectClass: organization entryUUID: 7b982cc0-d599-103a-93b2-3d7047cfd04f creatorsName: cn=admin,dc=pandora,dc=ldap createTimestamp: 20201218162610Z entryCSN: 20201218162610.450021Z#000000#000#000000 modifiersName: cn=admin,dc=pandora,dc=ldap modifyTimestamp: 20201218162610Z dn: cn=admin,dc=pandora,dc=ldap objectClass: simpleSecurityObject objectClass: organizationalRole cn: admin description: LDAP administrator userPassword:: e1NTSEF9MmRTdDVqK0ZtVFJpdFAwQ0g4QmkyNUkwK242dFcxakc= structuralObjectClass: organizationalRole entryUUID: 7b9b37a8-d599-103a-93b3-3d7047cfd04f creatorsName: cn=admin,dc=pandora,dc=ldap createTimestamp: 20201218162610Z entryCSN: 20201218162610.470043Z#000000#000#000000 modifiersName: cn=admin,dc=pandora,dc=ldap modifyTimestamp: 20201218162610Z dn: ou=usuarios,dc=pandora,dc=ldap objectClass: organizationalUnit objectClass: top ou: usuarios structuralObjectClass: organizationalUnit entryUUID: 4159df9c-d74a-103a-86e5-c92b1d7a3d24 creatorsName: cn=admin,dc=pandora,dc=ldap createTimestamp: 20201220200404Z entryCSN: 20201220200404.817837Z#000000#000#000000 modifiersName: cn=admin,dc=pandora,dc=ldap modifyTimestamp: 20201220200404Z dn: ou=grupos,dc=pandora,dc=ldap objectClass: organizationalUnit objectClass: top ou: grupos structuralObjectClass: organizationalUnit entryUUID: 416283fe-d74a-103a-86e6-c92b1d7a3d24 creatorsName: cn=admin,dc=pandora,dc=ldap createTimestamp: 20201220200404Z entryCSN: 20201220200404.874510Z#000000#000#000000 modifiersName: cn=admin,dc=pandora,dc=ldap modifyTimestamp: 20201220200404Z dn: cn=devops,ou=grupos,dc=pandora,dc=ldap objectClass: posixGroup cn: devops gidNumber: 10000 memberUid: devops structuralObjectClass: posixGroup entryUUID: fdac9144-d7f4-103a-86e7-c92b1d7a3d24 creatorsName: cn=admin,dc=pandora,dc=ldap createTimestamp: 20201221162615Z entryCSN: 20201221162615.215505Z#000000#000#000000 modifiersName: cn=admin,dc=pandora,dc=ldap modifyTimestamp: 20201221162615Z dn: uid=mordecai,ou=usuarios,dc=pandora,dc=ldap objectClass: inetOrgPerson objectClass: posixAccount objectClass: shadowAccount cn: Mordecai sn: Geek userPassword:: e1NTSEF9Z0d1eUZkMGlyVld5WkNkSUNRN1AySytUUENPQ0I5ZUI= loginShell: /bin/bash uidNumber: 10000 gidNumber: 10000 homeDirectory: /home/mordecai structuralObjectClass: inetOrgPerson uid: mordecai entryUUID: fdb16106-d7f4-103a-86e8-c92b1d7a3d24 creatorsName: cn=admin,dc=pandora,dc=ldap createTimestamp: 20201221162615Z entryCSN: 20201221162615.247033Z#000000#000#000000 modifiersName: cn=admin,dc=pandora,dc=ldap modifyTimestamp: 20201221162615Z","title":"Practica02 LDAP"},{"location":"04_LDAP/Practica03_LDAP.html","text":"Ahora vamos a configurar un equipo cliente con el fin de poder iniciar sesi\u00f3n en \u00e9l a partir de un usuario creado en el directorio LDAP. Comenzamos instalando la paqueter\u00eda necesaria: sudo apt install libnss-ldap libpam-ldap ldap-utils Autom\u00e1ticamente se nos abrir\u00e1 el asistente de configuraci\u00f3n donde indicaremos los datos de nuestro servidor donde se encuentra instalado el directorio LDAP. En primer lugar, nos solicita la direcci\u00f3n URI del servidor. Sustituiremos la cadena por la que se muestra en la imagen. A continuaci\u00f3n escribiremos el nombre distinguido \u00fanico (DN) de nuestro directorio LDAP. En el siguiente paso nos dan a elegir la versi\u00f3n del protocolo LDAP que vamos utilizar. Elegimos la versi\u00f3n m\u00e1s actual, en este caso la 3. Ahora indicaremos si las aplicaciones que utilicen PAM deber\u00e1n comportarse del mismo modo que cuando cambiamos contrase\u00f1as locales. Esto har\u00e1 que las contrase\u00f1as se almacenen en un fichero independiente que s\u00f3lo podr\u00e1 ser le\u00eddo por root. Elegimos que SI. Luego nos pregunta si queremos que sea necesario identificarse para realizar consultas en la base de datos del directorio LDAP. Elegimos que NO. En el siguiente paso indicaremos el nombre de la cuenta LDAP con privilegios para realizar cambios en las contrase\u00f1as. Dicha cuenta ser\u00e1 la del administrador de nuestro directorio LDAP, indicaremos su DN completo. Y por \u00faltimo, nos solicita la contrase\u00f1a de la cuenta que hemos indicado justo antes (la que indicamos para el administrador en el asistente de configuraci\u00f3n de OpenLDAP). Habr\u00e1 que escribirla por duplicado. Una vez finalizado el asistente de configuraci\u00f3n, vamos a realizar modificaciones en el fichero /etc/nsswitch.conf. Indicaremos al sistema que realice b\u00fasquedas sobre usuarios en el directorio LDAP adem\u00e1s de en el propio sistema. sudo nano /etc/nsswitch.conf Ahora tenemos que realizar modificaciones en el fichero /etc/pam.d/common-password. En \u00e9l eliminaremos la cadena use_authtok de la l\u00ednea 26. Quitando dicha cadena, el sistema nos permitir\u00e1 usar varios m\u00e9todos de autenticaci\u00f3n. sudo nano /etc/pam.d/common-password Por \u00faltimo, modificaremos el fichero /etc/pam.d/common-session. A\u00f1adiremos una l\u00ednea al final del fichero para indicar que cuando un usuario de LDAP inicie sesi\u00f3n en el sistema, se cree su directorio Home en el equipo. sudo nano /etc/pam.d/common-session session optional pam_mkhomedir.so skel=/etc/skel umask=077 Una vez realizados todos los cambios en los ficheros anteriores, podemos comprobar la interacci\u00f3n entre equipo cliente y servidor de directorio LDAP. Para ello podemos lanzar una b\u00fasqueda a trav\u00e9s de la terminal y veremos si nos responde. ldapsearch -x -H ldap://192.168.1.90 -b \"dc=pandora,dc=ldap\" Como podemos ver, el servidor LDAP nos responde mostr\u00e1ndonos el resultado a la b\u00fasqueda que hemos realizado, que en este caso se trata de todas las entradas que se encuentran definidas en \u00e9l. En el punto donde nos encontramos, ya tenemos nuestro directorio LDAP configurado, poblado y funcionando en nuestro servidor. Y nuestro equipo cliente configurado para poder conectar con el servicio de directorio y poder iniciar sesi\u00f3n en el sistema con usuarios registrados en LDAP (Ojo! De momento, solo a trav\u00e9s de consola.) Vamos a hacer una prueba de inicio de sesi\u00f3n por consola y veremos como tambi\u00e9n se crea el directorio Home del usuario registrado en LDAP. Antes que nada, visualizamos el contenido del directorio /home y vemos que ahora mismo solo existe el de usuario. ll /home Ahora abrimos un nuevo entorno de terminal tecleando Ctrl + Alt + F5, e iniciaremos sesi\u00f3n con el usuario mordecai que hemos registrado anteriormente en LDAP. Como podremos ver, al iniciar sesi\u00f3n se creara en el equipo cliente el directorio /home/mordecai. Podemos lanzar algunos comandos m\u00e1s para verificar la identidad del usuario y ver que pertenece al grupo devops tal y como creamos las entradas en nuestro directorio LDAP. Adem\u00e1s tambi\u00e9n verificaremos que el directorio /home/mordecai pertenece y se ha creado con los permisos necesarios para dicho usuario. id pwd ll /home Como hemos mencionado antes, hasta ahora solo era posible iniciar sesi\u00f3n en el equipo cliente por terminal. Ahora vamos a realizar lo necesario para que sea posible, tambi\u00e9n, iniciar sesi\u00f3n con usuarios de LDAP en modo gr\u00e1fico. Para ello comenzamos instalando el paquete nslcd. sudo apt install nslcd Al instalar el paquete, se abrir\u00e1 un asistente de configuraci\u00f3n autom\u00e1ticamente donde tendremos que indicar nuevamente la URI de nuestro servidor LDAP y su DN (Distinguished Name). Probablemente los datos vengan ya indicados por lo que solo pulsaremos Aceptar en ambas ventanas sin necesidad de modificar nada. Al terminal de instalar el paquete, debemos reiniciar nuestro sistema para un correcto funcionamiento. Reiniciamos el equipo cliente. Y tras reiniciar ya podremos iniciar sesi\u00f3n con nuestro usuario Mordecai, directamente desde la pantalla de Login del sistema. Tras iniciar sesi\u00f3n, se crear\u00e1 un perfil para el usuario y ya podr\u00e1 usar el sistema de forma completamente gr\u00e1fica adem\u00e1s de por terminal. Podemos verificar la identidad del usuario desde consola y veremos que sigue siendo tal cual lo configuramos en nuestro directorio LDAP.","title":"Practica03 LDAP"},{"location":"04_LDAP/ProgramacionAula.html","text":"Programaci\u00f3n de Aula \u00b6 Resultados de Aprendizaje \u00b6 Esta unidad cubre pel Resultado de aprendizaje 1 (RA1) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han identificado la funci\u00f3n, los elementos y las estructuras l\u00f3gicas del servicio de directorio. b. Se ha determinado y creado el esquema del servicio de directorio. c. Se ha realizado la instalaci\u00f3n del servicio de directorio en el servidor. d. Se ha realizado la configuraci\u00f3n y personalizaci\u00f3n del servicio de directorio. e. Se ha integrado el servicio de directorio con otros servicios. f. Se han aplicado filtros de b\u00fasqueda en el servicio de directorio.. g. Se ha utilizado el servicio de directorio como mecanismo de acreditaci\u00f3n centralizada de los usuarios en una red. h. Se ha realizado la configuraci\u00f3n del cliente para su integraci\u00f3n en el servicio de directorio. i. Se han utilizado herramientas gr\u00e1ficas y comandos para la administraci\u00f3n del servicio de directorio. j. Se ha documentado la estructura e implantaci\u00f3n del servicio de directorio. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } Planificaci\u00f3n Temporal \u00b6 Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 26/10/22 Introducci\u00f3n Servicios de directorio y LDAP. Introducci\u00f3n Servicios de directorio y LDAP. 2 27/10/22 Instalaci\u00f3n y configuraci\u00f3n de OpenLDAP. Instalaci\u00f3n y configuraci\u00f3n de OpenLDAP. 3 2/11/22 Modelo de Informaci\u00f3n de LDAP. Modelo de Informaci\u00f3n de LDAP. 4 3/11/22 Esquema de LDAP. Esquema de LDAP. 5 8/10/22 Creaci\u00f3n de usuarios y grupos OpenLDAP Creaci\u00f3n de usuarios y grupos OpenLDAP 6 9/11/22 Configuraci\u00f3n de equipo cliente. Configuraci\u00f3n de equipo cliente.","title":"Programaci\u00f3n de Aula"},{"location":"04_LDAP/ProgramacionAula.html#programacion-de-aula","text":"","title":"Programaci\u00f3n de Aula"},{"location":"04_LDAP/ProgramacionAula.html#resultados-de-aprendizaje","text":"Esta unidad cubre pel Resultado de aprendizaje 1 (RA1) seg\u00fan el Real Decreto 1629/2009, de 30 de octubre , el cual es: Administra el servicio de directorio interpretando especificaciones e integr\u00e1ndolo en una red. Los criterios de evaluaci\u00f3n asociados son: ol.criterio { list-style-type: none; } a. Se han identificado la funci\u00f3n, los elementos y las estructuras l\u00f3gicas del servicio de directorio. b. Se ha determinado y creado el esquema del servicio de directorio. c. Se ha realizado la instalaci\u00f3n del servicio de directorio en el servidor. d. Se ha realizado la configuraci\u00f3n y personalizaci\u00f3n del servicio de directorio. e. Se ha integrado el servicio de directorio con otros servicios. f. Se han aplicado filtros de b\u00fasqueda en el servicio de directorio.. g. Se ha utilizado el servicio de directorio como mecanismo de acreditaci\u00f3n centralizada de los usuarios en una red. h. Se ha realizado la configuraci\u00f3n del cliente para su integraci\u00f3n en el servicio de directorio. i. Se han utilizado herramientas gr\u00e1ficas y comandos para la administraci\u00f3n del servicio de directorio. j. Se ha documentado la estructura e implantaci\u00f3n del servicio de directorio. .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; }","title":"Resultados de Aprendizaje"},{"location":"04_LDAP/ProgramacionAula.html#planificacion-temporal","text":"Sesi\u00f3n. Fecha Contenido Recurso Did\u00e1ctico 1 26/10/22 Introducci\u00f3n Servicios de directorio y LDAP. Introducci\u00f3n Servicios de directorio y LDAP. 2 27/10/22 Instalaci\u00f3n y configuraci\u00f3n de OpenLDAP. Instalaci\u00f3n y configuraci\u00f3n de OpenLDAP. 3 2/11/22 Modelo de Informaci\u00f3n de LDAP. Modelo de Informaci\u00f3n de LDAP. 4 3/11/22 Esquema de LDAP. Esquema de LDAP. 5 8/10/22 Creaci\u00f3n de usuarios y grupos OpenLDAP Creaci\u00f3n de usuarios y grupos OpenLDAP 6 9/11/22 Configuraci\u00f3n de equipo cliente. Configuraci\u00f3n de equipo cliente.","title":"Planificaci\u00f3n Temporal"},{"location":"04_LDAP/ResumenUD.html","text":"Resumen UD \u00b6 A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. IC1. Actividades DESARROLLO (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 108 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 109 a la 111 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 112 a la 115 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 116 a la 119 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. IC1. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 120 a la 122 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Prueba de Auditor\u00eda. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Cuestionario multi-opci\u00f3n (test) de 20 preguntas sobre la teor\u00eda de la unidad. Ejercicios pr\u00e1cticos sobre las actividades realizadas de la unidad. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1 e IC2.","title":"Resumen UD"},{"location":"04_LDAP/ResumenUD.html#resumen-ud","text":"A continuaci\u00f3n se muestra un resumen de la Unidad Did\u00e1ctica: .heatMap td { text-align: left; padding-left: 10px; } table caption { padding: 10px; background: #0077b6; border-style: solid; border-width: 2px; border-color: #060606; font-weight: bold; } RESUMEN UNIDAD DID\u00c1CTICA Unidad Did\u00e1ctica UD1.- ShellScripting. Realizaci\u00f3n de Guiones en Sistemas Operativos Libres. Horas 6 Sesiones - 12 Horas Resultados de Aprendizaje RA7. Utiliza lenguajes de guiones en sistemas operativos, describiendo su aplicaci\u00f3n y administrando servicios del sistema operativo. Preconocimiento Funcionamiento del terminal de Linux/GNU. Aplicaci\u00f3n de comandos. Utilizaci\u00f3n de editores. Conocimiento de permisos de archivos. Objetivos Operativos Competencias Personales y Sociales. Transversales Administraci\u00f3n de terminal de Linux/GNU. Conocer comandos b\u00e1sicos y avanzados en Shell. Optimizar el c\u00f3digo de los scripts mediante tuber\u00edas y redirecciones. 14 . Gestionar y/o realizar el mantenimiento de los recursos de su \u00e1rea (programando y verificando su cumplimiento), en funci\u00f3n de las cargas de trabajo y el plan de mantenimiento. 16 . Mantener el esp\u00edritu de innovaci\u00f3n y actualizaci\u00f3n en el \u00e1mbito de su trabajo para adaptarse a los cambios tecnol\u00f3gicos y organizativos de su entorno profesional. Contenidos conceptuales Introducci\u00f3n Linux. Creaci\u00f3n ShellScripts. Depuraci\u00f3n. Argumentos, variables, operadores; Entrada y Salida. Control de Flujo. Estructuras condicionales e iterativas. Funciones y vectores. Instrumentos Evaluaci\u00f3n Actividades INICIALES (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 101 a la 104 . Basadas en Scripts de nivel bajo, en concreto, sobre el desarrollo de: Creaci\u00f3n primeros scripts de nivel bajo Depuraci\u00f3n de scripts. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietarios. CE7i. Se han documentado los guiones creados. IC1. Actividades DESARROLLO (IE1). Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 105 a la 108 . Interacci\u00f3n con usuario, utilizaci\u00f3n de variables, par\u00e1metros y operadores. Actividades desde la 109 a la 111 . Control de Flujo. Estructuras condicionales e iterativas. Actividades desde la 112 a la 115 . Vectores y funciones. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Actividades Refuerzo. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 116 a la 119 . Variables, par\u00e1metros, comprobaciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7i. Se han documentado los guiones creados. IC1. Actividades Ampliaci\u00f3n. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Actividades desde la 120 a la 122 . Vectores, funciones, estructuras condicionales e iterativas. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1. Prueba de Auditor\u00eda. Criterios Evaluaci\u00f3n Instrumento Calificaci\u00f3n Cuestionario multi-opci\u00f3n (test) de 20 preguntas sobre la teor\u00eda de la unidad. Ejercicios pr\u00e1cticos sobre las actividades realizadas de la unidad. CE7a. Se han utilizado y combinado las estructuras del lenguaje para crear guiones. CE7b. Se han utilizado herramientas para depurar errores sint\u00e1cticos y de ejecuci\u00f3n. CE7g. Se han implantado guiones en sistemas libres y propietario. CE7h. Se han consultado y utilizado librer\u00edas de funciones. CE7i. Se han documentado los guiones creados. IC1 e IC2.","title":"Resumen UD"}]}